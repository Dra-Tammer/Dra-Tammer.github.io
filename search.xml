<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cpp-lea</title>
    <url>/posts/2bd5d61f.html</url>
    <content><![CDATA[<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">"hello world"</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"></span><br><span class="line">cin &gt;&gt; 变量</span><br><span class="line"><span class="comment">//键盘输入数据</span></span><br><span class="line">整型</span><br><span class="line"><span class="type">int</span> a =<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line"></span><br><span class="line">浮点型</span><br><span class="line"><span class="type">float</span> f = <span class="number">3.14f</span>;</span><br><span class="line">cin&gt;&gt;f;</span><br><span class="line"></span><br><span class="line">字符型</span><br><span class="line"><span class="type">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line">cin&gt;&gt;ch;</span><br><span class="line"></span><br><span class="line">字符串</span><br><span class="line">string str = <span class="string">"fengshenglongshiwoer"</span>;</span><br><span class="line">cin &gt;&gt; str ;</span><br><span class="line"><span class="comment">//无论是输出还是输入字符串，要包含string的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">布尔类型</span><br><span class="line">    </span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">cin&gt;&gt;flag;</span><br><span class="line">输入<span class="number">0</span>是假，输入其他的数为真（绝对值大于<span class="number">1</span>）</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//函数的声明，提前告诉编译器函数的存在，这样可以把函数的定义写在main函数的后面</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a &gt;b?a:b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="函数的分文件编写"><a href="#函数的分文件编写" class="headerlink" title="函数的分文件编写"></a>函数的分文件编写</h2><p>1.创建后缀名为.h的文件</p>
<p>2.创建后缀名为.cpp的源文件</p>
<p>3.在头文件中写函数的声明</p>
<p>4.在源文件中写函数的定义</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//函数的声明</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ceshi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//函数的定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ceshi.h"</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ceshi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b )</span> </span>{</span><br><span class="line">	<span class="type">int</span> temp =a ;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">	cout&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">"b="</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//函数的使用，每次使用的时候，都需要</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ceshi.h"</span>引入</span></span><br><span class="line">****************************************</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ceshi.h"</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	 <span class="type">int</span> a =<span class="number">10</span> ;</span><br><span class="line">	 <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	 <span class="built_in">ceshi</span>(a,b);</span><br><span class="line">	 <span class="built_in">system</span>(<span class="string">"pause"</span>); </span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>通过指针间接访问内存</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 数据类型 * 指针变量名</span></span><br><span class="line"><span class="type">int</span> a =<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> * p = &amp;a;</span><br><span class="line">(</span><br><span class="line">    <span class="type">int</span> * p = &amp;a;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 指针前加上*代表解引用，找到指针指向的内存中的数据</span></span><br><span class="line">*p == <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="空指针和野指针"><a href="#空指针和野指针" class="headerlink" title="空指针和野指针"></a>空指针和野指针</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 空指针指向内存中编号为0的空间，用于初始化指针变量，一开始不知道这个破指针干啥用，空指针指向的内存是不可以访问的（0~255之间的内存编号是系统占用的，因此不可以访问</span></span><br><span class="line"><span class="type">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 野指针，指针指向非法的空间</span></span><br><span class="line"><span class="type">int</span> * p = (<span class="type">int</span> *) <span class="number">0x1100</span>;</span><br><span class="line"><span class="comment">// 这就是一个野指针</span></span><br><span class="line">** 空指针和野指针都不是我们申请的空间，因此不要访问</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Const修饰指针"><a href="#Const修饰指针" class="headerlink" title="Const修饰指针"></a>Const修饰指针</h3><p>1.修饰指针，常量指针</p>
<p>2.修饰常量，指针常量</p>
<p>3.既修饰指针，又修饰常量</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * p = &amp;a;</span><br><span class="line"><span class="comment">// 指针的指向可以修改，指针指向的值不可以改</span></span><br><span class="line">p = &amp;b; <span class="comment">//true</span></span><br><span class="line">*p = <span class="number">20</span>; <span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;a;</span><br><span class="line"><span class="comment">// 指针常量，指针的指向不可以改，指针指向的值可以修改</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;a;</span><br><span class="line"><span class="comment">// 指针的指向和指针指向的值都不可以修改</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line"><span class="type">int</span> * p = arr;</span><br><span class="line">p++; <span class="comment">//向后偏移四个字节</span></span><br><span class="line"><span class="comment">//指向arr的首地址</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt;<span class="number">10</span>;i++) {</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt;endl;</span><br><span class="line">    p++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>指针和函数跟c差不多</p>
<h2 id="核心编程"><a href="#核心编程" class="headerlink" title="核心编程"></a>核心编程</h2><blockquote>
<p>面向对象的编程思想</p>
</blockquote>
<h3 id="内存的分区模型"><a href="#内存的分区模型" class="headerlink" title="内存的分区模型"></a>内存的分区模型</h3><p>代码区：存放函数体的二进制代码，操作系统管理（共享，只读）</p>
<p>全局区：全局变量，静态变量和常量（程序结束后由操作系统释放）</p>
<p>栈区：注意不要返回局部变量的地址，因为编译器自动分配释放。存放函数的参数值，局部变量等</p>
<blockquote>
<p>指针的本质也是局部变量，指针保存的数据是放在堆区</p>
</blockquote>
<p>堆区：程序员分配和释放，不释放的话由操作系统回收。</p>
<blockquote>
<p>主要利用new在堆区中开辟内存。</p>
<p>delete 释放</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> * p = <span class="keyword">new</span> <span class="built_in">int</span> (<span class="number">10</span>); <span class="comment">// new返回开辟的空间的地址</span></span><br><span class="line"><span class="keyword">delete</span> p ; <span class="comment">// 释放内存空间</span></span><br></pre></td></tr></tbody></table></figure>

<p>不同的区域存放的数据，赋予不同的生命周期，最大的灵活编程</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>本质：给变量起别名</p>
<p>语法：数据类型 &amp;别名 = 原名</p>
<blockquote>
<p>引用必须初始化</p>
<p>引用在初始化后，就不可以更改了（b是给a起的别名，c的别名不可以是b）</p>
<p>本质就是指针常量</p>
</blockquote>
<h4 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h4><p>函数传参时，可以利用引用的技术让形参修饰实参</p>
<p>可以简化指针修改实参</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span> </span>{</span><br><span class="line">    <span class="type">int</span> t = a ;</span><br><span class="line">    a = b ;</span><br><span class="line">    b = t ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span> ; </span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span> ;</span><br><span class="line">    <span class="built_in">swap</span>(a,b) ;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"pause"</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 引用传递和地址传递都可以修饰实参，但是值传递不可以</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="引用做函数的返回值"><a href="#引用做函数的返回值" class="headerlink" title="引用做函数的返回值"></a>引用做函数的返回值</h4><p>不要返回局部变量引用</p>
<p>函数调用可以作为左值，等号的左边</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> &amp;ref = <span class="built_in">test</span>();</span><br><span class="line">    cout&lt;&lt;ref&lt;&lt;endl; <span class="comment">// 正常打印出10 因为编译器做了保留</span></span><br><span class="line">    cout&lt;&lt;ref&lt;&lt;endl; <span class="comment">// 第二次结果错误，因为a的内存已经释放</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">***************************************************************</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> &amp;ref = <span class="built_in">test</span>();</span><br><span class="line">    cout&lt;&lt;ref&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ref&lt;&lt;endl; <span class="comment">// 这样就没问题</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h4><p>常量引用修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加const修饰形参，防止形参改变实参</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ceshi</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;val)</span> </span>{</span><br><span class="line">    val = <span class="number">100</span>; <span class="comment">//这句会报告，必须是可修改的左值</span></span><br><span class="line">    <span class="type">const</span> &lt;&lt; <span class="string">"val = "</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">ceshi</span>(a);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b = <span class="number">10</span>,<span class="type">int</span> c = <span class="number">10</span>)</span> </span>{</span><br><span class="line">   <span class="keyword">return</span> a + b+ c ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="函数的占位参数"><a href="#函数的占位参数" class="headerlink" title="函数的占位参数"></a>函数的占位参数</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> )</span> </span>{</span><br><span class="line">     cout &lt;&lt;<span class="string">"this is func"</span> &lt;&lt; endl; <span class="comment">// 函数占位参数，占位参数也可以有默认参数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">20</span>,<span class="number">210</span>) ; <span class="comment">//占位函数必须要填补</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h3><p>函数名可以相同，提高代码的复用性</p>
<p>需要满足的条件</p>
<blockquote>
<p>同一个作用域下</p>
<p>函数的名称相同</p>
<p>函数参数类型不同，或者个数不同，或者顺序不同</p>
</blockquote>
<h4 id="函数重载的注意事项"><a href="#函数重载的注意事项" class="headerlink" title="函数重载的注意事项"></a>函数重载的注意事项</h4><blockquote>
<p>函数的返回值不可以作为函数重载的条件</p>
</blockquote>
<h4 id="引用作为重载的条件"><a href="#引用作为重载的条件" class="headerlink" title="引用作为重载的条件"></a>引用作为重载的条件</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">( <span class="type">int</span> &amp;a  )</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"func(int &amp;a)调用"</span> &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">调用: <span class="type">int</span> a = <span class="number">10</span> ;</span><br><span class="line">        <span class="built_in">func</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span> </span>{</span><br><span class="line">    cout````````````n </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">调用: <span class="built_in">func</span>( <span class="number">10</span> );  </span><br></pre></td></tr></tbody></table></figure>

<h4 id="函数重载碰到函数默认参数"><a href="#函数重载碰到函数默认参数" class="headerlink" title="函数重载碰到函数默认参数"></a>函数重载碰到函数默认参数</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 当函数重载碰到默认参数，出现二义性，报错，尽量避免这样的情况</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h4><blockquote>
<p>默认的访问权限不同</p>
</blockquote>
<p>struct 的默认权限为公共</p>
<p>class 的默认权限是私有</p>
<p>对象身上有属性和行为，类中的属性和行为都称为成员</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><blockquote>
<p>属性和行为作为一个整体，表现生活中的事物</p>
<p>将属性和行为加以权限控制</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> </span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">c</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*m;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setname</span><span class="params">(string name)</span> </span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        m_name = name;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    circle c1 ; <span class="comment">// 创建对象</span></span><br><span class="line">    c1.m = <span class="number">10</span>;</span><br><span class="line">    s1.<span class="built_in">setname</span>(<span class="string">"张三"</span>);</span><br><span class="line">    c1.<span class="built_in">c</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="public-公共权限"><a href="#public-公共权限" class="headerlink" title="public 公共权限"></a>public 公共权限</h5><blockquote>
<p>成员的类内可以访问，类外也可以访问</p>
</blockquote>
<h5 id="protected-保护权限"><a href="#protected-保护权限" class="headerlink" title="protected 保护权限"></a>protected 保护权限</h5><blockquote>
<p>成员的类内可以访问，类外不可以访问，儿子可以访问父亲中的保护的内容</p>
</blockquote>
<h5 id="private-私有权限"><a href="#private-私有权限" class="headerlink" title="private 私有权限"></a>private 私有权限</h5><blockquote>
<p>成员的类内可以访问，类外不可以访问，儿子不可以知道私有权限内容</p>
</blockquote>
<blockquote>
<p>可以自己控制读写权限</p>
<p>对于写可以检测数据的有效性</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> </span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>{</span><br><span class="line">         myname = name ;</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">private</span> :</span><br><span class="line">         string name:</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h4><h5 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h5><p>编译器自动调用，如果我们不提供构造和析构，编译器会提供，但是编译器提供的函数是空函数</p>
<p>构造函数：创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用</p>
<p>析构函数：对象销毁前系统自动调用，执行一些清理的工作</p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>类名 （） {<br>}</p>
<p>没有返回值也不写void</p>
<p>函数名称与类名相同</p>
<p>可以有参数，因此可以发生重载</p>
<p>程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次</p>
<h5 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h5><p>~类名（） {</p>
<p>}</p>
<p>没有返回值也不写void</p>
<p>函数名称与类名相同，前面加上~</p>
<p>不可以有参数，所以不可以发生重载</p>
<p>程序在对象销毁前会自动调用析构函数，无须手动调用，而且只会调用一次</p>
<h5 id="构造函数的分类和调用"><a href="#构造函数的分类和调用" class="headerlink" title="构造函数的分类和调用"></a>构造函数的分类和调用</h5><blockquote>
<p>两种分类方式：</p>
<p>​	按参数分为： 有参构造和无参构造</p>
<p>​	按类型分为： 普通构造和拷贝构造</p>
</blockquote>
<blockquote>
<p>三种调用方式：</p>
<p>​	括号法</p>
<p>​	显示法</p>
<p>​	隐式转换法</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"无参构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) {</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">"有参构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) {</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">"拷贝构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"析构函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">	Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.1  括号法，常用</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">	<span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.2 显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">	<span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.3 隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">	Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">	<span class="comment">//Person p5(p4);</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h5><p>C++提供了初始化列表语法，用来初始化属性</p>
<p><code>构造函数()：属性1(值1),属性2（值2）... {}</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">////传统方式初始化</span></span><br><span class="line">	<span class="comment">//Person(int a, int b, int c) {</span></span><br><span class="line">	<span class="comment">//	m_A = a;</span></span><br><span class="line">	<span class="comment">//	m_B = b;</span></span><br><span class="line">	<span class="comment">//	m_C = c;</span></span><br><span class="line">	<span class="comment">//}</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) {}</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"mA:"</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">"mB:"</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">"mC:"</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h5><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() {</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line">	<span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"mA:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>{</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="this指针的概念"><a href="#this指针的概念" class="headerlink" title="this指针的概念"></a>this指针的概念</h5><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="comment">//返回对象本身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"p1.age = "</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">	cout &lt;&lt; <span class="string">"p2.age = "</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h5><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"我是Person类!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) {</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Person * p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">	p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为  ==friend==</p>
<p>友元的三种实现</p>
<ul>
<li><p>全局函数做友元</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Building</span>()</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">"客厅"</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">"卧室"</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"好基友正在访问： "</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"好基友正在访问： "</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Building b;</span><br><span class="line">	<span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


</li>
<li><p>类做友元</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">"客厅"</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">"卧室"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">{</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"好基友正在访问"</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"好基友正在访问"</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


</li>
<li><p>成员函数做友元</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">"客厅"</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">"卧室"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">{</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"好基友正在访问"</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"好基友正在访问"</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"好基友正在访问"</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "好基友正在访问" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h5 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h5><p>作用实现两个自定义的数据类型的运算</p>
<blockquote>
<p>对于内置的数据类型的表达式的运算符是不可能改变的</p>
<p>不要滥用运算符重载</p>
</blockquote>
<h5 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h5><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h5><p><code>class A : public B; </code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"首页、公开课、登录、注册...（公共头部）"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"帮助中心、交流合作、站内地图...(公共底部)"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Java,Python,C++...(公共分类列表)"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"JAVA学科视频"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Python学科视频"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"C++学科视频"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"Java下载视频页面如下： "</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">"--------------------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"Python下载视频页面如下： "</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">"--------------------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"C++下载视频页面如下： "</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong></p>
<p>继承的好处：==可以减少重复的代码==</p>
<p>class A : public B; </p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h5 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h5><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Son2 s;</span><br><span class="line">	<span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">		<span class="comment">//m_A;</span></span><br><span class="line">		<span class="comment">//m_B;</span></span><br><span class="line">		<span class="comment">//m_C;</span></span><br><span class="line">	}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<blockquote>
<p>总结：</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p>
</blockquote>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p>
<p>文件类型分为两种：</p>
<ol>
<li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li>
<li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>操作文件的三大类:</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作</li>
</ol>
<h3 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h3><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>   写文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>#include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ofstream ofs;</p>
</li>
<li><p>打开文件</p>
<p>ofs.open(“文件路径”,打开方式);</p>
</li>
<li><p>写数据</p>
<p>ofs &lt;&lt; “写入的数据”;</p>
</li>
<li><p>关闭文件</p>
<p>ofs.close();</p>
</li>
</ol>
<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p>
<p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">"test.txt"</span>, ios::out);</span><br><span class="line"></span><br><span class="line">	ofs &lt;&lt; <span class="string">"姓名：张三"</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">"性别：男"</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">"年龄：18"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>文件操作必须包含头文件 fstream</li>
<li>读文件可以利用 ofstream  ，或者fstream类</li>
<li>打开文件时候需要指定操作文件的路径，以及打开方式</li>
<li>利用&lt;&lt;可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p>
<p>读文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>#include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ifstream ifs;</p>
</li>
<li><p>打开文件并判断文件是否打开成功</p>
<p>ifs.open(“文件路径”,打开方式);</p>
</li>
<li><p>读数据</p>
<p>四种方式读取</p>
</li>
<li><p>关闭文件</p>
<p>ifs.close();</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">"test.txt"</span>, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"文件打开失败"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种方式</span></span><br><span class="line">	<span class="comment">//char buf[1024] = { 0 };</span></span><br><span class="line">	<span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line">	<span class="comment">//{</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//}</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种</span></span><br><span class="line">	<span class="comment">//char buf[1024] = { 0 };</span></span><br><span class="line">	<span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line">	<span class="comment">//{</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//}</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种</span></span><br><span class="line">	<span class="comment">//string buf;</span></span><br><span class="line">	<span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line">	<span class="comment">//{</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//}</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>读文件可以利用 ifstream  ，或者fstream类</li>
<li>利用is_open函数可以判断文件是否打开成功</li>
<li>close 关闭文件</li>
</ul>
<h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 ==ios::binary==</p>
<h4 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、创建输出流对象</span></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">"person.txt"</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3、打开文件</span></span><br><span class="line">	<span class="comment">//ofs.open("person.txt", ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">	Person p = {<span class="string">"张三"</span>  , <span class="number">18</span>};</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、写文件</span></span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5、关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h4 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">"person.txt"</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"文件打开失败"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"姓名： "</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<ul>
<li>文件输入流对象 可以通过read函数，以二进制方式读数据</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/posts/f5f9fa9b.html</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="Windows配置Docker环境"><a href="#Windows配置Docker环境" class="headerlink" title="Windows配置Docker环境"></a>Windows配置Docker环境</h2><h3 id="启用Hyper-v"><a href="#启用Hyper-v" class="headerlink" title="启用Hyper-v"></a>启用Hyper-v</h3><ul>
<li>控制面板</li>
<li>程序</li>
<li>启动或关闭windows功能</li>
<li>Hyper-v</li>
</ul>
<h3 id="WSL及Linux分发版安装"><a href="#WSL及Linux分发版安装" class="headerlink" title="WSL及Linux分发版安装"></a>WSL及Linux分发版安装</h3><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">wsl --install </span><br><span class="line">wsl --list --online <span class="comment">// 查看可用的Linux发行版列表</span></span><br><span class="line">wsl --install -d <span class="title class_">Ubuntu</span>-<span class="number">22.04</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="修改WSL中系统的安装位置"><a href="#修改WSL中系统的安装位置" class="headerlink" title="修改WSL中系统的安装位置"></a>修改WSL中系统的安装位置</h3><ul>
<li><p>查看所有分发版本<code>wsl -l --all -v</code></p>
</li>
<li><p>导出分发版为tar文件到D盘<code>wsl --export Ubuntu-22.04 D:\Environment\ubuntu22.04.tar</code></p>
</li>
<li><p>注销当前分发版<code>wsl --unregister Ubuntu-22.04</code></p>
</li>
<li><p>重新导入并安装分发版在D盘</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">wsl --<span class="keyword">import</span> <span class="title class_">Ubuntu</span>-<span class="number">22.04</span> <span class="attr">D</span>:\<span class="title class_">Environment</span>\<span class="title class_">Ubuntu22</span><span class="number">.04</span> <span class="attr">D</span>:\<span class="title class_">Environment</span>\ubuntu22<span class="number">.04</span>.<span class="property">tar</span> --version <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置默认登录用户<code>ubuntu2204 config --default-user root</code></p>
</li>
<li><p>删除tar文件<code>del D:\ubuntu22.04.tar</code></p>
</li>
</ul>
<h3 id="DockerDesktop"><a href="#DockerDesktop" class="headerlink" title="DockerDesktop"></a>DockerDesktop</h3><p>官网下载安装<code>DockerDesktop</code>，最大的问题就是默认安装在c盘，十分占用c盘的空间</p>
<h4 id="更改DockerDesktop的安装目录"><a href="#更改DockerDesktop的安装目录" class="headerlink" title="更改DockerDesktop的安装目录"></a>更改DockerDesktop的安装目录</h4><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">cmd /c mklink /j <span class="string">"C:\Program Files\Docker"</span> <span class="string">"D:\SoftWare\DockerDesktop"</span></span><br></pre></td></tr></tbody></table></figure>

<p>实测创建连接的方法不可行，能安装上但是<code>Docker Engine</code>无法启动，会报错<code>Docker Desktop - WSL distro terminated abruptly</code>，看来只能装到C盘，先卸载，再删除链接目录<code>rmdir D:\Software\DockerDesktop</code></p>
<blockquote>
<p>todo: 镜像安装的文件夹，没法修改，导致下载会都下载到C盘很难受</p>
</blockquote>
<p><a href="https://docker.easydoc.net/doc/81170005/cCewZWoN/lTKfePfP">🎉 Docker 简介和安装 - Docker 快速入门 - 易文档 (easydoc.net)</a></p>
<h2 id="为什么使用docker"><a href="#为什么使用docker" class="headerlink" title="为什么使用docker"></a>为什么使用docker</h2><p>方便测试和生产环境部署，省去很多环境配置的时间</p>
<h2 id="和虚拟机的区别"><a href="#和虚拟机的区别" class="headerlink" title="和虚拟机的区别"></a>和虚拟机的区别</h2><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>每台虚拟机需要占用大量的资源，启动时间长。因为需要完整的操作系统，cpu占用等。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>docker只是container的一种的实现，是一种容器化的解决方案和平台。</p>
<p>容器不需要在虚拟化的环境中运行一个操作系统，而是使用宿主机的操作系统，启动速度非常快。需要的资源更少，充分利用物理服务器的资源。</p>
<h2 id="基本原理和概念"><a href="#基本原理和概念" class="headerlink" title="基本原理和概念"></a>基本原理和概念</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>镜像是一个只读的模板，它可以用来创建容器。</p>
<h3 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h3><p>容器是docker的运行实例，他提供了一个独立的可移植的环境。可以在这个环境中运行应用程序。镜像和容器的关系就像java中类和实例的关系一样。</p>
<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>存储docker镜像的地方，最流行也是常用的仓库就是dockerhub，公共的docker仓库。</p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>Client-Server架构模式，</p>
<h2 id="容器化和Dockerfile"><a href="#容器化和Dockerfile" class="headerlink" title="容器化和Dockerfile"></a>容器化和Dockerfile</h2><ol>
<li>创建一个Dockerfile</li>
<li>使用Dockerfile构建镜像</li>
<li>使用镜像创建和运行容器</li>
</ol>
<blockquote>
<p>如果想要在浏览器之外的环境运行javascipt的代码，就要安装node.js，通过<code>node index.js</code>运行index文件的代码</p>
</blockquote>
<h2 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h2><h3 id="镜像的构建"><a href="#镜像的构建" class="headerlink" title="镜像的构建"></a>镜像的构建</h3><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">docker build <span class="literal">-t</span> hello<span class="literal">-docker</span> .</span><br></pre></td></tr></tbody></table></figure>

<h3 id="镜像的运行"><a href="#镜像的运行" class="headerlink" title="镜像的运行"></a>镜像的运行</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">docker run hello-docker</span><br></pre></td></tr></tbody></table></figure>

<h3 id="查看镜像库"><a href="#查看镜像库" class="headerlink" title="查看镜像库"></a>查看镜像库</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></tbody></table></figure>

<h2 id="推荐网站"><a href="#推荐网站" class="headerlink" title="推荐网站"></a>推荐网站</h2><p>play-with-docker 尝试docker的各种功能</p>
<h2 id="docker-desktop"><a href="#docker-desktop" class="headerlink" title="docker-desktop"></a>docker-desktop</h2><p>docker数据是非持久化的，需要持久化就使用Volumes功能。</p>
<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><ul>
<li>用于定义和运行多容器Docker应用程序的工具</li>
<li>使用YAML文件来配置应用程序的服务</li>
<li>一条命令就可以创建并启动所有服务</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>docker</category>
        <category>部署</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Free-Talk-1</title>
    <url>/posts/f098273e.html</url>
    <content><![CDATA[<h3 id="Free-Talk"><a href="#Free-Talk" class="headerlink" title="Free Talk"></a>Free Talk</h3><h4 id="1-The-favors-the-people-might-have"><a href="#1-The-favors-the-people-might-have" class="headerlink" title="1.The favors the people might have."></a>1.The favors the people might have.</h4><h4 id="思考的角度："><a href="#思考的角度：" class="headerlink" title="思考的角度："></a>思考的角度：</h4><p>思考的角度：具体的事情：带个饭什么的 照顾宠物。关于suggestion。重要的事情，别人会询问建议 假期到哪旅游，工作，房子，去哪玩，找什么性格的朋友，</p>
<h4 id="参考句型："><a href="#参考句型：" class="headerlink" title="参考句型："></a>参考句型：</h4><p>I was wondering if you could look after my pet ?</p>
<p>Give the message to somebody</p>
<p>where she could go</p>
<h4 id="Pre"><a href="#Pre" class="headerlink" title="Pre:"></a>Pre:</h4><p>Someone will ask you to borrow something ,lend something ,figure out something difficult for us .</p>
<p>When we are in a new place we hadn’t arrived before ,we need someone to ask for directions.</p>
<p>When we cannot figure out something difficult for a long time ,maybe a math or physics problem, we need someone to give us some tips .</p>
<p>When we need money urgently , we need someone who could lend us money.</p>
<p>When we forget to take our stationery ,such as pens rulers erasers and so on ,we could ask someone for help .</p>
<p>When we’re emotional ,we could find someone to talk to ,after that ,maybe we’re going to be relieved .</p>
<h4 id="2-What-are-three-favors-that-you-dislike-being-asked"><a href="#2-What-are-three-favors-that-you-dislike-being-asked" class="headerlink" title="2.What are three favors that you dislike being asked?"></a>2.What are three favors that you dislike being asked?</h4><h4 id="思考的角度：-1"><a href="#思考的角度：-1" class="headerlink" title="思考的角度："></a>思考的角度：</h4><p>买东西，查资料， 违背道德与法律的事因为别人的懒惰而要求的帮忙不会去帮，借东西不还的， 会让你产生情绪，厌倦，学会表达主观情绪</p>
<h4 id="参考句型：-1"><a href="#参考句型：-1" class="headerlink" title="参考句型："></a>参考句型：</h4><p>bring food .</p>
<p>download something I have absolutely no need for</p>
<p>I hate it when someone ask me to buy something to eat .</p>
<p>I hate it when someone …………</p>
<p>I let me down (upset)</p>
<p>It drivers me crazy when</p>
<p>You know I really hate one of those guys ,</p>
<h4 id="Pre-1"><a href="#Pre-1" class="headerlink" title="Pre:"></a>Pre:</h4><p>I wouldn’t like someone to ask me for money because I’m really poor .</p>
<p>I wouldn’t like someone to ask me for directions because I have a bad sense of direction.</p>
<p>I wouldn’t like someone to ask me for emotional advice between boy and girl ,because I truly need a hand too !</p>
<h4 id="3-Should-you-always-say-‘yes’-to-a-friend"><a href="#3-Should-you-always-say-‘yes’-to-a-friend" class="headerlink" title="3.Should you always say ‘yes’ to a friend?"></a>3.Should you always say ‘yes’ to a friend?</h4><h4 id="What-would-you-do-if-your-friend-asked-you-a-favor-you-didn’t-feel-good-about"><a href="#What-would-you-do-if-your-friend-asked-you-a-favor-you-didn’t-feel-good-about" class="headerlink" title="What would you do if your friend asked you a favor you didn’t feel good about?"></a>What would you do if your friend asked you a favor you didn’t feel good about?</h4><h4 id="思考的角度：-2"><a href="#思考的角度：-2" class="headerlink" title="思考的角度："></a>思考的角度：</h4><p>如果我不帮她没有人会帮 首先要正面回答这个问题， ,我不帮的话，我会把话讲明，解释自己的难处，我也像帮忙，但是其他人会做的更好，看你自己是个什么样的人 拒绝别人会很难受，给出具体的小的解释，如果他会容易生气，我不想和他交往，给出自己具体的 可以举一个例子，</p>
<h4 id="参考句型：-2"><a href="#参考句型：-2" class="headerlink" title="参考句型："></a>参考句型：</h4><p>Take care of yourself at first ,then you could have the power to help others</p>
<p>I always say yes</p>
<p>I don’t think I’m one of this kind of people</p>
<p>As for me ,as the saying goes ,you know what I mean yeah ?</p>
<h4 id="Pre："><a href="#Pre：" class="headerlink" title="Pre："></a>Pre：</h4><p>It depends on the situation ,if a friend in great need asks me for help ,I will lend a hand immediately and do what I can do , no matter how difficult the things they’re facing .</p>
<p>Because we’re brothers ,their problems are my problems .</p>
<p>To help others is to help ourselves, for the good we do will be returned to us.</p>
<p>I will lend a hand if the thing is helpful for them .</p>
<p>As the old saying says :” If a person only thinks of himself ,then in his life ,sad things must be more than the happy things .”</p>
<p>Conversely ,if I offer a hand ,I will get something cheerful and satisfied, even if the favor was what I didn’t feel good about .</p>
<h4 id="4-How-do-you-feel-when-people-do-not-return-things-they-borrowed-from-you？"><a href="#4-How-do-you-feel-when-people-do-not-return-things-they-borrowed-from-you？" class="headerlink" title="4. How do you feel when people do not return things they borrowed from you？"></a>4. How do you feel when people do not return things they borrowed from you？</h4><h4 id="思考的角度：-3"><a href="#思考的角度：-3" class="headerlink" title="思考的角度："></a>思考的角度：</h4><p>很久不还东西，当我急用的时候才发现自己已经借出去了。 表达自己的情绪，可以使用一些更加高级的表达.freetalk自述高阶版 可以写下来，语言是重复出来的，</p>
<h4 id="参考句型：-3"><a href="#参考句型：-3" class="headerlink" title="参考句型："></a>参考句型：</h4><p>It drives me crazy ,</p>
<p>I don’t want to make friends with such a person</p>
<p>he’s such a pain !</p>
<h4 id="Pre-2"><a href="#Pre-2" class="headerlink" title="Pre:"></a>Pre:</h4><p>I will feel not good ,no matter who they’re ,friends or strangers .</p>
<p>In my opinion, it’s necessary for us to return things we borrowed from someone in time .</p>
<p>On the one hand ,these things didn’t belong to us ,they’re others’ property . We have no power to take them for ourselves .</p>
<p>On the other hand , it indicates that other people think us dependable if they lent us something ,and we should not play with their trust in us .</p>
<p>What’s more , it will drives me crazy if I can’t find something when I need it urgently just because someone have borrowed it and haven’t returned it to me in time .</p>
<h4 id="When-was-the-last-time-you-owed-someone-an-apology"><a href="#When-was-the-last-time-you-owed-someone-an-apology" class="headerlink" title="When was the last time you owed someone an apology?"></a>When was the last time you owed someone an apology?</h4><h4 id="Pre-3"><a href="#Pre-3" class="headerlink" title="Pre:"></a>Pre:</h4><p>The last time I owed someone an apology was in the junior year in high school after I had a big quarrel with my best friend Wu .</p>
<p>That was in the evening after we have a supper together .</p>
<p>As we were walking to the classroom for the free period ,</p>
<p>we made jokes with each other .</p>
<p>But suddenly his face changed greatly , and he blamed me for what I said . he thought it inappropriate .</p>
<p>But I didn’t think so ,from my perspective ,it’s not a big deal.</p>
<p>So we had a big fight and didn’t take the initiative to find each other at all.</p>
<p>In retrospect, if I had offered to apologize, I might not have lost a friend .</p>
<p>What a pity !</p>
<h4 id="Something-Else"><a href="#Something-Else" class="headerlink" title="Something Else"></a>Something Else</h4><p>Believe or not .I don’t think I am this kind of person .I’m just the regular kind of guy .Actually I don’t think that’s very responsible to your friends .And it’s not good in a way to become more independent .</p>
<p>As the saying goes .Take your own decisions on your own matter .I will respond directly .I can’t do this things for you .Because I’m busy on things like studying .If she gets angry easily ,I don’t think this relationship is very reliable ,and I don’t want to talk to you this kind of person at all anymore .</p>
<p>How do you feel when people do not return things they borrowed from you ?</p>
<p>It really drives me crazy when somebody do not return things they have borrowed from me .</p>
<p>Have you met that half the time when this kind of person says he’s going to return you things in time when they borrowed it from you but he never actually does it .It drives me crazy .Such a pain .</p>
<p>朋友让帮忙买东西，网上查资料，借东西不还，帮忙买吃的</p>
<p>It really upsets me .</p>
<p>I hate it .</p>
<p>The thing that bothers me the most .</p>
]]></content>
      <categories>
        <category>Oral English</category>
        <category>Distance Class</category>
      </categories>
      <tags>
        <tag>free talk</tag>
      </tags>
  </entry>
  <entry>
    <title>Free-Talk-3</title>
    <url>/posts/1e964612.html</url>
    <content><![CDATA[<h4 id="1-Do-you-think-your-city-is-clean"><a href="#1-Do-you-think-your-city-is-clean" class="headerlink" title="1. Do you think your city is clean?"></a>1. Do you think your city is clean?</h4><h4 id="Pre"><a href="#Pre" class="headerlink" title="Pre:"></a>Pre:</h4><p>I don’t think my city is clean .</p>
<p>As your know ,I’m from Huainan in Anhui province ,which is a raw coal origin .</p>
<p>Large and small coal mines are scattered throughout the city .</p>
<p>Every time a coal truck goes by ,it will raises a cloud of dust .</p>
<p>The flowers and plants around the mine were covered with grey.</p>
<p>Since present Xi took office ,putting forward the proposition that green hills and clear waters are mountains of gold and silver ,things have changed.</p>
<h4 id="2-How-do-U-feel-when-seeing-people-throwing-rubbish-on-the-street"><a href="#2-How-do-U-feel-when-seeing-people-throwing-rubbish-on-the-street" class="headerlink" title="2. How do U feel when seeing people throwing rubbish on the street?"></a>2. How do U feel when seeing people throwing rubbish on the street?</h4><h4 id="Pre-1"><a href="#Pre-1" class="headerlink" title="Pre:"></a>Pre:</h4><p>Parents teach me to throw rubbish in to the rubbish .</p>
<p>Education .</p>
<p>That’s truly a terrible behavior .</p>
<p>They’re so inexperienced and selfish .</p>
<p>I may try to come forward and stop this behavior as possible as I can .</p>
<p>Or just tell them how much our environment needs our common protection and persuade them to pick the rubbish up and throw it into the rubbish bins.</p>
<h4 id="3-Why-do-some-people-like-to-throw-rubbish-on-the-street"><a href="#3-Why-do-some-people-like-to-throw-rubbish-on-the-street" class="headerlink" title="3. Why do some people like to throw rubbish on the street?"></a>3. Why do some people like to throw rubbish on the street?</h4><h4 id="Pre-2"><a href="#Pre-2" class="headerlink" title="Pre:"></a>Pre:</h4><p>They’re lazy to walk to the rubbish bin to throw rubbish .</p>
<p>They maybe think going to the rubbish bin to just throw a bottles is so unnecessary and it’s so convenient to just throw it on the ground .</p>
<p>And they may think the things that they throw everywhere is not a big deal ,and it will do a very little harm to our environment or just the things around them .</p>
<p>They’re so inexperienced and selfish that they didn’t realize what they’re doing is making our living environment worse and worse .</p>
<h4 id="4-What-can-U-do-to-make-the-city-cleaner"><a href="#4-What-can-U-do-to-make-the-city-cleaner" class="headerlink" title="4. What can U do to make the city cleaner?"></a>4. What can U do to make the city cleaner?</h4><h4 id="Pre-3"><a href="#Pre-3" class="headerlink" title="Pre:"></a>Pre:</h4><p>Take an active part in planting trees .</p>
<p>Don’t throw rubbish everywhere .</p>
<p>Persuade people around me to do something with me .</p>
<p>We can take actions step by step to make sure that we have a future to grow up in person by person ,family by family ,community by community together we can make a difference .</p>
<h4 id="5-Do-you-do-anything-to-protect-the-environment"><a href="#5-Do-you-do-anything-to-protect-the-environment" class="headerlink" title="5. Do you do anything to protect the environment?"></a>5. Do you do anything to protect the environment?</h4><h4 id="Pre-4"><a href="#Pre-4" class="headerlink" title="Pre:"></a>Pre:</h4><p>Yes, of course . My family and I reuse many items in my home ,cans ,bottles ,plastic bags and so on rather than throwing away .</p>
<p>I usually make sure we use recycle bins every time .</p>
<p>There’re many simple things we and our family can do around our house such as planting a tree for the community and watch it grow .</p>
<h4 id="6-Why-should-people-follow-the-law-on-environmental-protection"><a href="#6-Why-should-people-follow-the-law-on-environmental-protection" class="headerlink" title="6.Why should people follow the law on environmental protection ?"></a>6.Why should people follow the law on environmental protection ?</h4><h4 id="Pre-5"><a href="#Pre-5" class="headerlink" title="Pre:"></a>Pre:</h4><p>The earth is not only our home for survival, but also the home of other creatures in the world .</p>
<p>Therefore, it is our duty to protect the environment .</p>
<p>It could mitigate climate change and energy waste and reduce the threat of greenhouse effect to all human beings .</p>
<p>The climate change could destroy the world we’re living .</p>
<p>Some scientists predict that within 50 years many parts of our world could be under 20cm of water .</p>
<p>We can prevent this if we work together .</p>
<p>All these things we do now could not only save the environment but also save our money .</p>
<p>And it is a chance to preserve our future .</p>
]]></content>
      <categories>
        <category>Oral English</category>
        <category>Distance Class</category>
      </categories>
  </entry>
  <entry>
    <title>Free-Talk-2</title>
    <url>/posts/69917684.html</url>
    <content><![CDATA[<h4 id="1-Did-you-live-or-would-you-like-to-live-in-a-foreign-country-How-did-you-feel-or-would-you-feel-about-moving-there"><a href="#1-Did-you-live-or-would-you-like-to-live-in-a-foreign-country-How-did-you-feel-or-would-you-feel-about-moving-there" class="headerlink" title="1. Did you live(or would you like to live) in a foreign country? How did you feel(or would you feel )about moving there?"></a>1. Did you live(or would you like to live) in a foreign country? How did you feel(or would you feel )about moving there?</h4><h4 id="Pre"><a href="#Pre" class="headerlink" title="Pre:"></a>Pre:</h4><p>I love to have a try , I have never been some places before .</p>
<p>No I haven’t exactly .</p>
<p>I think I will be really exciting to move to anther country .</p>
<p>I would see something maybe completely different from my motherland . Broaden my horizons .</p>
<p>I would go to visit some wonderful places of interest to feel the magic of nature .</p>
<p>I would feel the different culture of other country ,participate in their unique festivals , taste local cuisine , talk to the local people with different personalities .</p>
<p>What ‘s more ,I can go to the world-famous university to have a further study , making me more knowledgeable .</p>
<h4 id="2-If-you-move-to-a-foreign-country-what-is-your-biggest-concern"><a href="#2-If-you-move-to-a-foreign-country-what-is-your-biggest-concern" class="headerlink" title="2. If you move to a foreign country, what is your biggest concern?"></a>2. If you move to a foreign country, what is your biggest concern?</h4><h4 id="Pre-1"><a href="#Pre-1" class="headerlink" title="Pre:"></a>Pre:</h4><p>I have social phobia. I’m personally very afraid of strong blacks</p>
<p>The language of course .</p>
<p>As we all know ,different countries have different languages .</p>
<p>If we want to move to another city , we should learn how to speak and understand their language at first so that we can make some easy communications , show what we think or need .</p>
<p>On the other hand ,after we move to another city ,we have to make friends with our neighbors , we will have a better atmosphere if we can understand what one anther is talking about .</p>
<h4 id="3-What-kind-of-customs-do-you-know-of-living-in-different-countries"><a href="#3-What-kind-of-customs-do-you-know-of-living-in-different-countries" class="headerlink" title="3. What kind of customs do you know of living in different countries?"></a>3. What kind of customs do you know of living in different countries?</h4><h4 id="Pre-2"><a href="#Pre-2" class="headerlink" title="Pre:"></a>Pre:</h4><p>To be honest ,I know a little . have dinner so late .until two,,,,,,,</p>
<p>Americans have casual eating habits. They like to eat beef, pork, chicken and so on.</p>
<p>Americans do not eat garlic, avoid eating the viscera of various animals, and have no habit of vinegar.</p>
<p>When drinking drinks, most people like to add ice. Canadians don’t give gifts casually. They usually give gifts only when colleagues are separated and friends are on birthdays or weddings.</p>
<p>Gifts must be opened in person and you should thank for that .</p>
<h4 id="4-What-customs-should-a-visitor-to-your-country-know-about-Obey-relationship-bring-something-when-you’re-invited-flowers-and-presents-to-show-your-gratitude"><a href="#4-What-customs-should-a-visitor-to-your-country-know-about-Obey-relationship-bring-something-when-you’re-invited-flowers-and-presents-to-show-your-gratitude" class="headerlink" title="4. What customs should a visitor to your country know about? Obey relationship bring something when you’re invited flowers and presents to show your gratitude ."></a>4. What customs should a visitor to your country know about? Obey relationship bring something when you’re invited flowers and presents to show your gratitude .</h4><h4 id="Pre-3"><a href="#Pre-3" class="headerlink" title="Pre:"></a>Pre:</h4><p>If you are invited to a Chinese people’s home , the host will shake hands with you .</p>
<p>When you are having dinner ,the host will put a lot of meals to your bowl .</p>
<p>It seems that the host want to force you eat a lot of food so that there will be no leftovers .</p>
<p>But exactly , this is the host’s hospitality . They just want to show you’re an important visitors and want you to eat and drink to your heart’s content .</p>
<p>If some friends gives you a gift . It’s impolite to open it in front of others .</p>
<p>You should open it after others left .</p>
<h4 id="5-What-kind-of-culture-shock-have-you-ever-experienced-in-life"><a href="#5-What-kind-of-culture-shock-have-you-ever-experienced-in-life" class="headerlink" title="5.What kind of culture shock have you ever experienced in life?"></a>5.What kind of culture shock have you ever experienced in life?</h4><h4 id="Pre-4"><a href="#Pre-4" class="headerlink" title="Pre:"></a>Pre:</h4><p>Chinese people pay attention to modesty, which we regard as a virtue .</p>
<p>When others praise us, we tend to belittle ourselves. But people in western countries will accept praise and express gratitude happily .</p>
<p>What’s more .</p>
<p>When a family eats together, Chinese people often sit around the table and get what they need from the food on the table, while Westerners divide the food into small portions in advance, give each person one and eat independently .</p>
]]></content>
      <categories>
        <category>Oral English</category>
        <category>Distance Class</category>
      </categories>
  </entry>
  <entry>
    <title>Internet_Problem</title>
    <url>/posts/98e8f0c.html</url>
    <content><![CDATA[<h4 id="参考句型："><a href="#参考句型：" class="headerlink" title="参考句型："></a>参考句型：</h4><p>With the develop</p>
<p>Shopping online ,</p>
<p>The first time I bought something online</p>
<p>Fit me well</p>
<p>Deal with it quickly</p>
<p>More and more people for</p>
<p>The reminds exchange for another one</p>
<h4 id="Pre"><a href="#Pre" class="headerlink" title="Pre:"></a>Pre:</h4><p>In the digital era ,we can just use our computers or smart phones to visit shopping websites to buy things we need ,which means we don’t have to move our body but just browse the web ,click, and place an order instead of going to the offline stores.</p>
<p>But if there’s something the matter with the commodity ,we will have more things to do .</p>
<p>For example ,after we get the clothes we bought online ,we find there is a tear in the lining or some of buttons are very loose .</p>
<p>We need to contact after-sales, show our questions and exchange or refund.</p>
<p>After that ,we have to find an express company to send the goods back and wait for the results.</p>
<p>But if we shop offline near by,we just need to go to the store ,show our questions ,and exchange or refund.</p>
]]></content>
      <categories>
        <category>Oral English</category>
        <category>Distance Class</category>
      </categories>
  </entry>
  <entry>
    <title>Introduce_job</title>
    <url>/posts/6926aa6c.html</url>
    <content><![CDATA[<h4 id="How-to-introduce-your-job"><a href="#How-to-introduce-your-job" class="headerlink" title="How to introduce your job ."></a>How to introduce your job .</h4><p>Hello everyone,I’m Tammer.</p>
<p>If you ask me what kind of job would I like to look for,I would say I want to be a professor in computers.</p>
<p>And I will doing this full time.</p>
<p>On the one hand,I will have studied computer and science for almost four years,and it’s what I’m interested in.</p>
<p>On the other hand , it’s mostly a bunch of creative and interesting people working on it.</p>
<p>I like ones who’s always having a good sense of humor and have a brain which’s full of brilliantideas.</p>
<p>OK , that’s all .</p>
<h4 id="Talk-something-about-part-time-job"><a href="#Talk-something-about-part-time-job" class="headerlink" title="Talk something about part-time job ."></a>Talk something about part-time job .</h4><p>Hello ,everyone ,today I want to tell you something about part-time job .</p>
<p>As a college student ,learning is not our only task, we should also learn the truth of how to behave .</p>
<p>Obviously, taking a part-time job is a good choice .</p>
<p>And there is a lot of advantages of it .</p>
<p>Firstly, part-time job would strengthen we students’ability to deal with things.</p>
<p>As students, not only should we study hard, but we should learn to how to deal with things so that we can be more independent.</p>
<p>Doing part-time job can practice our ability to manage things and let us learn how to communicate with others .</p>
<p>We would learn how to say the right thing on different occasions.</p>
<p>We would learn how can we talk to our colleagues or express our ideas properly.</p>
<p>Secondly, through part-time job, we students can relieve our parents’burden.</p>
<p>By doing part-time job, we can earn some money to support ourselves.</p>
<p>Therefore, our parents would have less pressure to make money.</p>
<p>Thirdly, more part-time experience will benefit we students’future career.</p>
<p>For many companies, they prefer students with lots of practical experience.</p>
<p>Students with more practical experience would be more outstanding comparing to the other job seekers.</p>
<p>But every coin has two sides .</p>
<p>Working for approximately 10 hours per week or less seemingly does not take a consistent toll on school performance ,but many part-time jobs require a long time,.</p>
<p>If we indulge in part-time job too much, it will undoubtedly have a great impact on our studies.</p>
<p>First ,owing to our demanding work schedule ,we have less time to devote to school assignments .</p>
<p>We may cut corners by taking easier classes ,copying assignments from other students ,cutting class, or refusing to do work assigned by our teachers .</p>
<p>Second ,in order to work better ,we may work evenings .</p>
<p>Every evening work interferes not only with doing homework ,but with both sleep and diet .</p>
<p>Burning the midnight oil makes we working teenagers more tired in school.</p>
<p>Last but not least ,it appears that the excitement of earning large amounts of spending money makes school seem less rewarding and interesting .</p>
<p>We will have been working long hours since our second year ,are actually at greater risk than our classmates of dropping out before graduating .</p>
<p>All in all ,if we want to be successful in school ,we should balance the relationship between part-time job and study .</p>
<p>We should take part in a part-time job on the foundation of completing our studies well .</p>
<p>As for me , I am now working as an office assistant in our academy .</p>
<p>Although there is no money for reward , I learned a lot ,such as how to organize my work and study time reasonably .</p>
<p>I think it is really useful .My speech is over ,thank you for listening .</p>
]]></content>
      <categories>
        <category>Oral English</category>
        <category>Distance Class</category>
      </categories>
  </entry>
  <entry>
    <title>Introduce_partner</title>
    <url>/posts/ea3a7ea8.html</url>
    <content><![CDATA[<h3 id="How-to-introduce-your-partner"><a href="#How-to-introduce-your-partner" class="headerlink" title="How to introduce your partner ?"></a>How to introduce your partner ?</h3><h4 id="Attention"><a href="#Attention" class="headerlink" title="Attention:"></a>Attention:</h4><p>选定一个对象，那里的人，他是什么样的人，为啥想讲他的内容，讲讲你们具体经历的事情。</p>
<p>共同的爱好，工作，饮食习惯，喜欢啥呀。我们的性格都是积极向上的，积极活泼的。</p>
<p>他学习的专业，他擅长的方面</p>
<h5 id="可使用的句型"><a href="#可使用的句型" class="headerlink" title="可使用的句型:"></a>可使用的句型:</h5><p>Today I will say something about .</p>
<p>I wish more there will be more people like her in the world .</p>
<h4 id="Pre"><a href="#Pre" class="headerlink" title="Pre:"></a>Pre:</h4><p>Hello ,everyone .My name’s Tammer ,today I want to say something about my new partner Gloria .</p>
<p>Her Chinese name is Zhou Zhuonan ,and she’s from Tai Yuan in Shan Xi Province originally.</p>
<p>She came to Shan Xi University of Science to study educational technology after she graduated from high school.That was in 2020.</p>
<p>During her free time ,she like listening ,reading and travelling.</p>
<p>She’s also an animal lover ,so she want to own a cat in the future.</p>
<p>She’s also a hard-working girl ,she would practice spoken English day and night.</p>
<p>I haven’t seen such a wonderful girl before . I wish there will be more people like her in the world.</p>
]]></content>
      <categories>
        <category>Oral English</category>
        <category>Distance Class</category>
      </categories>
  </entry>
  <entry>
    <title>Movie_Class_Notes</title>
    <url>/posts/a1b49964.html</url>
    <content><![CDATA[<h2 id="Words"><a href="#Words" class="headerlink" title="Words"></a>Words</h2><p>newsworthy 有新闻价值的 </p>
<p>project  项目，工程，计划，方案  </p>
<p>polish 抛光，打磨</p>
<p>gleam 表露，发光</p>
<p>retrieve 找回，收回，检索</p>
<p>revolver 左轮手枪</p>
<p>startled 受震惊的  </p>
<p>popping 爆音，突然跳出，流行音乐的</p>
<p>aroused 唤醒，引起了  </p>
<p>initial 开始的，最初的  </p>
<p>blender 搅拌机，掺合者，混合物  </p>
<p>motionless 静止的，不运动的  </p>
<p>grief 悲伤，麻烦，烦恼  </p>
<p>funeral 葬礼  </p>
<p>resident 居民  </p>
<p>spicy 辛辣的  </p>
<p>propose 闪婚  </p>
<p>casually 随便地</p>
<p>pin 别针  </p>
<p>tease 嘲笑  </p>
<p>receipt 收据  </p>
<p>chest 胸部  </p>
<p>convertible 敞篷车  </p>
<p>outfield 外场手  </p>
<p>Yankee 美国佬  </p>
<p>muffins 西式糕点  </p>
<p>stricken 受灾的，患病的，受困扰的，（脸或者表情）非常悲痛的，极其忧伤的  </p>
<p>hectic 紧张，顾此失彼的忙碌  </p>
<p>irony 讽刺  </p>
<p>humiliate 羞愧，窘迫  </p>
<p>tragedy 悲剧事件，惨剧    </p>
<p>re-upholster 重新装潢椅子，重新做个坐垫等  </p>
<p>confront 质疑  </p>
<blockquote>
<p>we must confront future with optimism 我们必须乐观地面对未来</p>
<p>to confront a problem directly and openly 坦然面对某事</p>
</blockquote>
<p>punch 用拳头击打  </p>
<p>brunch 早午饭  </p>
<p>conscience 良知  </p>
<p>limp 无力的  </p>
<p>ethical 道德的  </p>
<p>conference 大型会议  </p>
<p>bang 交好  </p>
<p>phlianderer / <em>fɪˈlændərər</em> 爱和女人调情的男人，玩弄女性的男人  </p>
<p>handbook 手册，指南  </p>
<p>fulfilment 履行，实现，完成，结果  </p>
<p>erect 竖直的，勃起的  </p>
<p>penis 阴茎  </p>
<p>NRA 美国全国步枪协会  </p>
<p>head-on 迎面的，迎头的  </p>
<p>crisis 危机，危急关头   </p>
<p>humilliate 羞辱，使丧失尊严  </p>
<p>illustrate 画插画  </p>
<p>plunder 下水道管道工  </p>
<p>vimpire 吸血鬼  </p>
<p>cannonball 炮弹，加农炮  </p>
<p>undercooked 火候不足的，夹生的  </p>
<p>眉来眼去</p>
<p>yoga 瑜伽  </p>
<blockquote>
<p>do yoga 做瑜伽  </p>
</blockquote>
<p>kick 踢  </p>
<p>flirting 调情  </p>
<p>weird 奇怪的，诡异的，怪诞的  </p>
<p>eligible 有资格的，具备条件的  </p>
<p>bachelor 单身汉  </p>
<blockquote>
<p>eligible bachelor 黄金单身汉</p>
</blockquote>
<p>predatory 掠夺性的，（在金钱或者性关系上）欺负弱小的，压榨他人的  </p>
<p>numerous 很多的，众多的  </p>
<p>legendary 非常著名的，享有盛名的，传奇的，传说的  </p>
<p>slut 荡妇  </p>
<p>rivalry 竞争，竞赛，较量  </p>
<p>divorcee 离婚人士</p>
<p>drag 阻力  </p>
<p>ass 蠢人，笨蛋，驴，屁股</p>
<p>diamond 钻石  </p>
<blockquote>
<p>diamond necklace 钻石项链  </p>
</blockquote>
<p>bandages 绷带  </p>
<p>shelf 架子  </p>
<p>compromise 妥协  </p>
<p>import 进口  </p>
<p>deathly </p>
<p>allergic</p>
<p>dignify 使，，，高贵</p>
<blockquote>
<p>dignify suggestion </p>
</blockquote>
<p>pops</p>
<p>indignation</p>
<p>threatening</p>
<p>firm</p>
<p>dreaded </p>
<p>stall 拖延</p>
<p>ambrosia 特别美味的事物  </p>
<p>peanut 花生</p>
<p>butter 黄油  </p>
<blockquote>
<p>peanut butter 花生酱  </p>
</blockquote>
<p>cube 立方体  </p>
<p>cooking oil 食用油  </p>
<p>olive 橄榄  </p>
<p>popsicle 冰棒</p>
<blockquote>
<p>popsicle sticks</p>
</blockquote>
<p>stuff down 把塞入  </p>
<p>stuff up 堵上  </p>
<h2 id="Phrases"><a href="#Phrases" class="headerlink" title="Phrases"></a>Phrases</h2><p> work in mergers and acquisitions 从事合并和收购工作  </p>
<p>well up 涌出，涌上心头  </p>
<blockquote>
<p>tears well up  </p>
</blockquote>
<p>pipping hot  滚烫的，烫手的  </p>
<p>considerably cooler 关系冷淡  </p>
<p>pin the receipt on my chest   </p>
<p>from scratch 白手起家，从头做起  </p>
<p>mutual funds 共同资金  </p>
<p>out of one’s mind with  </p>
<p>grief stricken 极度悲伤的  </p>
<p>down the block 小区中心，最豪华的位置  </p>
<p>develop a taste for habit of 培养对什么的品味，爱好  </p>
<p>drop in on somebody 拜访某人  </p>
<p>come out of the closet 出柜（承认同性恋）  </p>
<p>in the closet （同性恋不承认）  </p>
<p>look on the bright side  抱着乐观的态度</p>
<p>stay at home mom 全职妈妈  </p>
<p>was laid to rest 下葬的委婉表达  </p>
<p>top lane 上路  </p>
<p>middle lane 中路  </p>
<p>bottom lane 下路  </p>
<p>pay one’s respect 致敬某人  </p>
<p>corporate ladder 公司晋升  </p>
<p>appreciate irony </p>
<p>just so you know 顺便告诉你，我警告你，对你说一声  </p>
<p>act up 捣乱    </p>
<p>Zen look 虔诚的表情（出轨之后假装平静）  </p>
<p>with — look on one’s face 某人带着—的表情  </p>
<p>in the back of his mind 时刻记得  </p>
<p>face them head-on 直面恐惧，苦难等  </p>
<p>pack up 收拾行李，身体器官等衰竭，机器出故障，停止工作  </p>
<p>for god’s sakes 看在上帝的份上  </p>
<p>get something over with 把这件事儿给结了吧    </p>
<p>out of some sort of curiosity 出于好奇心  </p>
<p>screw up 弄砸，搞砸  </p>
<p>be big with the under-five set 在五岁以下的孩子中受欢迎  </p>
<p>all over 到处  </p>
<p>have been doing 一直在做  </p>
<p>eligible bachelor 黄金单身汉  </p>
<p>ease up 放松一点，非正式场合  </p>
<p>house-warming gift 乔迁之礼  </p>
<p>conquest-conquer 征服  </p>
<p>Sausage puttanesca 酱汁香肠  </p>
<p>for purpose 出于什么目的  </p>
<p>conquest-conquer </p>
<p>for tax purposes 因为税收的原因  </p>
<p>real soon 尽快  </p>
<p>stop by 顺便拜访  </p>
<p>this is what —- is all about —- 这正是—-的真谛  </p>
<blockquote>
<p>This is what family is all about .</p>
</blockquote>
<p>hook up 勾搭某人  </p>
<p>hand-carved 手工制作的  </p>
<p>sudden urge 突然的冲动</p>
<p>basil puree 吃的</p>
<p>navy bean 吃的</p>
<p>osso buco 意式烩牛仔骨</p>
<p>sullen tone 不高兴，阴沉的语气</p>
<p>pork and beans 猪头炖黄豆</p>
<p>mayor of stepford </p>
<p>figure out 出问题不一定解决  </p>
<p>work out 解决问题  </p>
<p>fight for custody 为监护权而战斗  </p>
<p>put in order 下单  </p>
<h2 id="Sentences"><a href="#Sentences" class="headerlink" title="Sentences"></a>Sentences</h2><p>Most men lead lives of quiet desperation and go to the grave with the song still in them . 大多数人过着平静绝望的生活，带着心中的歌走向坟墓。</p>
<p>Yeah,I get that a lot . 我经常受到这样的情况  </p>
<p>Now that you’ve know how impotant oral English is ,you should do your utmost to learn it well . 既然你已经知道了英语是多么得重要，你就应该努力学好它。  </p>
<p>If this is the case ,I should probably check my homework again . 如果是这样的话，我会回去检查一下我的家庭作业。</p>
<p>I was sort of in the middle of something .我现在手头有点事情。  </p>
<p>Can you say something that people have heared of ? 你能说人话吗？  </p>
<p>How would you feel about me doing ··· 对于我做…..你的意见是啥，你怎么看，你会怎么想  </p>
<blockquote>
<p>How would you feel about yourself ? 你觉得自己怎么样？  </p>
</blockquote>
]]></content>
      <categories>
        <category>Oral English</category>
        <category>Movie Class</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab</title>
    <url>/posts/dc9cb9f1.html</url>
    <content><![CDATA[<h3 id="Matlab-学习笔记"><a href="#Matlab-学习笔记" class="headerlink" title="Matlab 学习笔记"></a>Matlab 学习笔记</h3><p>“&gt;&gt;”命令提示符</p>
<p>结尾加上”;”执行后不显示变量的值</p>
<h4 id="数值数据"><a href="#数值数据" class="headerlink" title="数值数据"></a>数值数据</h4><p>整型，浮点型，字符型</p>
<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; x = int8(<span class="number">129</span>)</span><br><span class="line">// 转为有符号的八位整型</span><br><span class="line">&gt;&gt; x = uint8(<span class="number">129</span>)</span><br><span class="line">// 转为无符号的八位整型</span><br><span class="line"></span><br><span class="line">&gt;&gt; single(<span class="number">4</span>)</span><br><span class="line">// 强制转换，将双精度的<span class="number">4</span>转换为单精度型</span><br><span class="line"></span><br><span class="line">&gt;&gt; class(<span class="number">4</span>)</span><br><span class="line">// 得到<span class="number">4</span>的数值类型</span><br><span class="line"></span><br><span class="line">&gt;&gt; format long</span><br><span class="line">// 定义数值数据的输出格式</span><br><span class="line">// format命令只影响数据的输出格式，不影响数据的计算和存储</span><br><span class="line"></span><br><span class="line">&gt;&gt; A = [<span class="number">3</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">// 创建矩阵A</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">sin</span>(<span class="built_in">pi</span>/<span class="number">2</span>)</span><br><span class="line">&gt;&gt; <span class="built_in">sind</span>(<span class="number">90</span>)</span><br><span class="line">// 以角度为单位加上d</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">abs</span>(<span class="string">'a'</span>)</span><br><span class="line">&gt;&gt; <span class="built_in">abs</span>(<span class="number">-4</span>)</span><br><span class="line">&gt;&gt; <span class="built_in">abs</span>(<span class="number">3</span>+<span class="number">4</span><span class="built_in">i</span>)</span><br><span class="line">// <span class="built_in">abs</span>函数能够求实数的绝对值，复数的根，字符串的ASCII码值</span><br><span class="line"></span><br><span class="line">// 用于取整的函数有<span class="built_in">fix</span>,<span class="built_in">floor</span>,<span class="built_in">ceil</span>,<span class="built_in">round</span></span><br><span class="line">// <span class="built_in">round</span>()四舍五入</span><br><span class="line">// <span class="built_in">ceil</span>()向上取整</span><br><span class="line">// <span class="built_in">floor</span>()向下取整，取小于等于这个数的第一个整数</span><br><span class="line">// <span class="built_in">fix</span>()舍去小数取整</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">rem</span>(a,b)</span><br><span class="line">// a除以b的余数</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">isprime</span>(n)</span><br><span class="line">// 判断n是否为素数，是返回<span class="number">1</span>，不是返回<span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; x = <span class="number">1</span>:<span class="number">100</span>;</span><br><span class="line">// 生成<span class="number">1</span>到<span class="number">100</span>全部整数组成的向量x</span><br><span class="line">&gt;&gt; <span class="built_in">find</span>(<span class="number">1</span>)</span><br><span class="line">// 生成序号  </span><br><span class="line"></span><br><span class="line">// <span class="built_in">linspace</span>函数生成行向量</span><br><span class="line">&gt;&gt; <span class="built_in">linspace</span>(a,b,n)</span><br><span class="line">// a第一个元素，b最后一个元素，n元素总数，当n省略时自动产生<span class="number">100</span>个元素</span><br><span class="line"></span><br><span class="line">&gt;&gt; sum()  //求和函数</span><br><span class="line"></span><br><span class="line">// 键盘输入n的值</span><br><span class="line">&gt;&gt; n = input(<span class="string">'please input n = '</span>)</span><br><span class="line"></span><br><span class="line">// 输出s的结果</span><br><span class="line">&gt;&gt; <span class="built_in">disp</span>(s)</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">max</span>(A) 列优先</span><br><span class="line">&gt;&gt; <span class="built_in">max</span>(A,[],dim) </span><br><span class="line">// dim取<span class="number">1</span>时与<span class="built_in">max</span>(A)</span><br><span class="line">// dim取<span class="number">2</span>时，该函数返回一个列向量，其第<span class="built_in">i</span>个元素是A矩阵的第<span class="built_in">i</span>行上的最大值</span><br><span class="line">&gt;&gt; [y,l] = <span class="built_in">max</span>(x)</span><br><span class="line">// 求矩阵x中各列元素的最大值及其这些元素的行下标</span><br><span class="line">&gt;&gt; <span class="built_in">max</span>(A,B)</span><br><span class="line">// A,B是两个同型的向量或矩阵，返回值是与A,B同型的向量或矩阵，其中的每个元素等于A,B对应元素的较大者。</span><br><span class="line">&gt;&gt; <span class="built_in">max</span>(A,n)</span><br><span class="line">// n是一个标量，返回值是与A同型的向量或矩阵，其中的每个元素等于A对应元素和n中的较大者</span><br><span class="line"></span><br><span class="line">&gt;&gt; prod(A) 求积</span><br><span class="line">&gt;&gt; prod(A,dim)</span><br><span class="line"></span><br><span class="line">平均值，中值，标准方差</span><br><span class="line"></span><br><span class="line">&gt;&gt; corrcoef(X,Y) 求向量X和Y的相关系数</span><br><span class="line">&gt;&gt; corrcoef(X) </span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">sort</span>() 排序</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">max</span>(A(:))</span><br><span class="line">// 整个矩阵的最大值</span><br></pre></td></tr></tbody></table></figure>

<p>计算表达式的值<br>$$<br>\frac {5+cos47°} {1+\mid x-y \mid}<br>$$<br>其中<br>$$<br>x = \sqrt 7 \quad y = e^{\Pi/2}<br>$$</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; x = <span class="built_in">sqrt</span>(<span class="number">7</span>) - <span class="number">2</span><span class="built_in">i</span></span><br><span class="line">&gt;&gt; y = <span class="built_in">exp</span>(<span class="built_in">pi</span>/<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="变量的管理"><a href="#变量的管理" class="headerlink" title="变量的管理"></a>变量的管理</h4><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">// who 命令给出所有变量的名称</span><br><span class="line">// whos 命令给出所有变量详细的信息</span><br></pre></td></tr></tbody></table></figure>

<h5 id="存储变量"><a href="#存储变量" class="headerlink" title="存储变量"></a>存储变量</h5><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">// save命令，创建内存变量文件</span><br><span class="line">// load命令，装入内存变量文件</span><br><span class="line"></span><br><span class="line">&gt;&gt; save mydata a x </span><br><span class="line">// 将变量a,x的值存储在mydata.mat文件中</span><br><span class="line"></span><br><span class="line">&gt;&gt; load mydata</span><br><span class="line">// 装载</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Matlab-中矩阵的表示"><a href="#Matlab-中矩阵的表示" class="headerlink" title="Matlab 中矩阵的表示"></a>Matlab 中矩阵的表示</h4><h5 id="矩阵的建立"><a href="#矩阵的建立" class="headerlink" title="矩阵的建立"></a>矩阵的建立</h5><p>1.直接输入法建立矩阵</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>2.利用已经建好的矩阵建立更大的矩阵，一个大矩阵可以由已经建立好的小矩阵拼接而成。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">&gt;&gt; B = [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>;<span class="number">-4</span>,<span class="number">-5</span>,<span class="number">-6</span>;<span class="number">-7</span>,<span class="number">-8</span>,<span class="number">-9</span>]</span><br><span class="line">&gt;&gt; c = [A,B;A,B]</span><br></pre></td></tr></tbody></table></figure>

<p>3.可以使用实部矩阵和虚部矩阵构成复数矩阵</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">&gt;&gt; B = [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>;<span class="number">-4</span>,<span class="number">-5</span>,<span class="number">-6</span>;<span class="number">-7</span>,<span class="number">-8</span>,<span class="number">-9</span>]</span><br><span class="line">&gt;&gt; C = A + <span class="built_in">i</span>*B</span><br></pre></td></tr></tbody></table></figure>

<p>4.构建零矩阵</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">zeros</span>(a,b)</span><br><span class="line">// 构建a行b列的零矩阵</span><br></pre></td></tr></tbody></table></figure>

<h5 id="结构矩阵"><a href="#结构矩阵" class="headerlink" title="结构矩阵"></a>结构矩阵</h5><p>格式：</p>
<p>结构矩阵元素.成员名 = 表达式</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; a(<span class="number">1</span>).x1=<span class="number">10</span>;a(<span class="number">1</span>).x2=<span class="string">'liu'</span>;a(<span class="number">1</span>).x3=[<span class="number">11</span>,<span class="number">21</span>;<span class="number">34</span>,<span class="number">78</span>]</span><br><span class="line">&gt;&gt; a(<span class="number">2</span>).x1=<span class="number">10</span>;a(<span class="number">2</span>).x2=<span class="string">'liu'</span>;a(<span class="number">2</span>).x3=[<span class="number">11</span>,<span class="number">21</span>;<span class="number">34</span>,<span class="number">78</span>]</span><br><span class="line">&gt;&gt; a(<span class="number">3</span>).x1=<span class="number">10</span>;a(<span class="number">3</span>).x2=<span class="string">'liu'</span>;a(<span class="number">3</span>).x3=[<span class="number">11</span>,<span class="number">21</span>;<span class="number">34</span>,<span class="number">78</span>]</span><br></pre></td></tr></tbody></table></figure>

<h5 id="单元矩阵"><a href="#单元矩阵" class="headerlink" title="单元矩阵"></a>单元矩阵</h5><p>建立单元矩阵和一般矩阵相似，直接输入就可以了，只是单元矩阵元素用大括号括起来，所有元素可以是不同的数据类型</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; b = {<span class="number">10</span>,<span class="string">'liu'</span>,[<span class="number">11</span>,<span class="number">21</span>;<span class="number">34</span>,<span class="number">59</span>];<span class="number">12</span>,<span class="string">'zhangsan'</span>,[<span class="number">23</span>,<span class="number">222</span>;<span class="number">333</span>,<span class="number">44</span>]}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="矩阵元素的引用方式"><a href="#矩阵元素的引用方式" class="headerlink" title="矩阵元素的引用方式"></a>矩阵元素的引用方式</h5><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">// 通过下标的方式引用</span><br><span class="line">&gt;&gt; A(<span class="number">3</span>,<span class="number">2</span>) = <span class="number">200</span></span><br><span class="line">// 给矩阵A第<span class="number">3</span>行第<span class="number">2</span>列的元素赋值<span class="number">200</span></span><br><span class="line"></span><br><span class="line">// 通过序号引用</span><br><span class="line">// Matlab矩阵按列存储</span><br><span class="line">&gt;&gt; A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">&gt;&gt; A(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">ans</span> = <span class="number">2</span></span><br><span class="line">// 序号与下标是一一对应的，以m✖n矩阵A为例，矩阵元素A(<span class="built_in">i</span>,<span class="built_in">j</span>)的序号为(<span class="built_in">j</span><span class="number">-1</span>)✖m+<span class="built_in">i</span></span><br><span class="line"></span><br><span class="line">// 矩阵元素的序号与下标可以利用<span class="built_in">sub2ind</span>和<span class="built_in">ind2sub</span>函数实现相互转换</span><br><span class="line"><span class="built_in">sub2ind</span>函数：将矩阵中指定元素的行，列下标转换为存储的序号，调用格式为：</span><br><span class="line">&gt;&gt; D = <span class="built_in">sub2ind</span>(S,I,J) //行数和列数组成的向量，转换矩阵元素的行下标，转换矩阵元素的列下标</span><br><span class="line">&gt;&gt; A = [<span class="number">1</span>:<span class="number">3</span>;<span class="number">4</span>:<span class="number">6</span>]</span><br><span class="line">&gt;&gt; D = <span class="built_in">sub2ind</span>(<span class="built_in">size</span>(A),[<span class="number">1</span>,<span class="number">2</span>;<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>;<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line">D = </span><br><span class="line">   <span class="number">1</span>  <span class="number">2</span> </span><br><span class="line">   <span class="number">6</span>  <span class="number">4</span></span><br><span class="line"><span class="built_in">ind2sub</span>函数：反之</span><br><span class="line">&gt;&gt; [I,J] = <span class="built_in">ind2sub</span>(S,D) //行数和列数组成的向量，序号</span><br><span class="line">&gt;&gt; [I,J] = <span class="built_in">ind2sub</span>([<span class="number">3</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>])</span><br><span class="line">I = </span><br><span class="line">   <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> </span><br><span class="line">J = </span><br><span class="line">   <span class="number">1</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="删除矩阵中的元素"><a href="#删除矩阵中的元素" class="headerlink" title="删除矩阵中的元素"></a>删除矩阵中的元素</h5><p>1.利用空矩阵删除元素</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; A(<span class="number">3</span>,:) = [] //将第三行所有元素删除</span><br></pre></td></tr></tbody></table></figure>

<h5 id="改变矩阵的形状"><a href="#改变矩阵的形状" class="headerlink" title="改变矩阵的形状"></a>改变矩阵的形状</h5><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">// <span class="built_in">reshape</span>(A,m,n):在矩阵总元素保持不变的前提下，将矩阵A重新排成m✖n的二维矩阵。</span><br><span class="line">// <span class="built_in">reshape</span>函数只是改变原矩阵的行数和列数，但并不改变原矩阵元素个数及其存储顺序。</span><br><span class="line">// A(:):将矩阵A的每一列元素堆叠起来，成为一个列向量 </span><br></pre></td></tr></tbody></table></figure>

<h5 id="矩阵的特征值和特征向量"><a href="#矩阵的特征值和特征向量" class="headerlink" title="矩阵的特征值和特征向量"></a>矩阵的特征值和特征向量</h5><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">// 函数调用格式有两种</span><br><span class="line"></span><br><span class="line">&gt;&gt; E = eig(A) </span><br><span class="line">// 求矩阵A的全部特征值，构成向量E</span><br><span class="line"></span><br><span class="line">&gt;&gt; [X,D] = eig(A) </span><br><span class="line">// 求矩阵A的全部特征值，构成对角阵D，并产生矩阵X，X的各列是相应的特征向量</span><br></pre></td></tr></tbody></table></figure>

<p>启示：构建斜体字库时可以只建立正体字库，再进行变换</p>
<h4 id="冒号表达式"><a href="#冒号表达式" class="headerlink" title="冒号表达式"></a>冒号表达式</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>格式：<br>$$<br>e1:e2:e3<br>$$<br>以e1为初始值，e2为步长，e3为终止值的行向量</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; t = <span class="number">0</span>:<span class="number">1</span>:<span class="number">5</span></span><br><span class="line">t = </span><br><span class="line">   <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line">// 省略e2则默认为<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="利用冒号表达式获得子矩阵"><a href="#利用冒号表达式获得子矩阵" class="headerlink" title="利用冒号表达式获得子矩阵"></a>利用冒号表达式获得子矩阵</h5><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; A(<span class="built_in">i</span>,:) 第<span class="built_in">i</span>行的全部元素</span><br><span class="line">&gt;&gt; A(:,<span class="built_in">j</span>) 第<span class="built_in">j</span>列的全部元素</span><br><span class="line">&gt;&gt; A(<span class="built_in">i</span>:<span class="built_in">i</span>+m,k:k+m) 第<span class="built_in">i</span>~<span class="built_in">i</span>+m行内且在第k~k+m列中的所有元素</span><br><span class="line">&gt;&gt; A(<span class="built_in">i</span>:<span class="built_in">i</span>+m,:) 第<span class="built_in">i</span>~<span class="built_in">i</span>+m行的全部元素</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>运算符：表示某一维的末尾元素下标</span><br><span class="line">&gt;&gt; A(<span class="keyword">end</span>,:) 引用最后一行的元素</span><br><span class="line">&gt;&gt; A([<span class="number">1</span>,<span class="number">4</span>],<span class="number">3</span>:<span class="keyword">end</span>) 引用第一行和第四行第三列到最后一列的元素</span><br></pre></td></tr></tbody></table></figure>

<h4 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h4><p>是把一个字符串当成一个行向量，可以形成一个字符串矩阵</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; eval(s) </span><br><span class="line">//将字符串s的内容当作matlab命令来执行</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">abs</span>(s)</span><br><span class="line">// 输出字符串矩阵所对应的ASCII码数值矩阵</span><br><span class="line"></span><br><span class="line">&gt;&gt; char(a) </span><br><span class="line">// 可以把ASCII码矩阵转换为字符串矩阵</span><br></pre></td></tr></tbody></table></figure>

<h6 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h6><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; strcmp(s1,s2) //相等<span class="number">1</span>，反之<span class="number">0</span></span><br><span class="line">&gt;&gt; strncmp(s1,s2,n) //比较前n个字符是否相等</span><br><span class="line">&gt;&gt; strcmpi(s1,s2) //忽略大小写</span><br><span class="line">&gt;&gt; strncmpi(s1,s2,n) //忽略大小写比较前n位</span><br></pre></td></tr></tbody></table></figure>

<h5 id="字符串的查找与替换"><a href="#字符串的查找与替换" class="headerlink" title="字符串的查找与替换"></a>字符串的查找与替换</h5><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; findstr(s1,s2) //返回短字符串在长字符串中的开始位置</span><br><span class="line">&gt;&gt; strrep(s1,s2,s3) //将字符串s1中的所有子字符串s2替换为字符串s3</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Matlab-基本运算"><a href="#Matlab-基本运算" class="headerlink" title="Matlab 基本运算"></a>Matlab 基本运算</h4><h5 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h5><h6 id="基本算数运算"><a href="#基本算数运算" class="headerlink" title="基本算数运算"></a>基本算数运算</h6><p>有”/右除”和”\左除”</p>
<blockquote>
<p>算术运算是在矩阵意义下进行的，单个数据的算术运算只是矩阵运算的一种特例</p>
<p>加减运算和乘除运算需要满足线性代数的条件</p>
</blockquote>
<h6 id="点运算"><a href="#点运算" class="headerlink" title="点运算"></a>点运算</h6><p>两矩阵进行点运算是指他们的对应元素进行点运算，要求两矩阵同型</p>
<p>点运算符：”.*,./,.,.^”</p>
<h5 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h5><p>~= 不等于</p>
<blockquote>
<p>当参与比较的是两个同型的矩阵时，对应位置比较，输出一个同型的矩阵，由0和1组成</p>
<p>当参与比较的一个标量一个是矩阵，拿着标量和矩阵的每一个元素比较，输出一个同型的矩阵，由0和1组成</p>
</blockquote>
<h5 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h5><p>a&amp;b,a|b</p>
<p>~a 非a</p>
<h4 id="函数文件的定义与调用"><a href="#函数文件的定义与调用" class="headerlink" title="函数文件的定义与调用"></a>函数文件的定义与调用</h4><h5 id="函数文件的基本结构"><a href="#函数文件的基本结构" class="headerlink" title="函数文件的基本结构"></a>函数文件的基本结构</h5><blockquote>
<p>function 输出形参表 = 函数名(输入形参表)</p>
<p>注释说明部分</p>
<p>函数体语句</p>
<p>当有多个形参时，形参之间用逗号分隔，组成形参表。当输出形参多于一个时，应该用方括号括起来，构成一个输出矩阵</p>
</blockquote>
<p>函数文件名通常由函数名再加上扩展名.m组成，函数文件名与函数名可以不相同</p>
<blockquote>
<p>return 语句表示结束函数的执行</p>
</blockquote>
<h4 id="线性方程组的求解"><a href="#线性方程组的求解" class="headerlink" title="线性方程组的求解"></a>线性方程组的求解</h4><blockquote>
<p>列主元消去法是目前计算机上求解线性方程组的标准算法</p>
</blockquote>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">// 利用左除运算符的直接解法</span><br><span class="line">&gt;&gt; Ax = b ====&gt; x = A\b </span><br><span class="line">// 如果矩阵A是奇异矩阵或接近奇异的，则MATLAB会给出警告信息</span><br><span class="line">&gt; 首先建立系数矩阵，再建立右端向量b矩阵，注意这个b矩阵是列向量，建立时：</span><br><span class="line">&gt;&gt; b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]';</span><br><span class="line"></span><br><span class="line">// 利用矩阵分解线性方程组</span><br><span class="line">&gt; LU 分解法就是三角分解法</span><br><span class="line">// [L,U] = lu(A) 产生一个上三角阵U和一个变换形式的下三角阵L，使之满足A = LU 。注意，这里的矩阵A必须是方阵。</span><br><span class="line">// [L,U,P] = lu(A) 产生一个上三角阵U和一个下三角阵L以及一个置换矩阵P，使之满足PA = LU。同样，矩阵A必须是方阵。</span><br><span class="line">&gt;&gt; x = U\(L\b)</span><br><span class="line">&gt;&gt; x = U\(L\P*b)</span><br><span class="line"></span><br><span class="line">// 线性方程组的迭代解法</span><br><span class="line"><span class="number">1.</span> 雅可比迭代法</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ y,n ]</span> = <span class="title">jacobi</span><span class="params">( A,b,x0,ep )</span> </span></span><br><span class="line">// ep是精度，y是解，n是迭代的次数</span><br><span class="line">D=<span class="built_in">diag</span>(<span class="built_in">diag</span>(A)); //A的对角矩阵</span><br><span class="line">L=-<span class="built_in">tril</span>(A,<span class="number">-1</span>);//A的下三角阵</span><br><span class="line">U=-<span class="built_in">triu</span>(A,<span class="number">1</span>);//A的上三角阵</span><br><span class="line">B=D\(L+U);</span><br><span class="line">f=D\b;</span><br><span class="line">y=B*x0+f;</span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> norm(y-x0)&gt;=ep // 前后两个解的二范数，描述矩阵引起变化的大小</span><br><span class="line">     x0=y;</span><br><span class="line">     y=B*x0+f;</span><br><span class="line">     n=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>高斯-赛德尔迭代法</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ y,n ]</span> = <span class="title">gauseidel</span><span class="params">( A,b,x0,ep )</span></span></span><br><span class="line">D=<span class="built_in">diag</span>(<span class="built_in">diag</span>(A));</span><br><span class="line">L=-<span class="built_in">tril</span>(A,<span class="number">-1</span>);</span><br><span class="line">U=-<span class="built_in">triu</span>(A,<span class="number">1</span>);</span><br><span class="line">B=(D-L)\U;</span><br><span class="line">f=(D-L)\b;</span><br><span class="line">y=B*x0+f;</span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> norm(y-x0)&gt;=ep</span><br><span class="line">    x0=y;</span><br><span class="line">    y=B*x0+f;</span><br><span class="line">    n=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="线性方程组应用举例"><a href="#线性方程组应用举例" class="headerlink" title="线性方程组应用举例"></a>线性方程组应用举例</h4><blockquote>
<h5 id="1-平面桁架结构受力分析"><a href="#1-平面桁架结构受力分析" class="headerlink" title="1.平面桁架结构受力分析"></a>1.平面桁架结构受力分析</h5><h5 id="2-小行星运行轨道计算"><a href="#2-小行星运行轨道计算" class="headerlink" title="2.小行星运行轨道计算"></a>2.小行星运行轨道计算</h5></blockquote>
<h4 id="曲线拟合"><a href="#曲线拟合" class="headerlink" title="曲线拟合"></a>曲线拟合</h4><p>polyfit(x,y,2)</p>
<p>求得最小二乘拟合多项式系数</p>
<h4 id="非线性方程数值求解"><a href="#非线性方程数值求解" class="headerlink" title="非线性方程数值求解"></a>非线性方程数值求解</h4><h5 id="单变量非线性方程求解"><a href="#单变量非线性方程求解" class="headerlink" title="单变量非线性方程求解"></a>单变量非线性方程求解</h5><p>x = fzero(filename,x0);</p>
<p>其中，filename是待求根方程左端的函数表达式，x0是初始值</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">f = @(x)x.^<span class="number">2</span><span class="number">-1</span>;  @(x)这是定义一个匿名函数</span><br></pre></td></tr></tbody></table></figure>

<h5 id="非线性方程组的求解"><a href="#非线性方程组的求解" class="headerlink" title="非线性方程组的求解"></a>非线性方程组的求解</h5><p>x = fsolve(filename,x0,option)</p>
<p>x 为 返回的近似解，filename是待求根方程左端的函数表达式，x0是初值，option用于设置优化工具箱的优化参数，可以调用optimset函数来完成，例如当参数为off时不显示中间变量</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">f = @(x)x - <span class="number">1.</span>/x+<span class="number">5</span></span><br><span class="line">x1 = fsolve(f,<span class="number">-5</span>,optimset(<span class="string">'Display'</span>,<span class="string">'off'</span>));</span><br></pre></td></tr></tbody></table></figure>

<h4 id="函数极值的计算"><a href="#函数极值的计算" class="headerlink" title="函数极值的计算"></a>函数极值的计算</h4><h5 id="无约束最优化问题"><a href="#无约束最优化问题" class="headerlink" title="无约束最优化问题"></a>无约束最优化问题</h5><p>求最小值的函数</p>
<h5 id="有约束最优化问题"><a href="#有约束最优化问题" class="headerlink" title="有约束最优化问题"></a>有约束最优化问题</h5><p>fimincon(): 函数</p>
<h4 id="数据统计分析"><a href="#数据统计分析" class="headerlink" title="数据统计分析"></a>数据统计分析</h4><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">max</span>(A(:)); //将A中的元素堆叠成为一个列向量，在求取列向量的最大值，这是求整个矩阵最大值的方法</span><br><span class="line">&gt;&gt; <span class="built_in">mean</span>(); //求平均值</span><br><span class="line">&gt;&gt; median(); //求中值</span><br><span class="line">&gt;&gt; cumsum(); //累加和函数</span><br><span class="line">&gt;&gt; cumprod(); //累乘积函数</span><br><span class="line">&gt;&gt; std(x); //求向量x的标准差</span><br><span class="line">&gt;&gt; std(A); //计算矩阵A的各列的标准差</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">相关系数</span><br><span class="line">&gt;&gt; corrcoef();相关系数函数</span><br><span class="line"></span><br><span class="line">排序函数</span><br><span class="line">&gt;&gt; <span class="built_in">sort</span>(); //排序函数</span><br></pre></td></tr></tbody></table></figure>

<h5 id="多项式计算"><a href="#多项式计算" class="headerlink" title="多项式计算"></a>多项式计算</h5><blockquote>
<p>多项式系数向量的顺序是从高到低</p>
<p>多项式系数向量包含0次项系数，所以其长度为多项式最高次数加1</p>
<p>如果有的项没有，系数向量相应位置应用0补足</p>
</blockquote>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; conv(p1,p2);  //多项式相乘函数</span><br><span class="line">&gt;&gt; [Q,r] = deconv(p1,p2);  //多项式相除函数</span><br><span class="line"></span><br><span class="line">&gt;&gt; polyder(); //多项式求导函数</span><br><span class="line"></span><br><span class="line">&gt;&gt; polyval(p,x); //代数多项式求值</span><br><span class="line">&gt;&gt; polyvalm(p,x); //矩阵多项式求值</span><br><span class="line"></span><br><span class="line">&gt;&gt; roots(p); //多项式求根函数</span><br><span class="line">&gt;&gt; poly(x); //若已知多项式的全部根，则可以用poly函数建立起该多项式，其调用格式为：p = poly(x)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="数据插值"><a href="#数据插值" class="headerlink" title="数据插值"></a>数据插值</h4><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; interpl() 一维插值</span><br><span class="line">&gt;&gt; linear() 线性插值</span><br><span class="line">&gt;&gt; nearest() 最近点插值</span><br><span class="line">&gt;&gt; pchip: 分段三次埃尔米特插值</span><br><span class="line">&gt;&gt; spline: 三次样条插值</span><br></pre></td></tr></tbody></table></figure>

<h4 id="符号运算"><a href="#符号运算" class="headerlink" title="符号运算"></a>符号运算</h4><h5 id="limit-f-x-a-求符号函数的极限"><a href="#limit-f-x-a-求符号函数的极限" class="headerlink" title="limit(f,x,a) 求符号函数的极限"></a>limit(f,x,a) 求符号函数的极限</h5><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt; sysms a m x n; //建立多个符号变量</span><br><span class="line">&gt;&gt; diff(f,x,n)  //求函数f关于变量x的n阶导数</span><br><span class="line">&gt;&gt; int(f,x) //符号函数的积分</span><br><span class="line">&gt;&gt;  </span><br></pre></td></tr></tbody></table></figure>

<h5 id="符号对象的建立"><a href="#符号对象的建立" class="headerlink" title="符号对象的建立"></a>符号对象的建立</h5><p>sym ,sysms</p>
<h5 id="四则运算和数值运算一样"><a href="#四则运算和数值运算一样" class="headerlink" title="四则运算和数值运算一样"></a>四则运算和数值运算一样</h5><h5 id="关系运算-lt-le-…………"><a href="#关系运算-lt-le-…………" class="headerlink" title="关系运算 lt(),le(),…………"></a>关系运算 lt(),le(),…………</h5><p>assume 函数对符号对象设置值域</p>
<h5 id="逻辑运算-1"><a href="#逻辑运算-1" class="headerlink" title="逻辑运算"></a>逻辑运算</h5><p>and(),or(),not(),xor()</p>
<h5 id="因式分解和展开运算"><a href="#因式分解和展开运算" class="headerlink" title="因式分解和展开运算"></a>因式分解和展开运算</h5><p>factor(s) 分解因式</p>
<p>expand(s) 进行展开</p>
<p>collect(s) 合并同类项</p>
<p>collect(s,v) 按变量v合并同类项</p>
<h5 id="梅森数的构造方法给大素数提供好方法"><a href="#梅森数的构造方法给大素数提供好方法" class="headerlink" title="梅森数的构造方法给大素数提供好方法"></a>梅森数的构造方法给大素数提供好方法</h5><h5 id="其他运算"><a href="#其他运算" class="headerlink" title="其他运算"></a>其他运算</h5><p>提取有理分式的分子分母</p>
<p>提取符号表达式的系数</p>
<p>符号表达式化简</p>
<p>符号多项式与多项式系数向量之间的转换</p>
<p>符号多项式转换为多项式系数向量</p>
<p>多项式系数向量转换为符号多项式</p>
<p>symvar() 函数查找一个符号表达式中的符号变量</p>
<h5 id="符号矩阵"><a href="#符号矩阵" class="headerlink" title="符号矩阵"></a>符号矩阵</h5><h5 id="代数方程的符号求解"><a href="#代数方程的符号求解" class="headerlink" title="代数方程的符号求解"></a>代数方程的符号求解</h5><p>solve()函数 </p>
<h5 id="常微分方程的符号求解"><a href="#常微分方程的符号求解" class="headerlink" title="常微分方程的符号求解"></a>常微分方程的符号求解</h5><p>在MATLAB种，用大写字母D表示导数</p>
<p>dsolve() 函数</p>
<h4 id="外部程序接口"><a href="#外部程序接口" class="headerlink" title="外部程序接口"></a>外部程序接口</h4><p>excel中使用matlab</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Tell_a_Story</title>
    <url>/posts/a40dcb10.html</url>
    <content><![CDATA[<h4 id="需要注意的要点："><a href="#需要注意的要点：" class="headerlink" title="需要注意的要点："></a>需要注意的要点：</h4><p>起因，经过，高潮，结果。</p>
<p>想清楚，来龙去脉讲清楚，时态是过去时，运用学过的句型。</p>
<p>主体部分重点使用上节课的学习内容，其余是之前学习的内容。</p>
<p>替换的部分，人物，动词短语，形容词，框架要知晓，要有总结性的收尾，言简意赅。</p>
<h4 id="Pre"><a href="#Pre" class="headerlink" title="Pre:"></a>Pre:</h4><p>What an interesting story !</p>
<p>My friend Yao who considered himself one of the cat lovers was scratched by a kitten a few months old .</p>
<p>It seems that he rushed to touch the kitten after one of his classmates told him that there was a lovely small cat basking in the sun on the lawn .</p>
<p>But he didn’t realize the kitten was sleeping , so it was frightened by his sudden touch .</p>
<p>It gave him a hard scratch .</p>
<p>After that , he had to go to the hospital for an injection himself ,costing a lot of money .</p>
<p>This story enlightens us that we should not disturb the life of animals casually even if they’re pretty cute.</p>
]]></content>
      <categories>
        <category>Oral English</category>
        <category>Distance Class</category>
      </categories>
      <tags>
        <tag>口语</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>grpc-lea</title>
    <url>/posts/20e13c1e.html</url>
    <content><![CDATA[<h1 id="grpc"><a href="#grpc" class="headerlink" title="grpc"></a>grpc</h1><p>调用方为client，被调用方为server。“服务定义”的思想，通过某种方式来描述一个服务，这种描述方式是语言无关的，在这个“服务定义”的过程中，我们描述了我们提供的服务是什么，有哪些方法可以被调用，这些方法有什么样的入参，有什么样的回参。</p>
<p>grpc会屏蔽底层的细节，client只需要直接调用定义好的方法，就能拿到预期的返回结果。对于server端来说，还需要实现我们定义的方法。</p>
<p>这是一种约定，约定好接口 ，server实现这个接口，client调用这个接口的代理对象，至于其他细节，交给grpc。</p>
<p>我们在定义服务和在编码和解码的过程中，应该是做到语言无关的。</p>
<h2 id="protocol-buffer"><a href="#protocol-buffer" class="headerlink" title="protocol buffer"></a>protocol buffer</h2><p>谷歌开源的一套成熟的数据结构序列化机制。数据传输的时候都是二进制传输，也就是字节流，适合高性能，对响应速度有要求的数据传输场景。因为profobuf是二进制数据格式，需要编码和解码，数据本身不具有可读性，因此只能反序列化之后得到真正可读的数据。</p>
<p><strong>序列化：将数据结构或对象转换成二进制串的过程</strong></p>
<p><strong>反序列化：将在序列化过程中产生的二进制串转换成数据结构或对象的过程</strong></p>
<ol>
<li>序列化之后体积相比json和xml更小，适合网络传输。</li>
<li>支持跨平台多语言。</li>
<li>消息格式升级和兼容性还不错。</li>
<li>序列化反序列化速度很快。</li>
</ol>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><p>下载protoc</p>
</li>
<li><p>安装grpc的核心库，这是protocol编译器，可以生成不同语言的代码。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get google.golang.org/grpc</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>各个语言的代码生成工具，go就是<code>protoc-gen-go</code></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> install google.golang.org/protobuf/cmd/protoc-gen-<span class="keyword">go</span>@latest</span><br><span class="line"><span class="keyword">go</span> install google.golang.org/grpc/cmd/protoc-gen-<span class="keyword">go</span>-grpc@latest</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="编写proto文件"><a href="#编写proto文件" class="headerlink" title="编写proto文件"></a>编写proto文件</h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 约束</span></span><br><span class="line"><span class="comment">// 说明使用的是proto3yufa</span></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="comment">// 这部分的内容是关于最后生成的go文件是处在哪个目录哪个区中，代表在当前目录生成，service代表了生成给的go文件的报名是service</span></span><br><span class="line">option go_package = <span class="string">".;service"</span>; <span class="comment">// 两个参数，生成的目录，包名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个服务，在这个服务中需要有一个方法，这个方法可以接受客户端的参数，再返回客户端的响应</span></span><br><span class="line"><span class="comment">// 我们定义一个service，称为sayhello，这个服务中有一个rpc方法，名为sayhello</span></span><br><span class="line"><span class="comment">// 这个方法会发送一个hellorequest，然后返回一个helloresponse</span></span><br><span class="line"></span><br><span class="line">service SayHello {</span><br><span class="line">  rpc SayHello(HelloRequest) returns (HelloResponse) {}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// message 关键字，可以理解为go中的结构体。</span></span><br><span class="line"><span class="comment">// 这里比较特别的是变量后面的”赋值“，注意，这里并不是赋值，而是定义在这个变量在这个message中的位置</span></span><br><span class="line">message HelloRequest {</span><br><span class="line">  <span class="type">string</span> requestName = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// int64 age = 2</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">message HelloResponse {</span><br><span class="line">  <span class="type">string</span> responseMsg = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个就是一个约束，server端和client端都得有</p>
<p>在同级目录下生成文件：两个参数，生成位置，把哪个文件生成代码，注意等号周围空格的问题</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">protoc --go_out=. hello.proto</span><br><span class="line">protoc --<span class="keyword">go</span>-grpc_out=. hello.proto</span><br></pre></td></tr></tbody></table></figure>

<h2 id="proto文件介绍"><a href="#proto文件介绍" class="headerlink" title="proto文件介绍"></a>proto文件介绍</h2><blockquote>
<p>message</p>
</blockquote>
<p>message : protobuf 中定义一个消息类型式是通过关键字message字段指定的，消息就是要传输的数据格式的定义</p>
<p>message 关键字类似于c++中的class，java中的class，go中的结构体</p>
<p>在消息中承载的数据分别对应每一个字段，其中每一个字段都有一个名字和一种类型。</p>
<p>一个proto文件中可以定义多个消息类型</p>
<blockquote>
<p>字段规则</p>
</blockquote>
<p>required:消息体中必填字段，不设置会导致编码异常，proto2中用，proto3中不用</p>
<p>optional:可填字段，protobuf3没有required，optional等说明关键字，默认为optional</p>
<p>repeated:可重复字段，重复的值的顺序会被保留在go中重复的会被定义为切片。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">repeated <span class="type">string</span> name  = <span class="number">3</span>;</span><br><span class="line">[]<span class="type">string</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>消息号</p>
</blockquote>
<p>每个字段都得有一个唯一的标识号，1到2^29-1的一个整数</p>
<blockquote>
<p>嵌套消息</p>
</blockquote>
<p>可以在其他消息类型中定义，使用消息类型</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">message PersonInfo{</span><br><span class="line">    message Person {</span><br><span class="line">        <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int32</span> height = <span class="number">2</span>;</span><br><span class="line">        repeated <span class="type">int32</span> weight = <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line">    repeated Person info = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果要在它的父消息外部重用这个消息类型，需要personinfo.person形式使用</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">message PersonMessage{</span><br><span class="line">    PersonInfo.Person info = 1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>服务定义</p>
</blockquote>
<p>如果想要将消息类型用在rpc系统中，可以在.proto文件中定义一个rpc服务接口，protocol buffer编译器将会根据所选择的不同语言生成服务接口代码及存根</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">service SearchService {</span><br><span class="line">    # rpc 服务函数名 （参数）返回（返回参数）</span><br><span class="line">    rpc Search(SearchRequest) returns (SearchResponse)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义了一个rpc服务，该方法接收searchrequest返回searchresponse</p>
<h2 id="服务端编写"><a href="#服务端编写" class="headerlink" title="服务端编写"></a>服务端编写</h2><ul>
<li><p>创建grpc server对象，可以理解他是server端的抽象对象。</p>
</li>
<li><p>将server（其包含需要被调用的服务端接口）注册到grpc server的内部注册中心。</p>
<p>这样可以在接收到请求时，通过内部的服务发现，发现该服务端接口并转换进行逻辑处理。</p>
</li>
<li><p>创建listen，监听tcp端口</p>
</li>
<li><p>grpc server开始lis.accept，直到stop</p>
</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc"</span></span><br><span class="line">	pb <span class="string">"grpc_demo/server/proto"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello server</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> {</span><br><span class="line">	pb.UnimplementedSayHelloServer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloResponse, <span class="type">error</span>) {</span><br><span class="line">	fmt.Println(<span class="string">"requestName"</span> + req.RequestName)</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.HelloResponse{ResponseMsg: <span class="string">"hello world"</span> + req.RequestName}, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 开启端口</span></span><br><span class="line">	listen, _ := net.Listen(<span class="string">"tcp"</span>, <span class="string">":9090"</span>)</span><br><span class="line">	<span class="comment">// 创建grpc服务</span></span><br><span class="line">	grpc_server := grpc.NewServer()</span><br><span class="line">	<span class="comment">// 注册服务</span></span><br><span class="line">	pb.RegisterSayHelloServer(grpc_server, &amp;server{})</span><br><span class="line">	<span class="comment">// 启动服务</span></span><br><span class="line">	err := grpc_server.Serve(listen)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(<span class="string">"failed to serve : %v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="客户端编写"><a href="#客户端编写" class="headerlink" title="客户端编写"></a>客户端编写</h2><ul>
<li>创建与给定目标（服务器）的连接交互</li>
<li>创建server的客户端对象</li>
<li>发送rpc请求，等待同步响应，得到回调后返回响应的结果</li>
<li>输出响应结果</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// go语言写连接代码，一定会有这两行，连接要处理错误，要关闭</span></span><br><span class="line">conn, err := grpc.Dial(<span class="string">"127.0.0.1:9090"</span>, grpc.WithTransportCredentials(insecure.NewCredentials())) <span class="comment">// 暂时不加密和验证</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		log.Fatalf(<span class="string">"did not connect : %v"</span>, err)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc/credentials/insecure"</span></span><br><span class="line">	pb <span class="string">"grpc_demo/server/proto"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	conn, err := grpc.Dial(<span class="string">"127.0.0.1:9090"</span>, grpc.WithTransportCredentials(insecure.NewCredentials())) <span class="comment">// 暂时不加密</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		log.Fatalf(<span class="string">"did not connect : %v"</span>, err)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	<span class="comment">// 建立连接</span></span><br><span class="line">	client := pb.NewSayHelloClient(conn)</span><br><span class="line">	<span class="comment">// 执行rpc调用（这个方法在服务器端来实现并返回结果）</span></span><br><span class="line">	resp, _ := client.SayHello(context.Background(), &amp;pb.HelloRequest{RequestName: <span class="string">"kuangshen"</span>})</span><br><span class="line">	fmt.Println(resp.GetResponseMsg())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="加密和认证"><a href="#加密和认证" class="headerlink" title="加密和认证"></a>加密和认证</h2><p>grpc是一个典型的C/S模型，需要开发客户端和服务端，客户端和服务端需要达成协议，使用某一个确实的传输协议来传输数据。grpc通常默认是使用protobuf来作为传输协议，当然可以其他自定义的。</p>
<p>那么，客户端与服务端要通信之前，客户端如何知道自己的数据是发给哪一个明确的服务端呢?反过来，服务端是不是也需要有一种方式来弄个清楚自己的数据要返回给谁呢?</p>
<p>那么就不得不提gRPC的认证</p>
<p>此处说到的认证，不是用户的身份认证，而是指多个server 和多个client之间，如何识别对方是谁，并且可以安全的进行数据传输</p>
<ul>
<li><font style="color:red;">SSL / TLS认证方式(采用http2协议)</font></li>
<li><font style="color:red;">基于Token的认证方式(基于安全连接).</font></li>
<li>不采用任何措施的连接，这是不安全的连接(默认采用http1)</li>
<li>自定义的身份认证</li>
</ul>
<p>客户端和服务端之间调用，我们可以通过加入证书的方式，实现调用的安全性</p>
<p>TLS (Transport Laver Security，安全传输层) , TLS是建立在传输层TCP协议之上的协议，服务于应用层，它的前身是SSL(Secure Socket Layer安全套接字层)，<code>https中的s就是ssl的意思</code> 它实现了将应用层的报文进行加密后再交由TCP进行传输的功能。</p>
<p>TLS协议主要解决如下三个网络安全问题</p>
<ol>
<li>保密(message privacy)，保密通过加密encryption实现，所有信息都加密传输，第三方无法嗅探:2)完整性(messageintegrity)，通过MAC校验机制，一旦被算改，通信双方会立刻发现:</li>
<li>完整性(message integrity)，通过MAC校验机制，一旦被篡改，通信双方会立刻发现;</li>
<li>认证(mutualauthentication)，双方认证,双方都可以配备证书，防止身份被冒充;</li>
</ol>
<blockquote>
<p>生产环境可以购买证书或者使用一些平台发放的免费证书     <code>宝塔等生成证书</code>   <code>nginx</code></p>
</blockquote>
<ul>
<li>key:服务器上的私钥文件，用于对发送给客户端数据的加密，以及对从客户端接收到数据的解密</li>
<li>csr:证书签名请求文件，用于提交给证书颁发机构(CA)对证书签名</li>
<li>crt:由证书颁发机构(CA)签名后的证书，或者是开发者自签名的证书，包含证书持有人的信息，持有人的公钥，以及签署者的签名等信息.</li>
<li>pem:是基于Base64编码的证书格式，扩展名包括PEM、CRT和CER。</li>
</ul>
<h2 id="SSL-TLS认证方式"><a href="#SSL-TLS认证方式" class="headerlink" title="SSL/TLS认证方式"></a>SSL/TLS认证方式</h2><p>通过<code>openssl</code>生成证书和私钥</p>
<ol>
<li>下载</li>
</ol>
<blockquote>
<p><a href="https://slproweb.com/products/Win32OpenSSL.html">Win32/Win64 OpenSSL Installer for Windows - Shining Light Productions (slproweb.com)</a></p>
</blockquote>
<ol>
<li>配置环境变量</li>
<li>命令行测试</li>
</ol>
<h3 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h3><h3 id="编写服务端代码"><a href="#编写服务端代码" class="headerlink" title="编写服务端代码"></a>编写服务端代码</h3><h2 id="token认证"><a href="#token认证" class="headerlink" title="token认证"></a>token认证</h2><p>这个接口需要客户端实现</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PerRPCCredentials <span class="keyword">interface</span> {</span><br><span class="line">    GetRequestMetadata(ctx context.Context,uri ...<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>,<span class="type">error</span>)</span><br><span class="line">    RequireTransportSecurity() <span class="type">bool</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>第一个方法是获取元数据信息，也就是客户端提供的key，value对，context用于控制超时和取消，uri是请求入口的uri</p>
<p>第二个方法的作用是否需要基于tls认证进行安全传输，如果返回值是true，则必须加上tls验证，返回值是false不用 </p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ClientTokenAuth)</span></span> GetRequestMetadata(ctx context.Context, uri ...<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>{</span><br><span class="line">		<span class="string">"appId"</span>:  <span class="string">"tammerdemo"</span>,</span><br><span class="line">		<span class="string">"appKey"</span>: <span class="string">"123123"</span>,</span><br><span class="line">	}, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ClientTokenAuth)</span></span> RequireTransportSecurity() <span class="type">bool</span> {</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloResponse, <span class="type">error</span>) {</span><br><span class="line">	<span class="comment">// 获取元数据的信息</span></span><br><span class="line">	md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> !ok {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"未传输token"</span>)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">var</span> appId <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> appKey <span class="type">string</span></span><br><span class="line">	<span class="keyword">if</span> v, ok := md[<span class="string">"appid"</span>]; ok {</span><br><span class="line">		appId = v[<span class="number">0</span>]</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> v, ok := md[<span class="string">"appkey"</span>]; ok {</span><br><span class="line">		appKey = v[<span class="number">0</span>]</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 校验的过程</span></span><br><span class="line">	<span class="keyword">if</span> appId != <span class="string">"tammerdemo"</span> || appKey != <span class="string">"123123"</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"token不正确"</span>)</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(appId, appKey)</span><br><span class="line">	fmt.Println(<span class="string">"requestName"</span> + req.RequestName)</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.HelloResponse{ResponseMsg: <span class="string">"hello world"</span> + req.RequestName}, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {}</span><br></pre></td></tr></tbody></table></figure>

<p>gRPC将各种认证方式浓缩统一到一个凭证(credentials) 上，可以单独使用一种凭证，比如只使用TLS凭证或者只使用自定义证，也可以务种凭证组合，gRPC提供统一的API验证机制，使研发人员使用方便，这也是gRPC设计的巧妙之处</p>
<h2 id="https-ssl-tls"><a href="#https-ssl-tls" class="headerlink" title="https,ssl,tls"></a>https,ssl,tls</h2><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>首先，HTTP 是一个网络协议，是专门用来帮你传输 Web 内容，HTTP协议大部分网站都是通过 HTTP 协来传输 Web 页面、以及 Web 页面上包含的各种东东(图片，CSS 样式、JS 脚本)。</p>
<h3 id="ssl-tls"><a href="#ssl-tls" class="headerlink" title="ssl/tls"></a>ssl/tls</h3><p>SSL是洋文“Secure Sockets layer”的写，中文叫做“安全套接层”。它是在上世纪90年代中期，由网景公司设计的。(顺便插一句，网景公司不光发明了 SSL，还发明了很多Web的基础设施-比如“CSS样式表”和“JS脚本”)</p>
<p>为啥要发明 SSL 这个协议捍因为原先与联网上使用的 HTTP 协议是明文的，存在很多缺点—传输内容会被偷窥（嗅探）和篡改。发明 SSL 协议，就是为了解这些问题。</p>
<p>到了1999年，SSL 因为应用广泛，已经成为与联网上的事实标准IETF 就在那年把 SSL 标准化。标准化之后的名称政为 TLS(是“Transport Layer Security”的写)，中文叫做“传输层安全协议”</p>
<p>很多相关的文章都把这两者并列称呼(SSL/TLS)，因为这两者可以视作同一个东西的不同阶段。</p>
<h3 id="https-http-2-0"><a href="#https-http-2-0" class="headerlink" title="https(http 2.0)"></a>https(http 2.0)</h3><p>更安全的http传输</p>
<p>解释完 HTTP  SSL/TLS，现在就可以来解释 HTTPS 。咱们通所说的 HTTPS 议，说了就是”HTTP 协”和SSLLS 协”的组合。</p>
<p>你可以把 HTTPS大理解为-“HTTPover SSL”或“HTTP over LS” (反正SSL和TLS 差不多)。</p>
<p>作为背景知识介绍，还需要再稍微谈一下 HTTP 协议本身的特点。HTTP 本身有很多特点，考虑到篇幅有限，只谈那些和 HTTPS 相关的特点</p>
<h4 id="HTTP的版本和历史"><a href="#HTTP的版本和历史" class="headerlink" title="HTTP的版本和历史"></a>HTTP的版本和历史</h4><p>如今咱们用的 HTTP 协议，版本号是 1.1(也就是 HTTP 1.1) 。这 1.1 版本是1995年开始起草的技术文档是 RFC2068)，并在1999年正式发布技术文档是RFC2616)。<br>在1.1之前，还有曾经出现过两个版本“0.9 和1.0”，其中的HTTP 0.9[没有]被广泛使用，而HTTP1.0 被广泛使用过</p>
<h4 id="HTTP-和TCP-之间的关系"><a href="#HTTP-和TCP-之间的关系" class="headerlink" title="HTTP 和TCP 之间的关系"></a>HTTP 和TCP 之间的关系</h4><p>简单地说，TCP协议是HTTP 协议的基石-HTTP 协议需要依靠TCP 协议来传输数据</p>
<p>在网络分层模型中，TCP被称为“传输层协议”，而HTTP被称为“应用层协议“</p>
<p>有很多常见的应用层协议是以TCP 为基础的，比如“FTP、SMTP、POP、IMAP”等CP 被称为”面向连接”的传输层协议、关于它的具体细节，俺就不展开了(否则幅又失控了)，你只需知道:传输层丰要有两协议、分别是 TCP 和 UIDP.TCP比UDP更可靠。</p>
<p>你可以把 TCP 协议想象成某个水管，发送端这头进水，接收端那头就出水。并且 TCP 协议能够确保，先发送的数据先到达(与之相反，UDP不保证这点)。</p>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>所谓的“对称加密技术”意思就是说:“加密”和“解密”使用[相同的密钥。</p>
<p>这个比较好理解。就好比你用 7zip 或 WinRAR 创建一个带密码(口令)的加密压缩包。</p>
<p>当你下次要把这个压缩文件解开的时候，你需要输入[同样的]密码。E这个例子中，密码/口令就如同刚才说的“密钥”</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>所谓的“非对称加密技术”“加密”和“解密”，意思就是说:使用[不同]密钥。</p>
<p>这玩意儿比较难理解，也比较难想到。当年“非对称加密”的发明，还被誉为“密码学”历史上的一次革命。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>笔记</category>
        <category>go</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>技术</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>gpt</title>
    <url>/posts/ca8ec864.html</url>
    <content><![CDATA[<h1 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>非英伟达显卡+win10+Python3.11</p>
<p><a href="https://blog.csdn.net/pointer_onlysoul/article/details/121354353">PyTorch 安装（非英伟达显卡+win10+Python3.8）_python3.8安装pytorch-CSDN博客</a></p>
<h3 id="anaconda"><a href="#anaconda" class="headerlink" title="anaconda"></a>anaconda</h3><p>python的一个发行版本，python的运行环境，就是python的包管理器，简化包管理功能和部署</p>
<h3 id="NAVIDIA-CUDA"><a href="#NAVIDIA-CUDA" class="headerlink" title="NAVIDIA &amp; CUDA"></a>NAVIDIA &amp; CUDA</h3><blockquote>
<p>运算平台，让python等程序语言可以同时在cpu和gpu上跑的一个平台。</p>
</blockquote>
<p>cuda的安装就是安装cuda toolkit（cuda工具包）加上cuda驱动。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="LLM-Large-Language-Model"><a href="#LLM-Large-Language-Model" class="headerlink" title="LLM(Large Language Model)"></a>LLM(Large Language Model)</h3><p>一种基于深度学习技术的自然语言处理模型，也被称作大语言模型。它可以学习自然语言的语法和语义，从而生成可读的文本。</p>
<h3 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h3><p>向模型提供输入以引导其生成特定输出的文本或指令。它是与模型进行交互时用户提供的文本段落，用于描述用户想要从模型获取的信息、回答、文本等内容。Prompt 的目的是引导模型产生所需的回应，以便更好地控制生成的输出。</p>
<h3 id="向量数据库"><a href="#向量数据库" class="headerlink" title="向量数据库"></a>向量数据库</h3><h4 id="GPT-tokens限制"><a href="#GPT-tokens限制" class="headerlink" title="GPT tokens限制"></a>GPT tokens限制</h4><p>GPT 作为 LLM 模型是没有记忆功能的，所谓的记忆功能只是开发者将对话记录存储在内存或者数据库中，当你发送消息给 gpt 模型时，程序会自动将最近的几次对话记录（基于对话的字数限制在 4096 tokens 内）通过 prompt 组合成最终的问题，并发送给 ChatGPT。简而言之，如果你的对话记忆超过了 4096 tokens，那么它就会忘记之前的对话，这就是目前 GPT 在需求比较复杂的任务中无法克服的缺陷。</p>
<h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><blockquote>
<p>向量数据库的核心思想是将文本转换成向量，然后将向量存储在数据库中，当用户输入问题时，将问题转换成向量，然后在数据库中搜索最相似的向量和上下文，最后将文本返回给用户</p>
</blockquote>
<p>当我们有一份文档需要 GPT 处理时，例如这份文档是客服培训资料或者操作手册，我们可以先将这份文档的所有内容转化成向量（这个过程称之为 Vector Embedding<vector embedding="">），然后当用户提出相关问题时，我们将用户的搜索内容转换成向量，然后在数据库中搜索最相似的向量，匹配最相似的几个上下文，最后将上下文返回给 GPT。这样不仅可以大大减少 GPT 的计算量，从而提高响应速度，更重要的是降低成本，并绕过 GPT 的 tokens 限制。</vector></p>
<h4 id="Vector-Embedding"><a href="#Vector-Embedding" class="headerlink" title="Vector Embedding"></a>Vector Embedding</h4><h5 id="传统的数据库"><a href="#传统的数据库" class="headerlink" title="传统的数据库"></a>传统的数据库</h5><blockquote>
<p>本质上是基于文本的精确匹配，这种索引和搜索算法对于关键字的搜索功能非常合适，但对于语义搜索功能就非常弱</p>
</blockquote>
<p>传统数据库无法识别语义关系，例如搜索小狗没法得到柯基等结果，传统的应用需要人为地打上特征标签进行关联。如何生成和挑选特征这个过程(特征工程<feature engineering="">)将原始数据转化成更好的表达问题本质的特征的过程。自动化的方式来提取这些特征，而这可以通过 Vector Embedding 实现。</feature></p>
<h4 id="特征和向量"><a href="#特征和向量" class="headerlink" title="特征和向量"></a>特征和向量</h4><blockquote>
<p>向量数据库的核心在于相似性搜索(Similarity Search)</p>
</blockquote>
<p>我们会通过识别不同事物之间不同的特征来识别种类，例如分别不同种类的小狗，就可以通过体型大小、毛发长度、鼻子长短等特征来区分。如下面这张照片按照体型排序，可以看到体型越大的狗越靠近坐标轴右边，这样就能得到一个体型特征的一维坐标和对应的数值，从 0 到 1 的数字中得到每只狗在坐标系中的位置。</p>
<p><img src="C:\Users\Dra.Tammer\AppData\Roaming\Typora\typora-user-images\image-20240208103113168.png" alt="image-20240208103113168"></p>
<p>然而单靠一个体型大小的特征并不够，像照片中哈士奇、金毛和拉布拉多的体型就非常接近，我们无法区分。所以我们会继续观察其它的特征，例如毛发的长短。</p>
<p><img src="C:\Users\Dra.Tammer\AppData\Roaming\Typora\typora-user-images\image-20240208103131499.png" alt="image-20240208103131499"></p>
<p>这样每只狗对应一个二维坐标点，我们就能轻易的将哈士奇、金毛和拉布拉多区分开来，如果这时仍然无法很好的区分德牧和罗威纳犬。我们就可以继续再从其它的特征区分，比如鼻子的长短，这样就能得到一个三维的坐标系和每只狗在三维坐标系中的位置。</p>
<p>在这种情况下，只要特征足够多，就能够将所有的狗区分开来，最后就能得到一个高维的坐标系，虽然我们想象不出高维坐标系长什么样，但是在数组中，我们只需要一直向数组中追加数字就可以了。</p>
<p>实际上，只要维度够多，我们就能够将所有的事物区分开来，世间万物都可以用一个多维坐标系来表示，它们都在一个高维的特征空间中对应着一个坐标点。</p>
<p>那这和相似性搜索 (Similarity Search) 有什么关系呢？你会发现在上面的二维坐标中，德牧和罗威纳犬的坐标就非常接近，这就意味着它们的特征也非常接近。我们都知道向量是具有大小和方向的数学结构，所以可以将这些特征用向量来表示，这样就能够通过计算向量之间的距离来判断它们的相似度，这就是<strong>相似性搜索</strong></p>
<h4 id="高效的搜索算法"><a href="#高效的搜索算法" class="headerlink" title="高效的搜索算法"></a>高效的搜索算法</h4><p>聚类算法（内存占用大）</p>
<p>量化：内存中可以将聚类中心里面每一个向量都用聚类中心的向量来表示，并维护一个所有向量到聚类中心的码本，减少内存占用。</p>
<p>但是在高维坐标系中，还会遇到维度灾难问题，具体来说，随着维度的增加，数据点之间的距离会呈指数级增长，这也就意味着，在高维坐标系中，需要更多的聚类中心点将数据点分成更小的簇，才能提高分类的质量。否者，向量和自己的聚类中心距离很远，会极大的降低搜索的速度和质量。</p>
<p>但如果想要维持分类和搜索质量，就需要维护数量庞大的聚类中心。随之而来会带来另一个问题，那就是聚类中心点的数量会随着维度的增加而指数级增长，这样会导致我们存储码本的数量极速增加，从而极大的增加了内存的消耗。例如一个 128 维的向量，需要维护 2^64 个聚类中心才能维持不错的量化结果，但这样的码本存储大小已经超过维护原始向量的内存大小了。</p>
<p>解决这个问题的方法是将向量分解为多个子向量，然后对每个子向量独立进行量化，比如将 128 维的向量分为 8 个 16 维的向量，然后在 8 个 16 维的子向量上分别进行聚类，因为 16 维的子向量大概只需要 256 个聚类中心就能得到还不错的量化结果，所以就可以将码本的大小从 2^64 降低到 8 * 256 = 2048 个聚类中心，从而降低内存开销。</p>
<h4 id="向量数据库的选型"><a href="#向量数据库的选型" class="headerlink" title="向量数据库的选型"></a>向量数据库的选型</h4><ol>
<li><p>分布式</p>
</li>
<li><p>访问控制和备份</p>
</li>
<li><p>API &amp; SDK</p>
<blockquote>
<p>api : 接口调用</p>
<p>sdk : 软件开发工具包</p>
</blockquote>
</li>
<li><p>选型</p>
</li>
</ol>
<p>chroma, milvus, pinecone, qdrant, typesense, weaviate</p>
<h3 id="LangChain"><a href="#LangChain" class="headerlink" title="LangChain"></a>LangChain</h3><blockquote>
<p>简化构建高级语言模型应用程序的过程的框架</p>
</blockquote>
<h4 id="what-is-langchain"><a href="#what-is-langchain" class="headerlink" title="what is langchain"></a>what is langchain</h4><p>一个强大的框架，旨在帮助开发人员使用语言模型构建端到端的应用程序。它提供了一套工具、组件和接口，可简化创建由大型语言模型 (LLM) 和聊天模型提供支持的应用程序的过程。LangChain 可以轻松管理与语言模型的交互，将多个组件链接在一起，并集成额外的资源，例如 API 和数据库。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>人工智能</tag>
        <tag>gpt</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT配置utterances</title>
    <url>/posts/14f6913e.html</url>
    <content><![CDATA[<h1 id="NexT配置utterances"><a href="#NexT配置utterances" class="headerlink" title="NexT配置utterances"></a>NexT配置utterances</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>utterances通过Github App实现，可以只对issues授权，因此没有安全性风险，不需要初始化。</p>
<blockquote>
<p><a href="https://utteranc.es/">https://utteranc.es/</a></p>
</blockquote>
<h2 id="创建存储评论的仓库"><a href="#创建存储评论的仓库" class="headerlink" title="创建存储评论的仓库"></a>创建存储评论的仓库</h2><p>新建一个仓库<code>blog_comments_db</code>用来存储评论</p>
<ul>
<li>保证仓库是公开仓库，否则读者没有办法看到这些评论</li>
<li>保证utterances app已经被安装</li>
</ul>
<h2 id="安装Github-Apps"><a href="#安装Github-Apps" class="headerlink" title="安装Github Apps"></a>安装Github Apps</h2><p><code>https://github.com/apps/utterances</code></p>
<p><code>install</code>-&gt;<code>Only select repositories</code>-&gt;<code>blog_comment_db</code></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="创建utterances-swig"><a href="#创建utterances-swig" class="headerlink" title="创建utterances.swig"></a>创建<code>utterances.swig</code></h3><p>在<code>layout/_third-party/comments</code>里创建<code>utterances.swig</code>，内容如下</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line">{<span class="string">%-</span> <span class="string">if</span> <span class="string">page.comments</span> <span class="string">%</span>}</span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">NexT.utils.loadComments(document.querySelector('#utterances-container'),</span> <span class="string">()</span> <span class="string">=&gt;</span> {</span><br><span class="line">    <span class="string">//</span> <span class="string">if</span> <span class="string">(typeof</span> <span class="string">parcelRequire</span> <span class="string">===</span> <span class="string">'function'</span><span class="string">)</span> { <span class="string">return;</span> }</span><br><span class="line">    <span class="string">var</span> <span class="string">js</span> <span class="string">=</span> <span class="string">document.createElement('script');</span></span><br><span class="line">    <span class="string">js.type</span> <span class="string">=</span> <span class="string">'text/javascript'</span><span class="string">;</span></span><br><span class="line">    <span class="string">js.src</span> <span class="string">=</span> <span class="string">'https://utteranc.es/client.js'</span><span class="string">;</span></span><br><span class="line">    <span class="string">js.async</span> <span class="string">=</span> <span class="literal">true</span><span class="string">;</span></span><br><span class="line">    <span class="string">js.crossorigin</span> <span class="string">=</span> <span class="string">'anonymous'</span><span class="string">;</span></span><br><span class="line">    <span class="string">js.setAttribute('repo'</span>, <span class="string">'<span class="template-variable">{{ theme.utterances.repo }}</span>'</span><span class="string">);</span></span><br><span class="line">    <span class="string">js.setAttribute('issue-term'</span>, <span class="string">'<span class="template-variable">{{ theme.utterances.issue_term }}</span>'</span><span class="string">);</span></span><br><span class="line">    <span class="string">js.setAttribute('theme'</span>, <span class="string">'<span class="template-variable">{{ theme.utterances.theme }}</span>'</span><span class="string">);</span></span><br><span class="line">    <span class="string">document.getElementById('utterances-container').appendChild(js);</span></span><br><span class="line">}<span class="string">);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line">{<span class="string">%-</span> <span class="string">endif</span> <span class="string">%</span>}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="创建utterances-js"><a href="#创建utterances-js" class="headerlink" title="创建utterances.js"></a>创建<code>utterances.js</code></h3><p>在<code>scripts/filters/comment</code>下创建<code>utterances.js</code>，内容如下</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">/*</span> <span class="string">global</span> <span class="string">hexo</span> <span class="string">*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">'use strict'</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="string">const</span> <span class="string">path</span> <span class="string">=</span> <span class="string">require('path');</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">Add</span> <span class="string">comment</span></span><br><span class="line"><span class="string">hexo.extend.filter.register('theme_inject',</span> <span class="string">injects</span> <span class="string">=&gt;</span> {</span><br><span class="line">  <span class="string">let</span> <span class="string">theme</span> <span class="string">=</span> <span class="string">hexo.theme.config;</span></span><br><span class="line">  <span class="string">if</span> <span class="string">(!theme.utterances.enable)</span> <span class="string">return;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">injects.comment.raw('utterances'</span>, <span class="string">'&lt;div class="comments" id="utterances-container"&gt;&lt;/div&gt;'</span>, {}, {<span class="attr">cache:</span> <span class="literal">true</span>}<span class="string">);</span></span><br><span class="line"></span><br><span class="line">  <span class="string">injects.bodyEnd.file('utterances'</span>, <span class="string">path.join(hexo.theme_dir</span>, <span class="string">'layout/_third-party/comments/utterances.swig'</span><span class="string">));</span></span><br><span class="line"></span><br><span class="line">}<span class="string">);</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><p><code>NexT主题文件夹</code>-&gt;<code>_config.yml</code></p>
<p>在主题配置文件中添加</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">utterances:</span> </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">"你的repo地址"</span></span><br><span class="line">  <span class="attr">issue_term:</span> <span class="string">"pathname"</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">"github-light"</span></span><br></pre></td></tr></tbody></table></figure>

<p>关于配置选项的更多信息可参考<a href="https://utteranc.es/">官方网站</a>.</p>
<blockquote>
<p>现在我的hexo版本和next版本都是最新的，发现next已经内置了utterances</p>
</blockquote>
<p>所以只需要完成最后一步：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">utterances:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">Dra-Tammer/blog_comments_db</span> <span class="comment"># Github repository owner and name</span></span><br><span class="line">  <span class="comment"># Available values: pathname | url | title | og:title</span></span><br><span class="line">  <span class="attr">issue_term:</span> <span class="string">pathname</span></span><br><span class="line">  <span class="comment"># Available values: github-light | github-dark | preferred-color-scheme | github-dark-orange | icy-dark | dark-blue | photon-dark | boxy-light</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">github-dark</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h2><p>hexo三连</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></tbody></table></figure>

<h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><h3 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h3><p>本地部署，查看评论功能的时候登录会显示404，不知道如何解决，但是将代码push上去之后，访问github page就没有问题，确实加载的时候有点慢。</p>
<p>之后sign with github又能正常使用了</p>
<h3 id="设置部分页面不能评论"><a href="#设置部分页面不能评论" class="headerlink" title="设置部分页面不能评论"></a>设置部分页面不能评论</h3><p>配置之后发现tags, categories, about页面都有评论，想要不能评论，可以在对应的md页面的头部添加<code>comments: false</code>配置项</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2023-08-06 18:10:02</span><br><span class="line">type: categories</span><br><span class="line">comments: false</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>技术</category>
        <category>博客</category>
        <category>Hexo</category>
        <category>NexT</category>
        <category>配置</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>zinx-go</title>
    <url>/posts/b5221bcc.html</url>
    <content><![CDATA[<h1 id="zinx-go"><a href="#zinx-go" class="headerlink" title="zinx-go"></a>zinx-go</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h3><blockquote>
<p>套接字是网络编程中的一种通信机制，是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>
</blockquote>
<h4 id="为什么使用套接字"><a href="#为什么使用套接字" class="headerlink" title="为什么使用套接字"></a>为什么使用套接字</h4><blockquote>
<p>接打电话需要什么？</p>
<p>电话机</p>
</blockquote>
<p>那么套接字就相当于一个电话机，为两边建立TCP提供载体。</p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><blockquote>
<p>电话号码是多少</p>
<p>电话号码是 ***</p>
</blockquote>
<p>调用bind函数给套接字分配地址之后，完成准备工作。</p>
<h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><blockquote>
<p>架起电话线，使得电话能够打进来</p>
</blockquote>
<p>把套接字的状态转换为可连接的状态</p>
<h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><blockquote>
<p>电话铃响</p>
<p>接听</p>
</blockquote>
<p>受理套接字请求</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li>创建套接字</li>
<li>分配IP地址和端口号</li>
<li>状态转换为可接收请求的状态</li>
<li>受理套接字请求</li>
</ol>
<p>TCP客户—服务器程序的执行流程图</p>
<h3 id="字节和比特"><a href="#字节和比特" class="headerlink" title="字节和比特"></a>字节和比特</h3><blockquote>
<p>byte 是字节，一个字节8个比特位</p>
<p>bit 是比特</p>
</blockquote>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>就是假如有一个都要调用的函数<code>func_pro</code>，很多人都要用，每个人在一个固定的点上加上自己的业务，当然不能用<code>if else</code>，这时候使用者在调用这个函数的时候传入一个封装有自己业务逻辑的函数变量。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func_pro</span><span class="params">(<span class="keyword">func</span> f)</span></span> {</span><br><span class="line">    ...</span><br><span class="line">    f()</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>这个函数变量就是回调函数</p>
</blockquote>
<h3 id="实例方法与静态方法"><a href="#实例方法与静态方法" class="headerlink" title="实例方法与静态方法"></a>实例方法与静态方法</h3><blockquote>
<p> 实例方法是实例化之后才能使用</p>
</blockquote>
<h3 id="路由是干什么的"><a href="#路由是干什么的" class="headerlink" title="路由是干什么的"></a>路由是干什么的</h3><blockquote>
<p>提供一个指令，指令对应的一个处理方式，指令和处理方式放在一起叫路由，不同消息不同路由</p>
</blockquote>
<h3 id="为什么在Connection中实现接口"><a href="#为什么在Connection中实现接口" class="headerlink" title="为什么在Connection中实现接口"></a>为什么在Connection中实现接口</h3><p>在Go语言中，接口（interface）是一种抽象类型，它定义了一组方法的集合，但并不实现这些方法的具体行为。接口的实现是通过类型为该接口的值来完成的，这些值可以是任何具有相应方法集的具体类型（通常是结构体）。这种设计允许多种不同的类型实现同一个接口，从而提供了一种灵活的方式来实现多态性。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IRouter <span class="keyword">interface</span> {</span><br><span class="line">    PreHandle(request IRequest)</span><br><span class="line">    Handle(request IRequest)</span><br><span class="line">    PostHandle(request IRequest)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Connection <span class="keyword">struct</span> {</span><br><span class="line">    Router ziface.IRouter</span><br><span class="line">    <span class="comment">// ... 其他字段 ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>Router</code> 字段的类型是 <code>ziface.IRouter</code> 接口。这里有几个关键点：</p>
<ol>
<li><p><strong>多态性</strong>：通过在 <code>Connection</code> 结构体中使用 <code>IRouter</code> 接口类型，您可以将任何实现了 <code>IRouter</code> 接口的具体类型赋值给 <code>Router</code> 字段。这意味着 <code>Connection</code> 可以与多种不同的路由处理逻辑一起工作，只要这些逻辑实现了 <code>IRouter</code> 接口。</p>
</li>
<li><p><strong>解耦</strong>：接口允许 <code>Connection</code> 结构体与具体的路由实现解耦。<code>Connection</code> 不需要知道 <code>Router</code> 字段的具体类型，只需要知道它实现了 <code>IRouter</code> 接口。</p>
</li>
<li><p><strong>扩展性</strong>：如果您需要添加新的路由处理逻辑，您只需创建一个新的类型并实现 <code>IRouter</code> 接口中的方法，而无需修改 <code>Connection</code> 结构体或其它使用 <code>IRouter</code> 的代码。</p>
</li>
<li><p><strong>实现接口而不是对象</strong>：在Go中，通常推荐实现接口而不是直接实现具体的对象。这是因为接口提供了一种定义契约的方式，任何类型都可以实现这个契约，从而使得代码更加灵活和可扩展。</p>
</li>
<li><p><strong>依赖注入</strong>：通过接口，可以实现依赖注入的设计模式，这是软件设计中常用的一种提高代码可测试性和可维护性的方法。</p>
</li>
</ol>
<p>因此，<code>Router</code> 字段被声明为接口类型，而不是一个具体的对象，是为了提供灵活性和可扩展性，同时允许 <code>Connection</code> 结构体与具体的路由实现保持解耦。</p>
<h2 id="基础的server"><a href="#基础的server" class="headerlink" title="基础的server"></a>基础的server</h2><ul>
<li><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>启动服务器</p>
<p>基本的服务器开发：</p>
<ol>
<li><p>创建addr </p>
</li>
<li><p>创建listenner </p>
</li>
<li><p>处理客户端的基本的业务，回显功能</p>
</li>
</ol>
</li>
<li><p>停止服务器</p>
</li>
<li><p>运行服务器</p>
<p>调用Start()方法，调用之后做阻塞处理，在之间可以做一个今后的一个扩展功能</p>
</li>
<li><p>初始化服务器</p>
</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li>name名称</li>
<li>监听的IP</li>
<li>监听的端口</li>
</ul>
</li>
</ul>
<p>先创建两个模块，一个是抽象层接口，一个是实现层</p>
<h2 id="简单的链接封装和业务绑定"><a href="#简单的链接封装和业务绑定" class="headerlink" title="简单的链接封装和业务绑定"></a>简单的链接封装和业务绑定</h2><ul>
<li><p>链接的模块</p>
<ul>
<li><p>方法</p>
<ul>
<li><p>启动链接start</p>
</li>
<li><p>停止链接stop</p>
</li>
<li><p>获取当前链接的conn对象（套接字）</p>
</li>
<li><p>绑定一个链接ID</p>
</li>
<li><p>得到客户端链接的地址和端口</p>
</li>
<li><p>发送数据的方法send</p>
<p>发送数据到客户端</p>
</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><p>socket TCP套接字</p>
</li>
<li><p>链接的ID</p>
</li>
<li><p>当前链接的状态</p>
<p>是否已经关闭，关闭应该把链接给干掉或者回收掉</p>
</li>
<li><p>与当前链接所绑定的处理业务方法</p>
</li>
<li><p>等待被告知的channel告知当前链接是退出，这是一个异步过程，channel去捕获这个状态，等待链接被动退出的channel</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="基础路由模块"><a href="#基础路由模块" class="headerlink" title="基础路由模块"></a>基础路由模块</h2><p>现在我们就给用户提供一个自定义的conn处理业务的接口吧，很显然，我们不能把业务处理的方法绑死在<code>type HandFunc func(*net.TCPConn, []byte, int) error</code>这种格式中，我们需要定一些<code>interface{}</code>来让用户填写任意格式的连接处理业务方法。</p>
<p>那么，很显然func是满足不了我们需求的，我们需要再做几个抽象的接口类。</p>
<h3 id="request请求封装"><a href="#request请求封装" class="headerlink" title="request请求封装"></a>request请求封装</h3><blockquote>
<p>将连接和数据绑定在一起，看成一个元子的请求包</p>
<p>router应该是基于这个request包进行处理</p>
</blockquote>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li>链接IConnection</li>
<li>请求数据</li>
</ul>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li>得到当前连接</li>
<li>得到当前数据</li>
</ul>
<h3 id="Router模块"><a href="#Router模块" class="headerlink" title="Router模块"></a>Router模块</h3><h4 id="抽象的router"><a href="#抽象的router" class="headerlink" title="抽象的router"></a>抽象的router</h4><h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><ul>
<li><p>处理业务之前的方法（钩子）</p>
</li>
<li><p>处理业务的主方法</p>
</li>
<li><p>处理业务之后的方法（钩子）</p>
</li>
</ul>
<h4 id="具体的BaseRouter"><a href="#具体的BaseRouter" class="headerlink" title="具体的BaseRouter"></a>具体的BaseRouter</h4><h5 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h5><ul>
<li><p>处理业务之前的方法（钩子）</p>
</li>
<li><p>处理业务的主方法</p>
</li>
<li><p>处理业务之后的方法（钩子）</p>
</li>
</ul>
<h4 id="自定义的router"><a href="#自定义的router" class="headerlink" title="自定义的router"></a>自定义的router</h4><p>继承BaseRouter去重写方法</p>
<h4 id="为什么还要搞一个BaseRouter"><a href="#为什么还要搞一个BaseRouter" class="headerlink" title="为什么还要搞一个BaseRouter"></a>为什么还要搞一个BaseRouter</h4><p>因为如果每一个自定义的router都继承接口，就要实现接口中的所有方法，但是我们不一定需要hook函数。所以baserouter先空实现接口的方法，然后再让自定义的router去继承baserouter，实现自己想要的函数</p>
<h3 id="zinx集成router模块"><a href="#zinx集成router模块" class="headerlink" title="zinx集成router模块"></a>zinx集成router模块</h3><ul>
<li>IServer增添路由添加功能</li>
<li>Server类增添Router成员</li>
<li>Connection类绑定一个Router成员</li>
<li>在Connection调用已经注册的Router处理业务</li>
</ul>
<h2 id="Q-S"><a href="#Q-S" class="headerlink" title="Q&amp;S"></a>Q&amp;S</h2><blockquote>
<p>在这个包去import其他包的东西的时候会爆红，取消勾选</p>
</blockquote>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">enable <span class="keyword">go</span> modules integration</span><br></pre></td></tr></tbody></table></figure>

<hr>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">Server.<span class="keyword">go</span>:<span class="number">3</span>:<span class="number">8</span>: <span class="keyword">package</span> zinx-<span class="keyword">go</span>/znet is not in GOROOT (D:\Environment\Go\src\zinx-<span class="keyword">go</span>\znet)</span><br></pre></td></tr></tbody></table></figure>

<p>需要引入本地包的话，需要在go.mod中进行修改，两个项目都在src目录下，如下即可解决问题。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">require <span class="string">"zinx-go"</span> v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">replace <span class="string">"zinx-go"</span> =&gt; <span class="string">"../zinx-go"</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>go</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>go</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>《人类简史》</title>
    <url>/posts/a275e0db.html</url>
    <content><![CDATA[<h1 id="《人类简史》"><a href="#《人类简史》" class="headerlink" title="《人类简史》"></a>《人类简史》</h1><p><code>start from 2023-08-30</code></p>
<p><code>end on 2023-09-18 </code></p>
<p><code>尤瓦尔·赫拉利</code></p>
<h3 id="2023-08-31"><a href="#2023-08-31" class="headerlink" title="2023-08-31"></a>2023-08-31</h3><p>采集社会的人类或许比我们聪明，我们现在只需要在各自的领域精通，其他的东西靠着其他人，之前的人需要对自己的周遭都很了解才能很好地生存下去，他们的脑容量或许比我们高。</p>
<h3 id="2023-09-01"><a href="#2023-09-01" class="headerlink" title="2023-09-01"></a>2023-09-01</h3><p>智人是导致澳大利亚等地方大型物种消失的主要原因，这些动物对智人没有防范，农耕是陷阱，降低智慧，多疾病，由奢入俭难，增加人口，疾病增加，挨饿的增加，但是想回去已经不行了，比如奋斗到35之后做自己想做的事，但是有家庭有孩子有房有车要养，有假期要度，不得不继续把自己累个半死，奢侈品最后努力成为某些人的必需品。</p>
<h3 id="2023-09-04"><a href="#2023-09-04" class="headerlink" title="2023-09-04"></a>2023-09-04</h3><p>物种演化上成功不代表个体的幸福，比如牛。生而平等，其实是演化各有不同，不可剥夺的权利就是可变的特性，生命权，自由权和追求幸福的权利就是生命和追求快感。人们相信一些虚构的故事，由想象所建构的次序，人类会去合作。</p>
<h3 id="2023-09-05"><a href="#2023-09-05" class="headerlink" title="2023-09-05"></a>2023-09-05</h3><p>人类不会发现组织自己生活的种种秩序其实只是想象：</p>
<ol>
<li><p>想象建构的秩序深深与真实的世界结合。</p>
</li>
<li><p>想象建构的秩序塑造了我们的欲望。</p>
<p>浪漫主义告诉我们，为了要尽量发挥潜力，就必须尽量累积不同的经验，必须体会不同的情感，尝试不同的关系，品尝不同的美食，还必须学会欣赏不同的音乐。</p>
</li>
<li><p>想象建构的秩序存在于人和人之间思想的连接。</p>
<p>“主观”，“主体间”</p>
</li>
</ol>
<p>身为人类，我们不可能脱离想象所构建的秩序。每一次我们以为自己打破了监狱的高墙，迈向自由的前方，其实只是到了另一间更大的监狱，把活动范围稍稍加以扩大。</p>
<h3 id="2023-09-07"><a href="#2023-09-07" class="headerlink" title="2023-09-07"></a>2023-09-07</h3><p>非洲的黑人对疟疾以及其他疾病的抗性比欧洲的那批白人要好得多，就是因为这样，奴隶主才知道找人干活得找黑人，这种优势反而导致了黑人成为了效率较高的奴隶。黑人歧视是一个死循环，对黑人的评价体系都是建立在歧视黑人的环境之上，导致黑人无法接收良好的教育，环境也是较为恶劣。这是一个死循环。</p>
<p>男权社会，重男轻女的形成原因很难有个定论，肌肉论，流氓理论，父权基因理论（男人找到一个愿意为他生育的女人很难，需要竞争，女人找到一个愿意为他生育的男人相对简单，女人繁殖的时候需要一个男人去照顾）。但是细细考究都发现这些理论站不住脚，有时候男性的角色替换成另一个女性也完全可以解释。这很难有个定论。</p>
<h3 id="2023-09-08"><a href="#2023-09-08" class="headerlink" title="2023-09-08"></a>2023-09-08</h3><p>金钱正是有史以来最普遍也是最有效的互信系统。</p>
<p>人们对黄金的信任，促成了跨国家，跨文化的大量的贸易交流，奠定整个亚非世界统一的基础。</p>
<p>钱是人类最能接收的东西。</p>
<p>帝国的定义只在于文化多元性和疆界灵活性两项。</p>
<p>帝国四处征服，掠夺财富之后，不只是拿来养活军队，兴建堡垒，同时也赞助了哲学，艺术，司法和公益。现在人类之所以有许多文化成就，常常背后靠的就是剥削战败者。</p>
<p>如今全球化就是一种全球帝国的趋势。</p>
<h3 id="2023-09-09"><a href="#2023-09-09" class="headerlink" title="2023-09-09"></a>2023-09-09</h3><p>在金钱和帝国之外，宗教是第三种让人类统一的力量。</p>
<p>宗教认为世界有一种超人类的秩序，而且并非出于人类的想象或是协议。</p>
<h3 id="2023-09-10"><a href="#2023-09-10" class="headerlink" title="2023-09-10"></a>2023-09-10</h3><p>释迦摩尼认为，一切苦难来自每个人心中的思想模式。</p>
<p>在事物带来快乐和苦痛的时候，重点是要看清事物的本质。</p>
<p>欲求的火焰彻底熄灭，原本的欲求就换成了圆满和寂静，称为涅槃，这时就解脱了所有苦痛，能够无比清晰地感受身边的现实，没有什么幻想和幻象。</p>
<p>历史的铁证：事后看来无可避免的事儿，在当时看来总是好不明显。</p>
<p>历史属于二级混沌系统，会受到预测的影响而改变。如果一个计算机程序能预测明天的油价，油价会立刻因为这个预测而波动。</p>
<p>研究历史，不是为了知道未来，而是拓展视野，了解现在的种种绝非偶然，也并非无可避免。未来的可能性超出我们的想象。</p>
<p>没有任何证据，反应历史是为了人类的利益而进展。因为没有对利益的客观的衡量标准。</p>
<p>军备竞赛就是博弈理论的一种体现，有多位参与者的时候，某些概念和行为模式可能对所有的参与者都有害，但就是有办法继续存活下去。军备竞赛只会拖垮所有彼此对立的国家，并不会真正改变军事力量的平衡。</p>
<h3 id="2023-09-11"><a href="#2023-09-11" class="headerlink" title="2023-09-11"></a>2023-09-11</h3><p>科学研究服务于社会意识形态，服务于政治，服务于利益，纯粹是兴趣很难拿到经费。</p>
<h3 id="2023-09-15"><a href="#2023-09-15" class="headerlink" title="2023-09-15"></a>2023-09-15</h3><p>人想要离苦得乐，就必须了解自己所有的主观感受都只是一瞬间的波动，而且别再追求某种感受。如此一来，虽然感受疼痛，但不再感到悲惨；虽然愉悦，但不再干扰心灵的平静。于是，心灵变得一片澄明，自在。</p>
]]></content>
      <categories>
        <category>读书</category>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>《嫌疑人X的献身》</title>
    <url>/posts/43720415.html</url>
    <content><![CDATA[<h1 id="《嫌疑人X的献身》"><a href="#《嫌疑人X的献身》" class="headerlink" title="《嫌疑人X的献身》"></a>《嫌疑人X的献身》</h1><p><code>start from 2023-10-18</code></p>
<p><code>end on 2023-10-18</code></p>
<p><code>东野圭吾</code></p>
<p>周四那天白天上课的时候实在不想听课，听说东野圭吾的《嫌疑人X的献身》也很好看，于是就用微信读书看了看，未曾想，一看就一发不可收拾，着迷于其中，最终花了三个多小时的时间给他一口气看完了，没办法，实在是太好看了。</p>
<p>其实，之前不知道从哪看的对东野圭吾书的评价，说从开始就知道故事结局，只不过看看过程是否精彩。我本以为这本书也是这样，一开始我们就知道了靖子美里母女二人杀了富㭴（后文简称富），石神帮助他们处理了富的尸体并创造不在场嫌疑，那么看书的过程不就是警察，汤川一步步逼近这个结果吗。越往后看，其实不然，石神貌似有一个更加让人毛骨悚然的计划。</p>
<p>小说的开篇为什么要提及那一群流浪汉，提到那个新来的流浪汉对环境的不适应以及社会以及流浪汉群体本身对自己的漠视，开始看的时候感觉这些东西对故事的叙述毫无作用。慢慢接近石神真正的计划，突然发现之前提到的这些东西都是伏笔。石神为了尽管计划泄露也能保证母女二人摆脱牢狱之灾，真正犯下了命案，用流浪汉去替代富，让流浪汉去富的家里留下生活的印迹，留下那个新的自行车，车把上面留下流浪汉的指纹，同时DNA的比对都正确，这样警察从一开始就落入了石神的圈套，他们查的其实是石神犯下的凶杀案，富的案子就这样被悄无声息地掩盖下去，实在巧妙，但也实在残忍，实在是狠，为了掩盖一个罪行去犯下另一个罪行。</p>
<p>那么精密计划到底输在哪里了呢，输在了石神的性格被汤川摸得太透了，石神只会做自己认为正确的事，无论这事儿有多么残酷，需要投入多大的代价，他都会去做。在他万念俱灰，对生活失去希望的，准备一死了之的时候，靖子母女二人犹如白月光闯入石神的生活中，让石神重新燃起了生的希望。为了她们俩，他可以牺牲掉自己的前途，牺牲掉另一个人的生命，他的动力就是对靖子的情感，至于是不是爱，我觉得不然，这只是一个单向的精神的依托。最后汤川跟靖子说清楚自己的推测之后，靖子或许并不倾向于自首，但是美里的割腕让她最后的防线崩塌，心理上还是过不去，想罢美里也很累吧，也被压得喘不过来气吧。或许结局其实对他们是好的，或许是坏的，谁又知道呢。</p>
<p>关于石神对靖子的情感，我想应该很多男生都会有类似的幻想吧，就是俗称的白月光？我高三的时候，连续一个月上下学的时候都会碰见一位女生，我觉得很有缘，于是就去了解她，每次下课拉着我的好哥们借着逛一逛的名义去他们班远远地看她，知道她有对象之后或许很失落但是还是会去看哈哈哈，最离奇就是高考前一天，我们俩在书店碰到了，并且先后付款，老板错把她的东西给了我。说真的，我当时心理怦怦跳的，激动地乱斗。高考结束之后也是加了她的联系方式，开始的一段时间也是天天聊，之后知道她对象表白之后就不咋聊，越来越寡了哈哈哈，后来也就是朋友圈互相问候一下，节日问候一下。但是每次想到高三的那段黑暗的时间，去三楼转真的是少有的让我开心的事儿。石神理由是否和我一样？</p>
<p>如果没有美里自残那最后一根稻草，靖子会不会自首，还是跟工藤幸福生活下去？不得而知，但是石神确实为着靖子的幸福，他真的爱她，但是悲哀的是，她不爱她，她对他只是感谢和内疚。为了一个不爱自己的人付出如此多真的值得，石神自己认为值得就行了。</p>
<p>很棒的一部小说，很精彩，真相慢慢浮出水面的时候真的是按耐不住激动的心，必须得给它读完。</p>
<p>石神是天才，性格上的缺陷决定了他的结局，所有人都是如此。逻辑思维和感性思维同等重要，男女互补才是正道。</p>
<p>纯粹的爱情，绝妙的诡计，无懈可击的推理，惊人的伏笔，不易猜透的悬念，理智与情感交织碰撞。谎言里交织着人性的善与恶，真相里闪烁着灵魂的喜与悲，诡计里包含着深深的爱与痛楚，包含着难以言表的心情。</p>
]]></content>
      <categories>
        <category>读书</category>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>《云边有个小卖部》</title>
    <url>/posts/4c32c6bc.html</url>
    <content><![CDATA[<h1 id="云边有个小卖部"><a href="#云边有个小卖部" class="headerlink" title="云边有个小卖部"></a>云边有个小卖部</h1><p><code>start from 2024-09-30</code></p>
<p><code>end on 2024-10-06</code></p>
<p>先是看的电影，之后去找的原著。就不该先看电影，搞得我看书的时候觉得程霜就该长周也那样，周也真的是标准的初恋脸，外婆也就该长电影里的外婆那样，男主倒是无所谓哈哈哈哈。</p>
<p>我觉得这个小说看起来像一个童话，催泪结尾的童话，整个过程就是刘十三的成长过程。从一个我们传统意义上的没本事的人一步一步成熟，一步一步失去最爱的人，最后成长。</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><blockquote>
<p>抄自百度</p>
</blockquote>
<p>该小说主要写了云边镇少年刘十三的成长故事，前半部分写了刘十三从云边镇走向城市，在校园爱情、职场中受挫且伤痕累累，后半部分写刘十三被外婆王莺莺用拖拉机拉回了云边镇，在云边镇感受到的世情冷暖。该小说表达了对故乡、对亲情的衷心倾诉。外婆王莺莺的乐观坚韧和无限包容，程霜像一道光一样短暂又永恒，刘十三的奋斗与卑微，云边镇迷人的自然风景、悠然的生活节奏，共同构成了云边故乡的美好意境。</p>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><p>我有很重要的事，输了的话，我就真的一无所有了。</p>
<p>幻觉很好，做梦也很好，一切远离现实的都很好。</p>
<p>有些人刻苦铭心，没几年会遗忘；有些人不论生死，都陪在身边。</p>
<p>月亮挂在半空，小镇背倚着起起伏伏的峰峦，山形边缘浮动银白色。</p>
<p>明明一块儿踏青野炊点篝火，大自然如此美好哭什么，难道触景生情，哭的是一岁一枯荣？</p>
<p>它们夹在笔记本最后的空白页，像夹在时光的间隙，人们随口说的一些话，跌落墙角，风吹不走，阳关烧不掉，独自沉眠。</p>
<p>为别人活着，也要为自己活着；希望和悲伤，都是一缕光；总有一天，我们会再相遇。</p>
<p>山风微微，像月光下晃动的海浪；温和而柔软，停留在时光的背后；变成小时候听过的故事；在遥远的城市，陌生的地方，有他未曾见过的山和海。</p>
<p>生命是有光的，在我熄灭以前，能够照亮你一点，就是我所有能做的了，我爱你，你要记得我。</p>
<p>跌倒一次，好不容易刚爬起来！没想到没走几步又狠狠地摔倒！想放弃这辈子就是个废物！但是为了亲情和责任又爬起来！装作没事的人，又接着上路。</p>
<p>原来世界上很多事情，不是你有计划，有毅力就能做到的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优点就是生活化做的很好，有时候叙事的同时会冷不丁地冒出来很有生活气息的一句话，让人感觉这是作者亲身经历过的事情，也容易引起共鸣，看书的时候会心一笑，开心一下。</p>
<p>看的时候感觉槽点很多，有些东西不能细想，有些东西太理想化。有人说作者是用了虚实结合的手法，情节是虚构的，但是人物测情感内核是真的。（十三的谐音是失散，程霜可能是成双成对，但终究是一场梦）。</p>
<p>耐心读完，一边吐槽一边大受感动，感受到了平时身边的人的对自己的爱是陪伴。</p>
<p>当不开心的时候或者想要消磨时间的时候，这本书是一个不错的选择，故事也很容易理解，十分具有生活气息。人和人之间舒服的关系，是可以一直不说话，也可以随时说话。</p>
]]></content>
      <categories>
        <category>读书</category>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>《浪潮之巅》</title>
    <url>/posts/901b430.html</url>
    <content><![CDATA[<h1 id="《浪潮之巅》"><a href="#《浪潮之巅》" class="headerlink" title="《浪潮之巅》"></a>《浪潮之巅》</h1><p><code>start from 2023-09-21</code></p>
<p><code>end on 2023-09 </code></p>
<h3 id="2023-09-21"><a href="#2023-09-21" class="headerlink" title="2023-09-21"></a>2023-09-21</h3><p>AT&amp;T(American telephone and telegraph corporation) 贝尔实验室就是其建立的。</p>
<p>IBM(International business machines corporation)</p>
<h3 id="2023-09-22"><a href="#2023-09-22" class="headerlink" title="2023-09-22"></a>2023-09-22</h3><p>计算机行业三大定律</p>
<ol>
<li><p>摩尔定律：每18个月，计算机等IT产品地性能会翻一番。</p>
</li>
<li><p>安迪-比尔定律：软件吃掉硬件的性能，程序员越来越不精打细算了。</p>
<p>在IT工业的产业链中，处于上游的是“看不见摸不着”的软件和IT服务业，而下游才是“看得见摸得着”的硬件和半导体。因此，从事IT行业，想要获取高额的利润，从上游做起。</p>
<p>苹果是一个例外，他成为一种时尚和潮流。</p>
</li>
<li><p>反摩尔定律：一个IT公司如果今天和18个月前卖掉同样多的同样的产品，它的营业额就要降一半。</p>
<p>促进科技领域质的进步，并为新兴公司提供生存和发展的可能。</p>
<p>小公司靠创新的质的进步可以和大公司掰掰手腕或者被收购。</p>
</li>
</ol>
<p><strong>Steve Jobs: Stay hungry, stay foolish  永远渴望，大智若愚</strong> </p>
<h3 id="2023-09-23"><a href="#2023-09-23" class="headerlink" title="2023-09-23"></a>2023-09-23</h3><p>ARM(Advanced RISC Machines)</p>
<p>大部分平板的芯片基于RISC（精简指令集）</p>
<p>CISC（复杂指令集）</p>
<p>诺威格效应：当公司的市场占有率&gt;50% ，市场占有率无法再翻番了。公司就必须去挖掘新的成长点。</p>
<p>微软打击苹果，莲花等公司的手段，转市场优势为技术优势。</p>
<p>盖茨志向远大，又非常脚踏实地，管理上，微软是严格的自顶向下的树状结构，和硅谷公司松散的结构完全不同。</p>
<p>盖茨和巴菲特的做法相同，从每一个人身上或多或少地挣一笔钱，而不是从富人身上狠宰一刀了事。</p>
<h3 id="2023-09-24"><a href="#2023-09-24" class="headerlink" title="2023-09-24"></a>2023-09-24</h3><p>山姆大叔：纽约州长带领一些人前往其加工厂参观，看到牛肉桶上都盖有E.A.-U.S.的标记，便问是何意思。工人回答，E.A.是一个军火承包商的名字，U.S.是美国的缩写。凑巧的是，“山姆大叔”的缩写也是U.S.，所以一个工人开玩笑地说，U.S.就是“山姆大叔”（Uncle Sam）。这件趣事传开后，“山姆大叔”名声大振。人们把那些军需食品都称为“山姆大叔”送来的食物。</p>
<p>合众国(United States)也是US。</p>
<h3 id="2023-09-25"><a href="#2023-09-25" class="headerlink" title="2023-09-25"></a>2023-09-25</h3><p>树状管理：自上而下的管理结构，层次分明</p>
<p>网状管理：在网状组织结构下，单个个体都是一个个<strong>经营单位</strong>，拥有个别的核心专长，分子间可依不同需求彼此整合成整体进行合作，以保持一定的竞争能力，单个个体还可以自由地对外寻求合作伙伴进行整合。</p>
<p>在网状组织下，真正作业的是<strong>独立的单位</strong>，组织即使复杂，也还是虚拟的。大的集团有大的虚拟总部来控制，小的集团有小的虚拟总部。在这里总部的动作是相当有限的。组织内的单位或称节点在各自分工的范围内运作。</p>
<p>在这种管理构架中，出现「决策的去中心化」的趋势，管理者的角色转变充满了痛苦和挑战。从英雄变成园丁，要负责缔造组织环境，维系组织氛围，培养人员能力。从具体的管理任务角度，目标如何确定和分解，内部关系如何进行取舍和协调，人员如何选拔和晋升，考核与激励机制如何设计，这都是尚未澄清的主题。</p>
<p>思科公司内部创业之后收购</p>
<p>泡沫经济我的理解是吹出来的，过分看好某一个行业的前景，导致回报对不起投资。</p>
<h3 id="2023-10-21"><a href="#2023-10-21" class="headerlink" title="2023-10-21"></a>2023-10-21</h3><p>创业的关键之一是找到志同道合的人。由于斯坦福这种内紧外松的环境，学生们交际的圈子相对较广，容易打造一个可以互补的创业团队（Founding team）。而在完全追求学分的大学里，每个人能深入了解的大多是自己的同班同学，或者同实验室的同事，但朋友之间的互补性不强。</p>
<p>斯坦福大学的学生不仅在学业上出类拔萃，而且有各种各样的特长。</p>
<p>不接触各种各样的人就无法想象天地之大，世界之多样。</p>
<p>对年轻的学生最有益的校园环境，就是那种最贴近今后真实生活的社会环境。在斯坦福大学，人员的构成和真正的社会并无太大差异，每一个年轻人周围又是各种行业的佼佼者，在这种环境中互相学习几年，外延就变得宽阔起来。对于大部分学生来说，在斯坦福大学的岁月里学到的社会知识比课堂知识对自己的一生更有帮助。麻省理工的工科生会有着更多的“呆气”。</p>
<p>大学应该培养全才，不仅自己的技术要过硬，更要学会人际交往，学会做人。</p>
<p>先成人，后成才。</p>
]]></content>
      <categories>
        <category>读书</category>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>《恶意》</title>
    <url>/posts/8c0c5825.html</url>
    <content><![CDATA[<h1 id="《恶意》"><a href="#《恶意》" class="headerlink" title="《恶意》"></a>《恶意》</h1><p><code>start from 2023-10-21</code></p>
<p><code>end on 2023-10-26</code></p>
<p><code>东野圭吾</code></p>
]]></content>
      <categories>
        <category>读书</category>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>《挪威的森林》</title>
    <url>/posts/f9101cf7.html</url>
    <content><![CDATA[<h1 id="《挪威的森林》"><a href="#《挪威的森林》" class="headerlink" title="《挪威的森林》"></a>《挪威的森林》</h1><p><code>start from 2023-10-23</code></p>
<p><code>end on 2023-10-24</code></p>
<p><code>村上春树</code></p>
<blockquote>
<p>谁会喜欢孤独，不过是不喜欢失望</p>
</blockquote>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>故事发生在20世纪六七十年代的日本，写的是20岁的年轻人彷徨无助的爱情。二战以后，日本经济快速复苏，那个时候的日本，生活水平和我们现在基本相当，温饱思淫欲，加之当时的日本受美国思潮影响比较大，整个社会充斥着性开放甚至叫性泛滥，人们对性有着很高的包容度，这种环境下，年轻人贞洁观念及其淡薄，对婚前性行为习以为常。</p>
<p>和上世纪六七十年代的美国相似，当时的日本年轻人思想空虚，追求虚无，嬉皮士流行，很多年轻人产生了精神问题，抑郁症、精神疾患频发，自杀率居高不下。本书中接连不断发生的自杀现象，增加了故事的沉重和伤感。虽然是一本爱情小说，但丝毫没有感受到爱情的甜美，反而被浓重的伤感所包围，就像陷进了连月不开的霏霏的阴雨中，湿冷而阴暗，无处躲藏，只能把自己完全融进去，和阴郁的天气一起发抖、哀伤。</p>
<p><strong>我们现在青年人渐渐抛弃了旧日里的传统，忽视了人与人之间的原始维系，能够轻易地获取到各种各样的信息，不再需要依靠社交的交流，极大化的信息量与极小化的生活圈的矛盾，社会到处弥漫着浮躁之气。</strong>每个人都像一个火药桶，一点小事就可能转化为极大的悲剧。</p>
<h2 id="挪威的森林（披头士乐队）"><a href="#挪威的森林（披头士乐队）" class="headerlink" title="挪威的森林（披头士乐队）"></a>挪威的森林（披头士乐队）</h2><p>Knowing she world，感觉不是特别好，就谐音了一下，Norwegian wood</p>
<h2 id="左翼与右翼"><a href="#左翼与右翼" class="headerlink" title="左翼与右翼"></a>左翼与右翼</h2><p>左翼和右翼政治观点的区别，表现哲学观、历史观上，也表现在对经济的政策上，表现在变革与保守上。严格说来左翼和右翼是民主政体下的两个派别，是两党制的渊源，是自由主义的两个群体，而专制政体下是不存在这两个派别的，所以左翼和右翼是民主政治的概念。</p>
<p>在哲学观、历史观上，<strong>左翼一般认为历史是人民创造的，信奉“小民史观”，其政治主张是偏向下层人民，草根阶层的。左翼反对贫富悬殊，追求社会公平和“均贫富”，认为贫困是由于“不公正”而造成的，国家、社会应对个人的不幸负责。</strong>左翼梦想一个和谐的、公正的社会，在经济政策上主张加强国家宏观控制，扩大税收，特别是针对富人的税收，扩大公共福利，甚至不惜举办国家公共工程来解决经济危机和失业问题。<strong>左翼总的来说是变革的、进步的，是自由主义和民主政治的原教旨阵地。</strong></p>
<p>右翼则正好相反，右翼信奉的是“英雄史观”，认为历史是英雄创造的，其政治主张是偏向中产阶级、精英阶层的。右翼特别反对左翼的“均贫富”的观点，认为这实际上是在追求终点的平等，是错误的。<strong>右翼和左翼共同之处是都追求起点的平等，但右翼更强调个人的使命感和责任感，强调国家应给每一个公民以机会，尊重每一个人的个性，强调平等受教育（基础教育）的权力，认为人必须对自已的命运负责，贫困只能源于自已的低素质、懒惰和无能，不能怪其他的因素。</strong>右翼的经济政策是主张自由放任的，主张小政府、大社会，对经济的干预和宏观调控越少越好，通过主张减税、减少公共福利、刺激投资来解决失业问题和社会问题，认为福利越多，人的的依赖性就越强，进取心就越差，就会鼓励懒惰，打击勤奋，因此对一个国家的前途将造成消极的影响。</p>
<p><strong>右翼强调“法律和秩序”，是保守主义的，也反对变革，右翼的经济观点是正宗的自由主义，但其政治观点是自由主义的侧门。</strong></p>
<p>在民主政治下，左翼和右翼，不存在谁正确谁错误、谁先进谁反动的问题，左翼和右翼是一个国家、一个民族的左右手，是缺一不可的。<strong>一个国家不可能长期由左翼执政，否则社会太均匀、太福利化将会阻碍经济的发展，同时容易走向民粹主义；一个国家同样不能由右翼长期执政，否则贫富悬殊就会导致社会不公正，分配不公，最终也会阻碍经济的发展。</strong>一个国家的“自由进程”之路不可能是笔直的，自由之路就象公路一样是弯弯曲曲的，民主政治就是一辆汽车，要想在自由之路上顺利前进，就必须要随时调整方向盘，一会儿向右拐弯，一会儿向左拐弯，只有这样，这辆汽车才不会冲出公路而翻车倾覆，才会顺利直达终点。所以，左翼和右翼的轮流执政，轮流调整国家前进之路，是民主政治下两党制的基础。真正成熟的民主国家，一般只有左、右两个主要政党，而政党林立的民主国家，其民主政治仍是不成熟的、幼稚的，还处在民主政治的低级阶段。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>人都渴望同类的理解，谁又能真正地理解自己。</p>
<p>成长恰恰是人们同孤独抗争，受伤、失落、失去却又要活下去。</p>
<p>尽管你可能心里难受，但还是要坚强起来，要再成熟一些，成为大人。</p>
<p>死不是生的对立面，而是作为生的一部分永存。生离也好死别也罢，都不是结束，而是作为一种意义，寄存于生者的生之中。与所爱之人所有的互动，塑造了现在的我。</p>
<p>洪桑说他看的时候是偏向致郁的感觉（他当时是高中的时候看的），但是大三的我看这部小说的时候却不是这种感觉，更多的时候是一种感同身受，那种在时代的浪潮下不知道何去何从的无力感，迷茫感。我也向往有一位女生在旁作伴，在悲伤的时候互相倾诉，在欢乐的时候享受幸福，不仅是肉体上的伴侣，同时也是精神伴侣。我们大多数人都是普通人，成为精英的就一点点，归根结底就是脚踏实地的，做好自己当下该做好的事情，我相信最后的结果一定不会差。这段时间是真的焦虑，保研边缘人物真是一个很抽象的东西，我也在思考，综测的这些东西我是真的不喜欢吗，还是只是我懒，不相干而已。我的目标是什么？该咋办？</p>
<p>这本书也是在上课的时候看完的，对我来说是平静，是引起我的思考，思考我的近况，思考未来。</p>
<p>大学的生活真的很孤独，这种孤独不是身边没有一起游戏的朋友，而是各自要走的路都不一样，成长的路上没有交心的朋友作伴，唯有孤独前行。面对孤独，处理好了就是进步，处理不好就是堕落，但是更多的是原地踏步，有时候感觉平静稳定的生活是真的很好。</p>
]]></content>
      <categories>
        <category>读书</category>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>《杀死一只知更鸟》</title>
    <url>/posts/842c0a9a.html</url>
    <content><![CDATA[<h1 id="杀死一只知更鸟"><a href="#杀死一只知更鸟" class="headerlink" title="杀死一只知更鸟"></a>杀死一只知更鸟</h1><p><code>start from 2024-04-03</code></p>
<p><code>end on 2024-04-10</code></p>
<p><code>哈珀·李</code></p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>我是通过微信读书的榜单知道这本书的，刚开始阅读的时候并没有这么上瘾，在交代斯库特，杰姆，迪尔他们的童年生活，一开始很疑惑这个阿迪克斯是什么人，随着阅读的深入，发现是他们的爸爸。他允许自己的孩子呼喊自己的名字，这点很特殊。幼年的孩子们天真烂漫，富有好奇心，他们想瞥见怪人拉德利的生活，并无恶意地去“打扰”怪人的生活，最后也获得了回应，树洞里的礼物证明了这一点，但是最后树洞被水泥封上了。之后故事围绕汤姆的强奸案展开，从这开始，我逐渐开始上瘾。黑人被最底层的白人造谣强奸，在当时的社会这是要判处死刑，但是阿迪克斯根据证据发现他是清白的。他一直努力在帮助黑人脱罪，但是最后还是杀不死人们一贯的偏见。汤姆也摆脱不了固有的天性，反抗被枪杀。在这个过程上，我和周围人都在不停地成长，周围人的形象也在一步一步地立体了起来。本书以尤厄尔的死亡告终，赫克和阿迪克斯都在用自己的方式去帮助那个怪人，去守护那一片纯真的心灵。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><blockquote>
<p>阿迪克斯是一位伟大的父亲，也是普通人的榜样</p>
</blockquote>
<p>阿迪克斯是一名律师，为他人声张正义，他一直为自己内心的正义工作，即便受到死亡威胁，他也不害怕。能够克服当时固有的种族歧视去帮助一个黑人脱罪。虽然最后没有成功，但是大家都知道他是能够无偏见地去帮助每一个人去声张正义。正义之士的形象跃然纸上。</p>
<p>同时他也是一名父亲，对孩子们管教有加，在怪人拉德利的事情上，阿迪克斯给与了孩子们最大的探索空间，告诉孩子们危险之处在哪，但是没有过多的阻拦，只做了最基础的警告。能够陪孩子们一起看报，将自己的思想传播给孩子们，给予孩子们平等的说话权。在孩子们犯错的时候给孩子们时间去解释整个事情的流程，而不是妄加指责。他是孩子们的父亲，良师和益友。他教会孩子们为人处世的道理，耐心纠正孩子们的错误，同时又给孩子们最大的个人思考的空间。这种教育的方式值得借鉴，同时也是理想的教育方式。</p>
<blockquote>
<p>不要用自己的标准去衡量和要求别人</p>
</blockquote>
<p>小说的最后杰姆看不懂看不惯人们的做法，为什么他们明知道事实的真相，但是却选择了撒谎。他认为其他人的做法都是错的。这个对我的思考很大，最近在组队搞比赛。组内的大佬一股子恃才放旷味道，也是火上眉头，差点冲突。但是看完这本书之后一想，每个人有每个人待人处事的方式，这或许就是他这个人的特点，我们不能拿我们认为对的东西去严加要求别人应该怎么干，怎么做事。自己做事问心无愧即可。</p>
<blockquote>
<p>优秀的人懂得尊重别人</p>
</blockquote>
<p>鲁迅先生曾经说过(应该是)，我原先以为别人尊重我是因为我优秀，后来发现，别人尊重我是因为别人优秀。无论面对的是谁，都要把对方当作人去看待。</p>
<blockquote>
<p>有些道理是成长之后才会知道的</p>
</blockquote>
<p>有时候不了解父母的某些做法，是不是因为阅历不够，经验不足呢。</p>
<blockquote>
<p>低调做人，高调做事</p>
</blockquote>
<p>阿迪克斯就是这一类人，自己本身其实非常优秀，但是他并没在孩子们面前鼓吹自己有多么多么牛掰，自己跟其他的父母相比有多么多么地好，而是将自己的价值观一点一点在平时的生活中传递给孩子们。在与孩子们生活的过程中让孩子们觉得自己父亲的本事是理所应当的，是能够深刻体会到的，而不是靠嘴吹牛逼出来的。</p>
<p>这是大三下学期看的第一本书，清明之后集中给他看完了，看后心中平静了不少，清明左右拔了两颗牙，又碰上计设ddl，难免火气大，感谢自己撑住了三天，感谢文字，无论是课程老师传授还是文字表达，都能让我犯错或者迷茫之时找到方向，有所启发，瞥见他人思想，他人经验总结出来的精华。同时又遇到了一位她，老去的心又年轻了一回hh，但是可惜。</p>
<p>好，再会！</p>
]]></content>
      <categories>
        <category>读书</category>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>《白夜行》</title>
    <url>/posts/ba52eee0.html</url>
    <content><![CDATA[<h1 id="《白夜行》"><a href="#《白夜行》" class="headerlink" title="《白夜行》"></a>《白夜行》</h1>]]></content>
      <categories>
        <category>读书</category>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>《解忧杂货铺》</title>
    <url>/posts/79b1aa9b.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>读书</category>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>《追风筝的人》</title>
    <url>/posts/ab39eefc.html</url>
    <content><![CDATA[<h1 id="追风筝的人"><a href="#追风筝的人" class="headerlink" title="追风筝的人"></a>追风筝的人</h1><p><code>start from 2024-04-12</code></p>
<p><code>end on 2024-04-24</code></p>
<p><code>卡勒德·胡塞尼</code></p>
]]></content>
      <categories>
        <category>读书</category>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器的基本配置（宝塔）</title>
    <url>/posts/48fc7caa.html</url>
    <content><![CDATA[<h1 id="云服务器的基本配置（宝塔）"><a href="#云服务器的基本配置（宝塔）" class="headerlink" title="云服务器的基本配置（宝塔）"></a>云服务器的基本配置（宝塔）</h1><blockquote>
<p>uname -a 查看当前的操作系统的版本信息等</p>
<p>clear 清屏</p>
<p>netstat -lntp 当前哪些端口被监听，进程号</p>
</blockquote>
<h2 id="阿里云的云服务器ECS"><a href="#阿里云的云服务器ECS" class="headerlink" title="阿里云的云服务器ECS"></a>阿里云的云服务器ECS</h2><p>云服务器 ECS（Elastic Compute Service）是一种弹性可伸缩的计算服务，助您降低 IT 成本，提升运维效率，使您更专注于核心业务创新。<br>云服务器Elastic Compute Service（ECS）是阿里云提供的一种基础云计算服务。使用云服务器ECS就像使用水、电、煤气等资源一样便捷、高效。您无需提前采购硬件设备，而是根据业务需要，随时创建所需数量的云服务器ECS实例。在使用过程中，随着业务的扩展，您可以随时扩容磁盘、增加带宽。如果不再需要云服务器，也能随时释放资源，节省费用。</p>
<h2 id="宝塔部署"><a href="#宝塔部署" class="headerlink" title="宝塔部署"></a>宝塔部署</h2><p>进入宝塔的官网，按照要求复制命令</p>
<p><code>[安装宝塔 (bt.cn)](https://www.bt.cn/admin/servers#wcu)</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh ed8484bec</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Firewall reloaded</span><br><span class="line">-----------------</span><br><span class="line">Congratulations!Installed successfully!</span><br><span class="line">-----------------</span><br><span class="line">------------面板账户登录信息------------</span><br><span class="line">外网面板地址：http://47.94.226.225:25591/6b522cf4</span><br><span class="line">内网面板地址：http://172.25.148.217:25591/6b522cf4</span><br><span class="line">username:8fc2e0c1</span><br><span class="line">password:9078a650</span><br><span class="line">------------打开面板请查看------------</span><br><span class="line">【云服务器】请在安全组放行25591端口</span><br><span class="line">因默认启用自签证书https加密访问，浏览器将提示不安全</span><br><span class="line">点击【高级】-【继续访问】或【接收风险并继续】访问</span><br><span class="line">教程：https://www.bt.cn/bbs/thread-117246-1-1.html</span><br><span class="line">-----------------</span><br><span class="line">Time consumed: 2 Minute!</span><br></pre></td></tr></tbody></table></figure>

<p>启动在25591</p>
<p>要在阿里云开放入方向的25591端口，出方向就不管，因为从服务器中出来的对于我们来说是安全的</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">serverbaota</span><br><span class="line">720118</span><br><span class="line">/safeserver</span><br></pre></td></tr></tbody></table></figure>

<h2 id="环境的快捷安装"><a href="#环境的快捷安装" class="headerlink" title="环境的快捷安装"></a>环境的快捷安装</h2><p>进入宝塔的云服务器的管理页面，从软件商店里找。（Nginx，MySQL等等）</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>缓存，给我们的网站做加速</p>
<h2 id="宝塔部署vue项目"><a href="#宝塔部署vue项目" class="headerlink" title="宝塔部署vue项目"></a>宝塔部署vue项目</h2><p>点击网站，添加站点，输入公网IP:端口创建即可。将vue项目打包，上传dist文件。将根目录修改到dist。</p>
<ul>
<li>部署的时候记得打开监听的端口，阿里云和宝塔两个地方都要打开，nginx监听的端口也要记得修改</li>
<li>目录一直整到dist目录</li>
</ul>
<h3 id="修改请求的地址"><a href="#修改请求的地址" class="headerlink" title="修改请求的地址"></a>修改请求的地址</h3><p>发现用localhost请求发送不对</p>
<p>使用浏览器访问是通的</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 解决方法用了最原始的方法</span><br><span class="line">// baseURL: 'http://localhost:8080', </span><br><span class="line">   改成 baseURL: 'http://47.94.226.225:8080'</span><br></pre></td></tr></tbody></table></figure>

<p>这可太蠢了，但是访问本机的就是搞不好hhh</p>
<h2 id="宝塔部署MySQL数据库"><a href="#宝塔部署MySQL数据库" class="headerlink" title="宝塔部署MySQL数据库"></a>宝塔部署MySQL数据库</h2><h3 id="查看MySQL的服务状态"><a href="#查看MySQL的服务状态" class="headerlink" title="查看MySQL的服务状态"></a>查看MySQL的服务状态</h3><blockquote>
<p>systemctl status mysql</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">● mysqld.service - LSB: start and stop MySQL</span><br><span class="line">     Loaded: loaded (/etc/init.d/mysqld; generated)</span><br><span class="line">     Active: active (running) since Tue 2023-11-07 17:59:34 CST; 3h 37min ago</span><br><span class="line">       Docs: man:systemd-sysv-generator(8)</span><br><span class="line">      Tasks: 26 (limit: 4195)</span><br><span class="line">     Memory: 188.6M</span><br><span class="line">        CPU: 3.118s</span><br><span class="line">     CGroup: /system.slice/mysqld.service</span><br><span class="line">             ├─127753 /bin/sh /www/server/mysql/bin/mysqld_safe --datadir=/www/server/data --pid-file=/www/server/data/iZ2ze12gjhwzsrx3tpmpm1Z.pid</span><br><span class="line">             └─128391 /www/server/mysql/bin/mysqld --basedir=/www/server/mysql --datadir=/www/server/data --plugin-dir=/www/server/mysql/lib/plugin --user=mysql --log-error=iZ2ze12gjhwzsrx3tpmpm1Z.err --open-files-limit=65535 --pid-file=/www/server/data/iZ2ze12gjhwzsrx&gt;</span><br><span class="line"></span><br><span class="line">Nov 07 17:59:34 iZ2ze12gjhwzsrx3tpmpm1Z systemd[1]: Starting LSB: start and stop MySQL...</span><br><span class="line">Nov 07 17:59:34 iZ2ze12gjhwzsrx3tpmpm1Z mysqld[127740]: Starting MySQL *</span><br><span class="line">Nov 07 17:59:34 iZ2ze12gjhwzsrx3tpmpm1Z systemd[1]: Started LSB: start and stop MySQL.</span><br></pre></td></tr></tbody></table></figure>

<p>如此即为服务运行正常</p>
<h3 id="MySQL修改表名"><a href="#MySQL修改表名" class="headerlink" title="MySQL修改表名"></a>MySQL修改表名</h3><p>MySQL修改表名很麻烦，本质就是建立新数据库然后备份转存</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">使用Navicat</span><br><span class="line">先右键老的数据库，转储数据库文件，然后在新库导入数据库文件即可</span><br></pre></td></tr></tbody></table></figure>

<p><font style="color:red">遇到了上传了sql文件但是服务器上的数据库中无内容，可能是mysql的版本不对应</font></p>
<p>修改了宝塔中装的MySQL的版本，问题解决。</p>
<h3 id="命令行访问"><a href="#命令行访问" class="headerlink" title="命令行访问"></a>命令行访问</h3><p>首先记得在宝塔页面修改root的密码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mysql -u root -p 登录mysql服务</span><br></pre></td></tr></tbody></table></figure>

<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>回到宝塔页面，点击添加数据库，数据库名和用户名要一致，不一致要报错。</p>
<p>将本地数据库中的内容转储，得到一个例如<code>car_sales.sql</code>文件，不要随意修改名称，保证建立的数据库的名称跟<code>.sql</code>之前的内容一致。</p>
<p>老样子，记得宝塔和阿里云开启3306端口的权限。</p>
<h2 id="宝塔部署go项目"><a href="#宝塔部署go项目" class="headerlink" title="宝塔部署go项目"></a>宝塔部署go项目</h2><p>首先还是释放端口的访问权限，阿里云和宝塔的权限</p>
<p>网站那一栏有go项目的新建，新建一个go项目，将本地的go项目的执行文件上传，这种方式暂时没有效果。采用使用命令行运行的方法。</p>
<h3 id="添加go环境"><a href="#添加go环境" class="headerlink" title="添加go环境"></a>添加go环境</h3><p>安装包下载</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">wget https://studygolang.com/dl/golang/go1.19.4.linux-amd64.tar.gz</span><br></pre></td></tr></tbody></table></figure>

<p>解压gz包</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gzip -d go1.19.4.linux-amd64.tar.gz</span><br></pre></td></tr></tbody></table></figure>

<p>解压tar包</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">tar -xvf go1.19.4.linux-amd64.tar</span><br></pre></td></tr></tbody></table></figure>

<p>配置go的环境变量</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line">文件的最后加入</span><br><span class="line">export GOPATH=/root/gopath   你的工作目录（在这里创建.go文件）</span><br><span class="line">export GOROOT=/root/go     go的安装目录</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br><span class="line">:wq</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></tbody></table></figure>

<p>将本地的gin项目文件夹导入到服务器上src目录下，cd进car_sales，运行go build mian.go，由于没有gin环境，他得先下载，云服务器访问github真的慢昂。这样我们就要在windows中交叉编译出Linux下的可执行文件。</p>
<h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><p>在windows系统的命令行下输入</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">set GO_ENABLED=0</span><br><span class="line">set GOOS=linux</span><br><span class="line">set GOARCH=amd64</span><br><span class="line">go build main.go</span><br></pre></td></tr></tbody></table></figure>

<p>编译linux系统下的可执行文件<code>main</code>，上传到tmp目录中</p>
<h3 id="运行执行文件"><a href="#运行执行文件" class="headerlink" title="运行执行文件"></a>运行执行文件</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">如果要修改权限</span><br><span class="line">chmod +x main</span><br><span class="line">之后运行</span><br><span class="line">./main</span><br></pre></td></tr></tbody></table></figure>

<p>这样就运行起来了，记得放开阿里云和宝塔的端口</p>
<h3 id="持久运行执行文件"><a href="#持久运行执行文件" class="headerlink" title="持久运行执行文件"></a>持久运行执行文件</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">nohup ./main &amp; // 后台运行</span><br><span class="line">netstat -lntp // 查看端口的监听情况</span><br></pre></td></tr></tbody></table></figure>

<p><code>tcp6	0	0 :::8080	:::*	LISTEN	54288/./main</code></p>
<h3 id="停止进程"><a href="#停止进程" class="headerlink" title="停止进程"></a>停止进程</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kill 54288 // 如果想停掉的话，直接杀掉这个进程即可</span><br></pre></td></tr></tbody></table></figure>

<h3 id="如何查看打印的日志"><a href="#如何查看打印的日志" class="headerlink" title="如何查看打印的日志"></a>如何查看打印的日志</h3>]]></content>
      <categories>
        <category>技术</category>
        <category>部署</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>配置</tag>
        <tag>云服务器</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>2024年九月推免面试汇总</title>
    <url>/posts/1d5f4f02.html</url>
    <content><![CDATA[<h2 id="本地知识库问答应用"><a href="#本地知识库问答应用" class="headerlink" title="本地知识库问答应用"></a>本地知识库问答应用</h2><h3 id="核心功能介绍"><a href="#核心功能介绍" class="headerlink" title="核心功能介绍"></a>核心功能介绍</h3><h4 id="个人AI助手"><a href="#个人AI助手" class="headerlink" title="个人AI助手"></a>个人AI助手</h4><p>将智能对话系统和传统知识库相耦合，使用户不仅可以询问知识库内相关内容，还可以询问知识库以外的内容。</p>
<h4 id="智能问答模块"><a href="#智能问答模块" class="headerlink" title="智能问答模块"></a>智能问答模块</h4><p>基于LLM大语言模型，在海量的知识库文件中挖掘信息，实现知识理解，推理与分析，根据挖掘的有效知识信息，智能回答用户提出的问题，并给出参考文件。</p>
<h4 id="对象存储模块"><a href="#对象存储模块" class="headerlink" title="对象存储模块"></a>对象存储模块</h4><p>利用对象存储技术的可扩展性强，可靠性高，采用全局唯一标识符访问数据，包含基本的文件管理，文件上传，文件删除功能。</p>
<h4 id="知识库管理模块"><a href="#知识库管理模块" class="headerlink" title="知识库管理模块"></a>知识库管理模块</h4><p>单独设立个人空间，包含新增知识库，删除知识库，修改知识库，知识库成员新增和踢出等知识库管理功能，同时还可以变更知识库访问权限。</p>
<h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><blockquote>
<p>一套互联网应用程序的API设计理论</p>
</blockquote>
<p><strong>API</strong>是应用程序编程接口，使得一个软件程序能够向另一个软件程序传输数据，API调用就是触发使用API。</p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>通信协议总是使用HTTPS</p>
<h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>应该尽量将API部署在专用域名之下，如果确定API很简单，不会有进一步扩展，可以考虑放在主域名之下</p>
<h4 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h4><p>GET, POST, PUT, PATCH, DELETE等</p>
<h4 id="状态码等"><a href="#状态码等" class="headerlink" title="状态码等"></a>状态码等</h4><ol>
<li>200，成功返回数据</li>
<li>400，用户发出的请求有误</li>
<li>500，服务器发生错误，用户无法判断发出的请求是否成功</li>
</ol>
<h3 id="FastAPI"><a href="#FastAPI" class="headerlink" title="FastAPI"></a>FastAPI</h3><p>FasAPI是一个现代，快速，高性能的Web框架，用户构建基于Python的API</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>快速高效</li>
<li>自动文档生成</li>
<li>数据验证和转换</li>
<li>类型提示</li>
<li>安全认证</li>
<li>强大的生态系统</li>
</ul>
<h3 id="LangChain"><a href="#LangChain" class="headerlink" title="LangChain"></a>LangChain</h3><p>开源编排框架，用于使用大语言模型开发应用程序，可以简化LLM驱动型应用程序的开发过程。</p>
<p>核心是一个开发环境，通过使用抽象方法简化LLM应用程序的编程，模块化将充当AI程序的构建块，将它们连接在一起来创建应用程序。</p>
<h4 id="Langchain-组件"><a href="#Langchain-组件" class="headerlink" title="Langchain 组件"></a><strong>Langchain 组件</strong></h4><p>基于以下几个核心的 langchain 组件构建本地知识库</p>
<ul>
<li><p>Embedding（嵌入模型）</p>
<p>为了捕捉文本的语义和语法信息，以便在后续的任务中能够更好地使用</p>
</li>
<li><p>Vector Store（向量数据库）</p>
</li>
<li><p>Document Splitter（文档切割）</p>
</li>
<li><p>LLM （大模型）</p>
</li>
</ul>
<h3 id="LLM"><a href="#LLM" class="headerlink" title="LLM"></a>LLM</h3><p>大语言模型是针对语言的大模型，大模型是一种深度学习模型，包含了“预训练”和“大模型”两层含义，模型在大规模数据集上完成了预训练后无需微调或者仅需少量的微调，就能直接支持各类应用。</p>
<p>通过学习大量的文本数据，<strong>来预测下一个词或者下一段话的可能性</strong>，从而使计算机能够更好地理解和生成人类语言。生成式预训练Transformer（GPT），可以自动生成具有语言上下文和逻辑关系的连贯文本，这些文本在预训练时并没有直接指定，而是通过模型自身的学习和推理得到的。</p>
<p>LLM能够理解上下文信息，处理多种自然语言处理的任务，比如：文本生成，翻译，摘要，情感分析，无需给每个任务单独训练一个模型。</p>
<h4 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h4><p>一个预先设定的条件，可以限制模型的自由发散，而是围绕提示内容进行展开。</p>
<h3 id="如何进行知识挖掘"><a href="#如何进行知识挖掘" class="headerlink" title="如何进行知识挖掘"></a>如何进行知识挖掘</h3><ol>
<li>加载用户上传到知识库中的文件</li>
<li>预处理与文本切分</li>
</ol>
<p>将一个文档转成向量数据库中的数据往往可以分成两个大的步骤，<strong>tokenizer****和</strong>embedding**</p>
<ul>
<li>tokenizer负责将文本拆分成次元</li>
<li>embedding将词元转换成词向量的表示</li>
</ul>
<ol>
<li>向量化与向量存储</li>
<li>用户提问，将用户的提问向量化，在数据库中检索相似的几条向量，即匹配文本相似性和语义检索，将检索出来的结果用于NLP问答。将用户的提问向量和检索出的向量数据发送给大语言模型处理，生成用户能够理解的语言。</li>
</ol>
<h3 id="向量数据库"><a href="#向量数据库" class="headerlink" title="向量数据库"></a>向量数据库</h3><blockquote>
<p>向量数据存储在专门设计的向量数据库中，可以通过最近邻搜索算法找到与查询向量相似的向量。</p>
</blockquote>
<p>如果要表达一个具体事物的特征，所用的向量维度还是非常大的，在检索的时候非常消耗性能，使用一些算法进行优化， 比如K-means聚类算法，用分类的质心向量来代替每一个向量，以减少存储的空间。</p>
<p>每一个事物可以是具象的，也可以是抽象的，最终都会在一个高维的特征空间中对应着一个坐标点。</p>
<h4 id="向量数据库对LLM处理的作用"><a href="#向量数据库对LLM处理的作用" class="headerlink" title="向量数据库对LLM处理的作用"></a>向量数据库对LLM处理的作用</h4><p>如果拿着当前文本的向量数据去寻找之前问答过程中最相似的问答文本，将他们作为上下文输送给大模型，能够极大提高大模型的输出准确性和输出效率。能够生成具有上下文意识和更加满足用户需求，更加专业的回答。</p>
<ol>
<li>提高LLM的性能：通过使用向量数据库，LLM可以实现对文本数据的快速检索和分析，从而提高其处理速度和准确性。这对于需要处理大规模数据的LLM来说尤为重要。</li>
<li>降低存储成本：向量数据库采用高效的存储结构，能够实现对向量数据的压缩和去重，从而降低存储成本。这对于需要长期保存大量数据的LLM来说非常有利。</li>
<li>支持多模态数据处理：除了文本数据外，向量数据库还可以处理图像、音频等多模态数据。这使得LLM能够实现对多种类型数据的综合处理，进一步拓展其应用场景。</li>
</ol>
<p>同时解决LLM的上下文限制问题（token），如果你的知识库内容长度超出了限制，我们就不能直接让 ChatGPT 对其进行总结并回答问题。通过 Embedding 技术，我们可以使用语义搜索来快速找到相关的文档，然后只将相关的文档内容注入到大模型的上下文窗口中，让模型来生成特定问题的答案，从而解决大模型的限制问题。这种做法比 Fine tuning 速度更快，而且不需要训练，使用上也更灵活。</p>
<h4 id="最近邻问题"><a href="#最近邻问题" class="headerlink" title="最近邻问题"></a>最近邻问题</h4><blockquote>
<p>向量数据的一个主要的应用场景就是给定一个查询向量，然后从众多向量中找到最为相似的一些。</p>
</blockquote>
<h4 id="最近邻搜索算法"><a href="#最近邻搜索算法" class="headerlink" title="最近邻搜索算法"></a>最近邻搜索算法</h4><h5 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h5><p>两个向量的夹角，或者计算两个向量之间的欧氏距离。</p>
<h5 id="K-means聚类算法（近似最近邻）"><a href="#K-means聚类算法（近似最近邻）" class="headerlink" title="K-means聚类算法（近似最近邻）"></a>K-means聚类算法（近似最近邻）</h5><ol>
<li>先选定一个想要分类的数量，随机生成四个点，称为聚类中心点，这些向量与哪个中心点最近就被分为哪一类</li>
<li>用当前被分为一类的向量计算出一个平均向量点，把对应的中心点的位置更新为这个平均向量点</li>
<li>重新判断每一个向量与哪个中心最近，重新分类</li>
<li>重复步骤二，三</li>
</ol>
<p>如此反复，这个不断迭代的过程就被称为训练，最后这些中心点会趋于稳定或者说收敛，搜索的时候，先看查询向量属于哪个聚类，再在聚类中所搜最相似的向量。</p>
<h4 id="向量数据库和传统数据库有什么区别"><a href="#向量数据库和传统数据库有什么区别" class="headerlink" title="向量数据库和传统数据库有什么区别"></a>向量数据库和传统数据库有什么区别</h4><p>传统数据库主要是针对结构化数据的存储和查询，而向量数据库则是针对非结构化数据（例如图像、文本等）的存储和查询。 向量数据库的优势在于它可以通过向量相似度快速和高效地查询相似的数据，适用于图像搜索、语音识别、推荐系统等场景。</p>
<h4 id="什么是结构化的数据"><a href="#什么是结构化的数据" class="headerlink" title="什么是结构化的数据"></a>什么是结构化的数据</h4><p>结构化数据就是具有预定义的结构或者预定义的格式的数据，例如存储的日期是有格式的，性别是有格式的</p>
<p>非结构化数据缺乏定义，各种各样的格式，比如图像，文本等</p>
<h4 id="向量数据库给LLM传输的是什么类型的数据"><a href="#向量数据库给LLM传输的是什么类型的数据" class="headerlink" title="向量数据库给LLM传输的是什么类型的数据"></a>向量数据库给LLM传输的是什么类型的数据</h4><p>在构建知识库应用时，向量数据库向LLM（大型语言模型）传输的数据通常是高维数值向量。这些向量是通过将原始数据（如文本、图像、音频等）经过特定的算法（如词嵌入Word Embeddings、BERT或其他深度学习模型）转换得到的，它们能够捕捉数据的关键特征和语义信息。</p>
<h3 id="AIGC"><a href="#AIGC" class="headerlink" title="AIGC"></a>AIGC</h3><blockquote>
<p>人工智能生成内容</p>
</blockquote>
<p>ChatGPT是AIGC在聊天对话场景的一个具体应用。</p>
<h3 id="自然语言处理（NLP）"><a href="#自然语言处理（NLP）" class="headerlink" title="自然语言处理（NLP）"></a>自然语言处理（NLP）</h3><p>理解用户的自然语言</p>
<h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><p>一种深度学习模型，在自然语言处理领域特别流行，能够更加高效和有效地处理序列数据。transformer完全基于注意力机制，没有使用循环神经网络（RNN）或者卷积神经网络（CNN）。核心是：</p>
<ul>
<li>自注意力机制：并行处理所有位置的数据，提高计算效率</li>
<li>多头注意力：捕获序列中多种不同级别的依赖关系</li>
<li>位置编码：提供单词在序列中位置的信息</li>
</ul>
<h3 id="RNN模型"><a href="#RNN模型" class="headerlink" title="RNN模型"></a>RNN模型</h3><p>循环神经网络（recurrent neural network，RNN）是一种具有反馈结构的神经网络，其输出不但与当前输入和网络的权值有关，而且也与之前网络的输入有关；RNN通过添加跨越时间点的自连接隐藏层，对时间进行建模；换句话说，隐藏层的反馈，不仅仅进入输出端，而且还进入了下一时间的隐藏层。 一般的RNNs有多个FNN横向连接而成，其中中间有个rnn-cell, 存储的是前面序列的隐含状态s。 分解开来的话， 就相当于三层，第一层是输入x到rnn-cell的连接，第二层是rnn-cell,得到的是隐藏状态s，第三层是rnn-cell到输出o的连接层。</p>
<ul>
<li>输入层</li>
<li>隐藏层</li>
<li>输出层</li>
</ul>
<h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>基于对象的存储，与其他计算机数据存储架构不同的是，它管理的是对象，而不是文件系统和数据块，一个“对象”包括数据本身，一些元数据和一个唯一标识符。这些数据可以通过API或者http/https进行即刻访问。通过这种方式，对象存储保障了数据的安全。如果需要这些数据还可以复制到多个数据中心。</p>
<p>与文件类型和块类型存储不同，对象存储支持有助于描述文件的全面元数据。元数据可帮助您理解和分析大型文件，而无需直接处理文件中包含的内容。</p>
<h4 id="对象存储的好处"><a href="#对象存储的好处" class="headerlink" title="对象存储的好处"></a>对象存储的好处</h4><ul>
<li><strong>更易于访问</strong>：对象存储由元数据驱动，通过对每个数据的这种分类级别，您可以轻松地对文件进行排序和搜索。</li>
<li><strong>无限存储</strong>：对象存储不依赖于硬件（不限于单个服务器或NAS）</li>
<li><strong>降低成本</strong>：由于对象存储的横向扩展性质，存储所有数据的成本更低。</li>
<li><strong>资源优化</strong>：由于对象存储没有归档层次结构，并且元数据完全可自定义，因此与文件或块存储相比，硬件限制要少得多。</li>
</ul>
<h4 id="对象存储的元数据"><a href="#对象存储的元数据" class="headerlink" title="对象存储的元数据"></a>对象存储的元数据</h4><p>对于元数据为何产生影响的实际例子，我们可以看看医院如何存储和处理患者的X射线图像。 X射线文件将具有与其关联的有限元数据，例如创建日期，所有者，位置和大小。另一方面，X射线对象可以具有丰富的元数据信息。</p>
<p>元数据可以包括患者姓名，出生日期，受伤细节，身体的哪个区域进行X光检查 - 以及文件所具有的相同标签。这使得医生提取相关信息以供参考非常有用。</p>
<h4 id="对象存储的局限性"><a href="#对象存储的局限性" class="headerlink" title="对象存储的局限性"></a>对象存储的局限性</h4><ul>
<li>与Block Storage相比，访问速度更慢</li>
<li>文件无法编辑，需要重写/重新上传整个内容</li>
<li>难以限制/定义存储位置</li>
</ul>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="燃烧若干根不均匀的绳，每条绳子燃尽是1小时，如何计时1小时15分？"><a href="#燃烧若干根不均匀的绳，每条绳子燃尽是1小时，如何计时1小时15分？" class="headerlink" title="燃烧若干根不均匀的绳，每条绳子燃尽是1小时，如何计时1小时15分？"></a>燃烧若干根不均匀的绳，每条绳子燃尽是1小时，如何计时1小时15分？</h3><p>把第一根绳子两头同时点燃,同时把第二根绳子点燃一头,当第一根绳子烧完时,时间为半个小时,这时把第二根绳子的另一头也点燃,开始计时,当第二根绳子烧完时,停止计时,那么这段时间就是15分钟。也就是说，只需要3根绳子就可以计时一个小时15分钟。</p>
<h3 id="给你一个6L和5L的杯子和一个无限容量的容器，如何量出4L的水？"><a href="#给你一个6L和5L的杯子和一个无限容量的容器，如何量出4L的水？" class="headerlink" title="给你一个6L和5L的杯子和一个无限容量的容器，如何量出4L的水？"></a>给你一个6L和5L的杯子和一个无限容量的容器，如何量出4L的水？</h3><p>先把6L桶装满，再向5L桶里倒水。5L桶满，则把它的水倒掉，6L桶没水，则装满水，不断循环这个过程，直到找到满足要求的水。</p>
<h3 id="exe文件在Linux系统下为什么不能运行"><a href="#exe文件在Linux系统下为什么不能运行" class="headerlink" title=".exe文件在Linux系统下为什么不能运行"></a>.exe文件在Linux系统下为什么不能运行</h3><p>编译链接的时候用到的库不一样</p>
<h3 id="编译型语言和解释型语言的区别"><a href="#编译型语言和解释型语言的区别" class="headerlink" title="编译型语言和解释型语言的区别"></a>编译型语言和解释型语言的区别</h3><p>源代码一次性转换成二进制指令，生成一个可执行程序，即编译型语言</p>
<p>一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序</p>
<h3 id="深度学习和机器学习"><a href="#深度学习和机器学习" class="headerlink" title="深度学习和机器学习"></a>深度学习和机器学习</h3><p>深度学习（也称为深度神经学习或深度神经网络）会让计算机通过观察，学习、模仿人类获取知识的方式。 </p>
<p>人脑中有很多相互连接的神经元，当大脑处理信息（或数据）时，这些神经元就负责传递信息。神经元之间通过电信号和化学物质相互作用，并在大脑的不同区域之间传递信息。 </p>
<p>人工神经网络（ANN）是模仿这种生物学现象而构成的，是深度学习所依托的底层架构，然而，ANN 使用的是人工神经元而不是生物神经元，这些人工神经元是由称为节点的软件模块构成的。这些节点使用数值计算（而不是大脑中的化学信号）来进行通信和传递信息。模拟神经网络（SNN）通过聚类数据点进行预测的方式来处理数据。</p>
<p>为了便于理解，我们可以将深度学习想象为某种流程图，它从输入层开始，到输出层结束。夹在这两层之间的是“隐藏层”，负责加工处理不同级别的信息，并随着不断接收新数据而调整和适应它们的行为。深层学习模型可以拥有数百个隐藏层，每个隐藏层都在数据集中发现关系和模式方面发挥作用。 </p>
<p>深度学习是机器学习的一种特殊形式，两者的区别在于其所处理的数据类型和学习方法。</p>
<p>经典的机器学习算法需要人工干预，先对数据集进行预处理，然后再将其导入模型。这意味着人要在模型的输入数据中定义和标记特定特征，并组织到表格中，然后再将其导入机器学习模型。相反，深度学习算法不需要这种级别的预处理，并且能够理解非结构化数据，例如文本文档、像素数据图像或音频数据文件。 </p>
<p>在有大量数据，却缺乏相关主题的背景知识或手头有复杂耗时的任务的情况下，深度学习可能优于经典机器学习。</p>
<ol>
<li>机器学习只关注解决现实问题。它还需要人工智能的一些想法。机器学习通过旨在模仿人类决策能力的神经网络。ML工具和技术是两个主要的仅关注深度学习的窄子集。我们需要应用它来解决任何需要思考的问题 —— 人类的或人为的。任何深度神经网络都将包含以下三层：输入层、隐藏层、输出层</li>
<li>我们用机器算法来解析数据，学习数据，并从中做出理智的判定。根本上讲，深度学习用于创建可自我学习和可理智判定的人工“神经网络”。我们可以说深度学习是机器学习的子领域。</li>
</ol>
<h3 id="介绍一下go语言的特征"><a href="#介绍一下go语言的特征" class="headerlink" title="介绍一下go语言的特征"></a>介绍一下go语言的特征</h3><h4 id="go语言出现的背景"><a href="#go语言出现的背景" class="headerlink" title="go语言出现的背景"></a>go语言出现的背景</h4><ul>
<li>Go希望成为互联网时代的C语言。多数系统级语言（包括Java和C#）的根本编程哲学来源于C++，将C++的面向对象进一步发扬光大。但是Go语言的设计者却有不同的看法，他们认为值得学习的是C语言。C语言经久不衰的根源是它足够简单。因此，Go语言也是足够简单。</li>
<li>所以，他们当时设计Go的目标是为了消除各种缓慢和笨重、改进各种低效和扩展性。Go是由那些开发大型系统的人设计的，同时也是为了这些人服务的；它是为了解决工程上的问题，不是为了研究语言设计；它还是为了让我们的编程变得更舒适和方便。</li>
<li>但是结合Google当时内部的一些现实情况，如很多工程师都是C系的，所以新设计的语言一定要易学习，最好是类似C的语言；20年没有出新的语言了，所以新设计的语言必须是现代化的（例如内置GC）等情况。最后根据实战经验，他们向着目标设计了Go这个语言。</li>
</ul>
<h4 id="go语言的特色"><a href="#go语言的特色" class="headerlink" title="go语言的特色"></a>go语言的特色</h4><ul>
<li>没有继承多态的面向对象</li>
<li>强一致类型</li>
<li>interface不需要显式声明(Duck Typing)</li>
<li>没有异常处理(Error is value)</li>
<li>基于首字母的可访问特性</li>
<li>不用的import或者变量引起编译错误</li>
<li>完整而卓越的标准库包</li>
<li>Go内置runtime（作用是性能监控、垃圾回收等）</li>
</ul>
<h4 id="go语言的优势"><a href="#go语言的优势" class="headerlink" title="go语言的优势"></a>go语言的优势</h4><p>1、学习曲线容易</p>
<p> Go语言语法简单，包含了类C语法。因为Go语言容易学习，所以一个普通的大学生花几个星期就能写出来可以上手的、高性能的应用。在国内大家都追求快，这也是为什么国内Go流行的原因之一。</p>
<p>2、效率：快速的编译时间，开发效率和运行效率高</p>
<p> 开发过程中相较于 Java 和 C++呆滞的编译速度，Go 的快速编译时间是一个主要的效率优势。Go拥有接近C的运行效率和接近PHP的开发效率。</p>
<p>C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。</p>
<p>3、出身名门、血统纯正</p>
<p> 之所以说Go出身名门，从Go语言的创造者就可见端倪，Go语言绝对血统纯正。其次Go语言出自Google公司，Google在业界的知名度和实力自然不用多说。Google公司聚集了一批牛人，在各种编程语言称雄争霸的局面下推出新的编程语言，自然有它的战略考虑。而且从Go语言的发展态势来看，Google对它这个新的宠儿还是很看重的，Go自然有一个良好的发展前途。</p>
<p>4、自由高效：组合的思想、无侵入式的接口</p>
<p> Go语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go语言支持当前所有的编程范式，包括过程式编程、面向对象编程、面向接口编程、函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。</p>
<p>5、强大的标准库</p>
<p> 这包括互联网应用、系统编程和网络编程。Go里面的标准库基本上已经是非常稳定了，特别是我这里提到的三个，网络层、系统层的库非常实用。<strong>Go 语言的 lib 库麻雀虽小五脏俱全。</strong>Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。</p>
<p>6、部署方便：二进制文件，Copy部署</p>
<p> 这一点是很多人选择Go的最大理由，因为部署太方便了，所以现在也有很多人用Go开发运维程序。</p>
<p>7、简单的并发</p>
<p><strong>并行和异步编程几乎无痛点。</strong>Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的编程者来说，完全就是让人眼前一亮的感觉。Go 是一种非常高效的语言，高度支持并发性。Go是为大数据、微服务、并发而生的一种编程语言。</p>
<ul>
<li>Go 作为一门语言致力于使事情简单化。它并未引入很多新概念，而是聚焦于打造一门简单的语言，它使用起来异常快速并且简单。其唯一的创新之处是 goroutines 和通道。Goroutines 是 Go 面向线程的轻量级方法，而通道是 goroutines 之间通信的优先方式。</li>
<li>创建 Goroutines 的成本很低，只需几千个字节的额外内存，正由于此，才使得同时运行数百个甚至数千个 goroutines 成为可能。可以借助通道实现 goroutines 之间的通信。Goroutines 以及基于通道的并发性方法使其非常容易使用所有可用的 CPU 内核，并处理并发的 IO。相较于 Python/Java，在一个 goroutine 上运行一个函数需要最小的代码。</li>
</ul>
<p>8、稳定性</p>
<p> Go拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么Go相比于其他程序会更稳定呢？这是因为Go提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如go tool、gofmt、go test。</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="计算机之间的通信"><a href="#计算机之间的通信" class="headerlink" title="计算机之间的通信"></a>计算机之间的通信</h3><p>计算机之间的通信是两个主机进程之间的通信</p>
<h3 id="计算机网络分层"><a href="#计算机网络分层" class="headerlink" title="计算机网络分层"></a>计算机网络分层</h3><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><ul>
<li>应用层：为计算机用户提供服务</li>
<li>表示层：数据处理</li>
<li>会话层：管理应用程序之间的会话</li>
<li>传输层：端到端的进程通信</li>
<li>网络层：路由和寻址</li>
<li>数据链路层：帧编码喝误差纠正控制</li>
<li>物理层：透明地传送比特流</li>
</ul>
<h4 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h4><ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ul>
<h4 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h4><table>
<thead>
<tr>
<th>层次</th>
<th>功能</th>
<th>协议</th>
<th>交互的数据单元</th>
<th>中间设备</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>为最终用户提供特定的网络应用</td>
<td>DNS,HTTP,HTTPS,SMTP</td>
<td>报文</td>
<td>网关</td>
</tr>
<tr>
<td>运输层</td>
<td>提供端到端的进程通信</td>
<td>TCP,UDP</td>
<td>报文段（TCP），用户数据报（UDP）</td>
<td>网关</td>
</tr>
<tr>
<td>网络层</td>
<td>在任意主机之间进行通信，任意节点之间尽力而为地传输分组</td>
<td>IP</td>
<td>IP数据报（数据报）</td>
<td>路由器</td>
</tr>
<tr>
<td>数据链路层</td>
<td>相邻节点之间无差错地传输数据帧</td>
<td>PPP,以太网</td>
<td>数据帧</td>
<td>网桥，交换机</td>
</tr>
<tr>
<td>物理层</td>
<td>传播比特流</td>
<td></td>
<td>比特</td>
<td>转发器，集线器，中继器，放大器</td>
</tr>
</tbody></table>
<h3 id="为什么网络要分层"><a href="#为什么网络要分层" class="headerlink" title="为什么网络要分层"></a>为什么网络要分层</h3><ol>
<li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li>
<li><strong>提高了灵活性和可替换性</strong>：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。并且，每一层都可以根据需要进行修改或替换，而不会影响到整个网络的结构。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li>
<li><strong>大问题化小</strong>：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 **这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</li>
</ol>
<blockquote>
<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p>
</blockquote>
<h3 id="常见的网络协议"><a href="#常见的网络协议" class="headerlink" title="常见的网络协议"></a>常见的网络协议</h3><ul>
<li><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）</strong>：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li>
<li><strong>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）</strong>：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li>
<li><strong>POP3/IMAP（邮件接收协议）</strong>：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li>
<li><strong>FTP（File Transfer Protocol，文件传输协议）</strong> : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。</li>
<li><strong>Telnet（远程登陆协议）</strong>：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li>
<li><strong>SSH（Secure Shell Protocol，安全的网络传输协议）</strong>：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务</li>
<li><strong>RTP（Real-time Transport Protocol，实时传输协议）</strong>：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</li>
<li><strong>DNS（Domain Name System，域名管理系统）</strong>: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。</li>
</ul>
<h3 id="信息交互的方式"><a href="#信息交互的方式" class="headerlink" title="信息交互的方式"></a>信息交互的方式</h3><ol>
<li><p>单工通信</p>
<p>只有一个方向的通信没有反方向的交互</p>
</li>
<li><p>半双工通信</p>
<p>通信的双方都能发送信息，但是不能同时发送信息</p>
</li>
<li><p>全双工通信</p>
<p>通信的双方可以同时发送和接收信息</p>
</li>
</ol>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><blockquote>
<p>隐藏局域网之间的差异，逻辑上编一个地址，给连接到互联网上的每一台主机（或者路由器）的每一个接口，分配一个在全世界范围内唯一的32位的标识符）</p>
<p>格式：网络号+主机号</p>
<p>IPv4的地址空间2^32</p>
<p>点分十进制</p>
<p>IPv6的地址空间2^128</p>
<p>点分十六进制</p>
</blockquote>
<h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><p>TCP是面向连接的，可靠的，基于字节流的传输层通信协议</p>
<ol>
<li>面向连接：一定是一对一建立连接才能通信，不像UDP可以一对多</li>
<li>可靠的：保证报文一定能够到达接收端</li>
<li>字节流</li>
</ol>
<h3 id="TCP建立的三次握手"><a href="#TCP建立的三次握手" class="headerlink" title="TCP建立的三次握手"></a>TCP建立的三次握手</h3><ol>
<li>请求方向接收方发送一个建立连接的请求报文。（SYN = 1）</li>
<li>接收方向发送方发送一个对建立连接报文的确认报文。（SYN = 1, ACK = 1）</li>
<li>请求方向接收方发送一个对确认报文的确认报文，建立连接。（SYN = 1）</li>
</ol>
<h3 id="TCP断开连接的四次挥手"><a href="#TCP断开连接的四次挥手" class="headerlink" title="TCP断开连接的四次挥手"></a>TCP断开连接的四次挥手</h3><ol>
<li>主动关闭方告诉对方自己没有数据发送，请求关闭连接。</li>
<li>被动关闭方向主动关闭方发送一个对关闭连接请求的确认报文。</li>
<li>被动关闭方发送一个准备关闭连接的报文。</li>
<li>主动关闭方发送一个对被动关闭方发送的关闭连接的请求的确认报文，之后双方都进入CLOSED状态。</li>
</ol>
<h3 id="UDP和TCP"><a href="#UDP和TCP" class="headerlink" title="UDP和TCP"></a>UDP和TCP</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>都是传输层的协议</p>
<ul>
<li>传输控制协议(TCP)：面向连接，可靠</li>
<li>用户数据报协议(UDP)：无连接，尽力而为，不保证可靠</li>
</ul>
<h4 id="面向"><a href="#面向" class="headerlink" title="面向"></a>面向</h4><ul>
<li>UDP是面向报文的，对于应用层传输下来的报文，加上一个首部就交付给网络层。对报文既不拆分也不合并，保留这些报文的边界。一次发送一个报文。UDP向应用层交付的时候也是去掉一个首部，将一个完整的报文交给应用层。</li>
<li>TCP是面向字节流的，无论是发送还是接收，都是把数据块视为一个无边界的字节流，按顺序一个字节一个字节地发送或者接收。</li>
</ul>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>UDP是无连接的，TCP是面向连接的</p>
<h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>UDP是不可靠的传输协议，他只是尽力而为地传输。没有内置的重传机制，流量控制和拥塞控制。TCP是可靠的传输协议，停等协议，回退n帧，选择重发，有流量控制和拥塞控制。</p>
<h4 id="上层协议"><a href="#上层协议" class="headerlink" title="上层协议"></a>上层协议</h4><p>DNS的下层协议是UDP，HTTP，HTTPS，FTP的下层协议是TCP</p>
<h3 id="网络层有哪些协议"><a href="#网络层有哪些协议" class="headerlink" title="网络层有哪些协议"></a>网络层有哪些协议</h3><ul>
<li><strong>IP（Internet Protocol，网际协议）</strong>：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li>
<li><strong>ARP（Address Resolution Protocol，地址解析协议）</strong>：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li>
<li><strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。</li>
<li><strong>NAT（Network Address Translation，网络地址转换协议）</strong>：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</li>
<li><strong>OSPF（Open Shortest Path First，开放式最短路径优先）</strong>：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</li>
<li><strong>RIP(Routing Information Protocol，路由信息协议）</strong>：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li>
<li><strong>BGP（Border Gateway Protocol，边界网关协议）</strong>：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。</li>
</ul>
<h3 id="从输入URL到页面展示发生了什么"><a href="#从输入URL到页面展示发生了什么" class="headerlink" title="从输入URL到页面展示发生了什么"></a>从输入URL到页面展示发生了什么</h3><ol>
<li>在浏览器中输入指定网页的 URL。</li>
<li>浏览器通过 DNS 协议，获取域名对应的 IP 地址。</li>
<li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li>
<li>浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li>
<li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li>
<li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li>
<li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li>
</ol>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>互联网上唯一的进程编号</p>
<h3 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h3><p>互联网使用的命名系统，便于人们容易理解的机器名字转换为IP地址，解决域名和IP地址的映射问题</p>
<h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><p>HTTP最初的目的是为了提供一种发布和接收HTML页面的方法</p>
<p>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。</p>
<ol>
<li><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li>
<li><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
<li><strong>SEO（搜索引擎优化）</strong>：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</li>
</ol>
<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><p>GET 和 POST 是 HTTP 协议中两种常用的请求方法，它们在不同的场景和目的下有不同的特点和用法。一般来说，可以从以下几个方面来区分二者（重点搞清两者在语义上的区别即可）：</p>
<ul>
<li>语义（主要区别）：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。</li>
<li>幂等：GET 请求是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。</li>
<li>格式：GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中，可以有多种编码格式，如 application/x-www-form-urlencoded、multipart/form-data、application/json 等。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。不过，实际上 GET 请求也可以用 body 传输数据，只是并不推荐这样做，因为这样可能会导致一些兼容性或者语义上的问题。</li>
<li>缓存：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。</li>
<li>安全性：GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 HTTP 协议本身是明文传输的，必须使用 HTTPS 协议来加密传输数据。另外，GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中。</li>
</ul>
<h3 id="WebSocket和HTTP有什么区别"><a href="#WebSocket和HTTP有什么区别" class="headerlink" title="WebSocket和HTTP有什么区别"></a>WebSocket和HTTP有什么区别</h3><p>WebSocket 和 HTTP 两者都是基于 TCP 的应用层协议，都可以在网络中传输数据。</p>
<p>下面是二者的主要区别：</p>
<ul>
<li>WebSocket 是一种双向实时通信协议，而 HTTP 是一种单向通信协议。并且，HTTP 协议下的通信只能由客户端发起，服务器无法主动通知客户端。</li>
<li>WebSocket 使用 ws:// 或 wss://（使用 SSL/TLS 加密后的协议，类似于 HTTP 和 HTTPS 的关系） 作为协议前缀，HTTP 使用 http:// 或 https:// 作为协议前缀。</li>
<li>WebSocket 可以支持扩展，用户可以扩展协议，实现部分自定义的子协议，如支持压缩、加密等。</li>
<li>WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小，而 HTTP 通信每次都要携带完整的头部，网络开销较大（HTTP/2.0 使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）。</li>
</ul>
<h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><h3 id="B，KB，MB，GB，TB"><a href="#B，KB，MB，GB，TB" class="headerlink" title="B，KB，MB，GB，TB"></a>B，KB，MB，GB，TB</h3><ul>
<li><strong>B</strong> 代表字节（Byte），是最小的数据单位，1个字节等于8位（bit）。</li>
<li><strong>KB</strong> 代表千字节（Kilobyte），1KB 等于 1024 字节（2^10 字节）。</li>
<li><strong>MB</strong> 代表兆字节（Megabyte），1MB 等于 1024KB，也就是 1024 * 1024 字节，即 2^20 字节。</li>
<li><strong>GB</strong> 代表吉字节（Gigabyte），1GB 等于 1024MB，也就是 1024 * 1024KB，即 1024210242 字节，等于 230230 字节。</li>
<li><strong>TB</strong> 代表太字节（Terabyte），1TB 等于 1024GB，也就是 1024 * 1024MB，即 1024310243 字节，等于 240240 字节。</li>
</ul>
<h3 id="冯诺依曼体系结构和机器的特点"><a href="#冯诺依曼体系结构和机器的特点" class="headerlink" title="冯诺依曼体系结构和机器的特点"></a>冯诺依曼体系结构和机器的特点</h3><p>五大组成，输入设备，运算器，输出设备，存储器和控制器</p>
<p>特点：</p>
<ul>
<li>指令和数据以二进制码表示</li>
<li>同等地位</li>
<li>指令由操作码和地址码组成</li>
<li>指令在存储器中顺序存放</li>
<li>运算器为中心</li>
</ul>
<h3 id="比特，字，字节"><a href="#比特，字，字节" class="headerlink" title="比特，字，字节"></a>比特，字，字节</h3><p><strong>比特</strong>，表示二进制位</p>
<p><strong>字节</strong>，byte，一个字节等于8个比特</p>
<p><strong>字</strong>，word，计算机进行数据处理时，一次存取，加工和传送的数据长度称为字，一个字通常是由一个或者多个字节构成。计算机的字长决定了其CPU一次操作处理实际位数的多少，由此可见计算机的字长越大，其性能越优越。</p>
<h3 id="RAM-和-ROM和FM"><a href="#RAM-和-ROM和FM" class="headerlink" title="RAM 和 ROM和FM"></a>RAM 和 ROM和FM</h3><p>随机存取存储器RAM，访问某个单元时间和它的物理位置没有关系</p>
<p>RAM包括SRAM用触发器实现，稳定，但元件多，常用cache，DRAM用电容实现，元件少，常用主存</p>
<p>RAM断电后数据丢失</p>
<p>只读存储器ROM，负责把辅存里面的OS调到RAM中，负责存储开机的详细信息</p>
<h3 id="计算机系统由哪两部分组成？性能取决于什么？"><a href="#计算机系统由哪两部分组成？性能取决于什么？" class="headerlink" title="计算机系统由哪两部分组成？性能取决于什么？"></a>计算机系统由哪两部分组成？性能取决于什么？</h3><p>软件和硬件，CPU（运算器，控制器）和内存（存储器），外存（硬盘）</p>
<h3 id="解释下什么是DMA"><a href="#解释下什么是DMA" class="headerlink" title="解释下什么是DMA"></a>解释下什么是DMA</h3><p>以主存为中心，采用硬件手段在主存与I/O设备之间建立直接的数据传送通路，由DMA控制器（DMAC）取得总线控制权，控制主存与I/O设备之间的数据传送，在传送过程中不需要CPU的程序干预的数据传送控制方式。</p>
<h3 id="说下五级流水CPU的各阶段"><a href="#说下五级流水CPU的各阶段" class="headerlink" title="说下五级流水CPU的各阶段"></a>说下五级流水CPU的各阶段</h3><p>取指、译码、执行、访存、写回</p>
<h3 id="执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？"><a href="#执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？" class="headerlink" title="执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？"></a>执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？</h3><p>单周期更快，减少段与段之间的交互开销。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="如何判断一个单链表是否是循环链表（要给出一个比遍历更快的方法）"><a href="#如何判断一个单链表是否是循环链表（要给出一个比遍历更快的方法）" class="headerlink" title="如何判断一个单链表是否是循环链表（要给出一个比遍历更快的方法）"></a>如何判断一个单链表是否是循环链表（要给出一个比遍历更快的方法）</h3><p>快慢指针法：两个指针一个每次前进1步、一个每次前进2步，相遇则循环</p>
<h3 id="介绍下平衡二叉树"><a href="#介绍下平衡二叉树" class="headerlink" title="介绍下平衡二叉树"></a>介绍下平衡二叉树</h3><p>一般是二叉搜索树，任意节点的子树的高度差都小于等于 1</p>
<h3 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h3><ul>
<li>时间复杂度是用于评估执行程序所消耗的时间</li>
<li>空间复杂度是用于评估执行程序所占用的内存空间</li>
</ul>
<h3 id="数据结构、逻辑结构、存储结构"><a href="#数据结构、逻辑结构、存储结构" class="headerlink" title="数据结构、逻辑结构、存储结构"></a>数据结构、逻辑结构、存储结构</h3><ul>
<li>数据结构是计算机存储和组织数据的方式</li>
<li>逻辑结构是指元素之间的逻辑关系，与数据的存储结构无关</li>
<li>存储结构是指元素在计算机中的物理存储方式</li>
</ul>
<h3 id="数据结构的4种逻辑结构"><a href="#数据结构的4种逻辑结构" class="headerlink" title="数据结构的4种逻辑结构"></a>数据结构的4种逻辑结构</h3><ul>
<li>集合结构:数据元素之间同属于一种类型</li>
<li>线性结构:数据元素之间存在一对一的关系</li>
<li>树形结构:数据元素之间存在一对多的关系</li>
<li>图状结构:数据元素之间存在多对多的关系</li>
</ul>
<h3 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h3><ul>
<li><p>数组需要预先从栈中分配固定的长度，不能动态增添数据项，适用于快速查找和修改，较少使用插入和删除</p>
</li>
<li><p>链表可以从堆中动态地分配空间，可以适应动态增添数据项，适用于经常插入和删除</p>
</li>
<li><p>数组支持随机访问，而链表不支持。</p>
</li>
<li><p>数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</p>
</li>
<li><p>数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！</p>
</li>
</ul>
<h3 id="树的存储方式"><a href="#树的存储方式" class="headerlink" title="树的存储方式"></a>树的存储方式</h3><p>双亲表示法:每个节点都有一个指向其父节点的指针<br>孩子表示法:每个节点都有一个指向其第一个孩子节点的指针，如果一个节点有多个孩子，可以使用链表将它们链接起来<br>孩子兄弟表示法:每个节点都有一个指向其第一个孩子节点和其右兄弟节点的指针<br>二叉树线性存储：用一组连续的存储单元来存放二叉树的数据元素</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>完全二叉树<br>除最后一层外，每一层的结点数都达到最大值，最后一层的结点，连续集中在最左边</p>
<p>堆是一颗完全二叉树，任何一个分支节点都不大于（或不小于）其左右结点的值，可以分为大顶堆、小顶堆</p>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>给定n个权值作为n个叶子节点，构造一棵带权路径长度最小的二叉树叫做最优二叉树，即哈夫曼树</p>
<p>结点的带权路径长度:树的根结点到该结点的路径长度和该结点权重的乘积</p>
<p>树的带权路径长度WPL:哈夫曼树中，所有叶子结点的带权路径长度之和</p>
<p>构造方法:每次从森林中取出两个根节点权值最小的子树合并，分别作为新树的左右子树，新树的根节点的权值为左右子树根节点权值之和。重复n-1次这个操作，最后森林中仅剩的一棵树即是哈夫曼树。</p>
<p>应用:哈夫曼编码，减少编码长度</p>
<h3 id="最小生成树两种算法优缺点比较"><a href="#最小生成树两种算法优缺点比较" class="headerlink" title="最小生成树两种算法优缺点比较"></a>最小生成树两种算法优缺点比较</h3><p>最小生成树:寻找原图中包含n个结点边权值和最小的极小联通子图</p>
<p>prim:基于贪心策略，先选择一个初始点加入点集S，然后从点集S中选出弧尾未被标记且边权最小的点继续加入点集S，重复上述操作，直至图中所有的点都被收录到S中，只跟结点数有关，适用于稠密图<br>kruskal:基于贪心策略，贪心地从边集中选出一条最短的边，并使用并查集判断加入边是否会使生成树形成环，如果会，就跳过这条边，直至最后选出n-1条边，只跟边数有关，适用于稀疏图</p>
<h3 id="图的遍历方式"><a href="#图的遍历方式" class="headerlink" title="图的遍历方式"></a>图的遍历方式</h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>首先访问出发点V，然后访问与V邻接的未被访问的点W，直至访问完与V连通的所有结点，若还有结点未被访问，就继续重复上述操作，直至将所有图中所有的点都访问过</p>
<h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>首先访问出发点V，并将V加入到队列中，然后弹出队列中的结点，依次访问与其邻接的且未被访问的点，并加入队列中，重复上述操作，直至将所顶点都访问过</p>
<h3 id="图的存储方式"><a href="#图的存储方式" class="headerlink" title="图的存储方式:"></a>图的存储方式:</h3><p>邻接矩阵 适合表示稠密图，需要较大的存储空间<br>邻接表 适合表示稀疏图，能节省存储空间，能够快速找到它的邻边<br>十字链表 针对有向图<br>邻接多重表 针对无向图</p>
<h3 id="快速排序的流程"><a href="#快速排序的流程" class="headerlink" title="快速排序的流程"></a>快速排序的流程</h3><p>从区间中选定一个主元，将区间划分为左、右两个子区间<br>接着可以使用插空法将大于等于主元的放到右区间，小于等于主元的放到左区间<br>同理，对主元左右两个子区间进行上述操作，直至整体有序</p>
<h3 id="简述背包问题"><a href="#简述背包问题" class="headerlink" title="简述背包问题"></a>简述背包问题</h3><p>背包是一个动态规划问题，问题的描述是给定一组具有重量和价值的物品，在限定重量的背包内如何放下总价值最大的物品。</p>
<p>可以用dp[i][j]代表前i件物品放入j容量的背包中的最大容量，对于这种情况，总共可以有两种选择，一、不放第i件物品，问题就转化为i-1件物品放入j容量的背包的情况即dp[i-1][j]，二、放第i件物品，问题就转化为i-1件物品放入j-第i件物品重量的问题，所以第i层的状态可以由i-1层状态转移过来，所以可以从初试层一直递推下去得到背包问题的最优结果</p>
<h3 id="KMP的主要思想"><a href="#KMP的主要思想" class="headerlink" title="KMP的主要思想"></a>KMP的主要思想</h3><p>建立一个next数组用于存储失配结点的跳转位置，实际上是<strong>存储了模式串的最大相同前后缀长度</strong>，当在某一个位置失配时，可以将模式串的前缀滑动到后缀相同的位置，从而主串匹配的位置i无需回溯，并继续从该位置继续比较</p>
<h3 id="二叉搜索树的优缺点"><a href="#二叉搜索树的优缺点" class="headerlink" title="二叉搜索树的优缺点"></a><strong>二叉搜索树的优缺点</strong></h3><p>二叉搜索树查找速度快、查找方便（logn时间）。但是其维护困难，且数据的插入和删除十分的复杂。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><p>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。操作系统本质上是一个运行在计算机上的软件程序 ，主要用于管理计算机硬件和软件资源。 </p>
<h3 id="操作系统实现的功能"><a href="#操作系统实现的功能" class="headerlink" title="操作系统实现的功能"></a>操作系统实现的功能</h3><ul>
<li><strong>进程和线程的管理</strong>：进程的创建、撤销、阻塞、唤醒，进程间的通信等。</li>
<li><strong>存储管理</strong>：内存的分配和管理、外存（磁盘等）的分配和管理等。</li>
<li><strong>文件管理</strong>：文件的读、写、创建及删除等。</li>
<li><strong>设备管理</strong>：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。</li>
<li><strong>网络管理</strong>：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。</li>
<li><strong>安全管理</strong>：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。</li>
</ul>
<h3 id="什么是用户态和内核态"><a href="#什么是用户态和内核态" class="headerlink" title="什么是用户态和内核态"></a>什么是用户态和内核态</h3><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ul>
<li><strong>用户态(User Mode)</strong> : 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当应用程序需要执行某些需要特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起系统调用请求，进入内核态。</li>
<li>**内核态(Kernel Mode)**：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。</li>
</ul>
<p>内核态相比用户态拥有更高的特权级别，因此能够执行更底层、更敏感的操作。不过，由于进入内核态需要付出较高的开销（需要进行一系列的上下文切换和权限检查），应该尽量减少进入内核态的次数，以提高系统的性能和稳定性。</p>
<h3 id="只有一个内核态不行吗"><a href="#只有一个内核态不行吗" class="headerlink" title="只有一个内核态不行吗"></a>只有一个内核态不行吗</h3><ul>
<li>在 CPU 的所有指令中，有一些指令是比较危险的比如内存分配、设置时钟、IO 处理等，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成灾难性地影响。因此，我们需要限制这些危险指令只能内核态运行。这些只能由操作系统内核态执行的指令也被叫做 <strong>特权指令</strong> 。</li>
<li>如果计算机系统中只有一个内核态，那么所有程序或进程都必须共享系统资源，例如内存、CPU、硬盘等，这将导致系统资源的竞争和冲突，从而影响系统性能和效率。并且，这样也会让系统的安全性降低，毕竟所有程序或进程都具有相同的特权级别和访问权限。</li>
</ul>
<h3 id="用户态和内核态是如何切换的"><a href="#用户态和内核态是如何切换的" class="headerlink" title="用户态和内核态是如何切换的"></a>用户态和内核态是如何切换的</h3><ol>
<li>系统调用</li>
<li>中断</li>
<li>异常</li>
</ol>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul>
<li><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间</p>
</li>
<li><p>线程是比进程更小的执行单位，它是在一个进程中独立的控制流，一个进程可以启动多个线程，每条线程并行执行不同的任务。</p>
</li>
</ul>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul>
<li>线程是进程划分成更小的运行单位，一个进程在其执行的过程中可以产生多个线程。</li>
<li>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li>
<li>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</li>
</ul>
<h3 id="有了进程为什么还要有线程"><a href="#有了进程为什么还要有线程" class="headerlink" title="有了进程为什么还要有线程"></a>有了进程为什么还要有线程</h3><ul>
<li>进程切换是一个开销很大的操作，线程切换的成本较低。</li>
<li>线程更轻量，一个进程可以创建多个线程。</li>
<li>多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。</li>
<li>同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。</li>
</ul>
<h3 id="线程间的同步方式"><a href="#线程间的同步方式" class="headerlink" title="线程间的同步方式"></a>线程间的同步方式</h3><ul>
<li>互斥锁</li>
<li>读写锁</li>
<li>信号量</li>
<li>屏障</li>
<li>事件</li>
</ul>
<h3 id="进程的几种状态"><a href="#进程的几种状态" class="headerlink" title="进程的几种状态"></a>进程的几种状态</h3><blockquote>
<p>PCB，进程控制块</p>
</blockquote>
<ul>
<li>创建</li>
<li>就绪</li>
<li>运行</li>
<li>阻塞</li>
<li>结束</li>
</ul>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>进程间通信方式有以下几种：</p>
<p>1、<strong>管道通信</strong></p>
<p>匿名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 有名管道是半双工的通信方式，数据只能单向流动。</p>
<p>2、<strong>消息队列</strong></p>
<p>3、<strong>共享内存</strong>。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
<p>4、<strong>信号量</strong>。信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<p>5、套接字</p>
<h3 id="进程调度的衡量标准是什么？"><a href="#进程调度的衡量标准是什么？" class="headerlink" title="进程调度的衡量标准是什么？"></a>进程调度的衡量标准是什么？</h3><ul>
<li>CPU利用率</li>
<li>系统吞吐量</li>
<li>周转时间</li>
<li>等待时间</li>
<li>响应时间</li>
</ul>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ul>
<li>先来先服务</li>
<li>短作业优先</li>
<li>高相应比优先</li>
<li>时间片轮转</li>
<li>优先级调度</li>
</ul>
<h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h3><ul>
<li>阻塞</li>
<li>挂起</li>
<li>执行</li>
</ul>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器可以做到并发。比如有两个进程<code>A</code>和<code>B</code>，<code>A</code>运行一个时间片之后，切换到<code>B</code>，<code>B</code>运行一个时间片之后又切换到<code>A</code>。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。</p>
<p>并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。</p>
<h3 id="多线程相较单线程的好处"><a href="#多线程相较单线程的好处" class="headerlink" title="多线程相较单线程的好处"></a>多线程相较单线程的好处</h3><p>1、并发提升程序执行效率</p>
<p>2、提升CPU利用率，访存的时候可以切换线程来执行</p>
<p>3、更快的响应速度，可以有专门的线程来监听用户请求和专门的线程来处理请求。比如监听线程和工作线程是两个线程，这样监听就负责监听，工作的就负责工作，监听到用户请求马上把请求转到工作线程去处理，监听线程继续监听</p>
<h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，它们都将无法推进下去。</p>
<h3 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h3><ol>
<li>互斥</li>
<li>占有并等待</li>
<li>非抢占</li>
<li>循环等待</li>
</ol>
<h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><ul>
<li>预防</li>
<li>避免</li>
<li>检测</li>
<li>解除</li>
</ul>
<h3 id="内存管理主要做了什么"><a href="#内存管理主要做了什么" class="headerlink" title="内存管理主要做了什么"></a>内存管理主要做了什么</h3><ol>
<li>内存的分配与回收</li>
<li>地址转换</li>
<li>内存扩充</li>
<li>内存映射</li>
<li>内存优化</li>
<li>内存安全</li>
</ol>
<h3 id="什么是物理地址和虚拟地址"><a href="#什么是物理地址和虚拟地址" class="headerlink" title="什么是物理地址和虚拟地址"></a>什么是物理地址和虚拟地址</h3><p><strong>物理地址（Physical Address）</strong> 是真正的物理内存中地址，更具体点来说是内存地址寄存器中的地址。程序中访问的内存地址不是物理地址，而是 <strong>虚拟地址（Virtual Address）</strong> 。</p>
<p>也就是说，我们编程开发的时候实际就是在和虚拟地址打交道。比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的虚拟地址。</p>
<h3 id="什么是分页？"><a href="#什么是分页？" class="headerlink" title="什么是分页？"></a>什么是分页？</h3><blockquote>
<p>把主存（物理内存）分为连续等长的物理页，应用程序的虚拟地址空间划也被分为连续等长的虚拟页。现代操作系统广泛采用分页机制。</p>
</blockquote>
<p>把内存空间划分为<strong>大小相等且固定的块</strong>，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，<strong>因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。</strong></p>
<p>访问分页系统中内存数据需要<strong>两次的内存访问</strong> (一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。</p>
<h3 id="什么是分段？"><a href="#什么是分段？" class="headerlink" title="什么是分段？"></a>什么是分段？</h3><blockquote>
<p>不同于分段机制下不同长度的段。</p>
</blockquote>
<p><strong>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</strong></p>
<p>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。</p>
<h3 id="分页和分段有什么区别？"><a href="#分页和分段有什么区别？" class="headerlink" title="分页和分段有什么区别？"></a>分页和分段有什么区别？</h3><ul>
<li>分页对程序员是透明的，但是分段需要程序员显式划分每个段。</li>
<li>分页的地址空间是一维地址空间，分段是二维的。</li>
<li>页的大小不可变，段的大小可以动态改变。</li>
<li>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ul>
<h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><ul>
<li>都是非连续内存管理的方式。</li>
<li>都采用了地址映射的方法，将虚拟地址映射到物理地址，以实现对内存的管理和保护。</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li><p>分页机制以页面为单位进行内存管理，而分段机制以段为单位进行内存管理。页的大小是固定的，由操作系统决定，通常为 2 的幂次方。而段的大小不固定，取决于我们当前运行的程序。</p>
</li>
<li><p>页是物理单位，即操作系统将物理内存划分成固定大小的页面，每个页面的大小通常是 2 的幂次方，例如 4KB、8KB 等等。而段则是逻辑单位，是为了满足程序对内存空间的逻辑需求而设计的，通常根据程序中数据和代码的逻辑结构来划分。</p>
</li>
<li><p>分段机制容易出现外部内存碎片，即在段与段之间留下碎片空间(不足以映射给虚拟地址空间中的段)。分页机制解决了外部内存碎片的问题，但仍然可能会出现内部内存碎片。</p>
</li>
<li><p>分页机制采用了页表来完成虚拟地址到物理地址的映射，页表通过一级页表和二级页表来实现多级映射；而分段机制则采用了段表来完成虚拟地址到物理地址的映射，每个段表项中记录了该段的起始地址和长度信息。</p>
</li>
<li><p>分页机制对程序没有任何要求，程序只需要按照虚拟地址进行访问即可；而分段机制需要程序员将程序分为多个段，并且显式地使用段寄存器来访问不同的段。</p>
</li>
</ul>
<h3 id="常见的磁盘调度算法"><a href="#常见的磁盘调度算法" class="headerlink" title="常见的磁盘调度算法"></a>常见的磁盘调度算法</h3><ol>
<li>先来先服务</li>
<li>最短寻道时间</li>
<li>扫描</li>
<li>循环扫描</li>
<li>边扫描边观察</li>
<li>均衡循环扫描</li>
</ol>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>启动mysql服务：<code>mysql [-h 127.0.0.1] [-P 3306] -u root -p</code></p>
<blockquote>
<p>-h 指定的是连接的是哪个ip，-p指定的是连接的是哪个端口</p>
<p>查看当前的mysql服务开在哪个端口上，<code>show global variables like 'port'</code></p>
</blockquote>
<p>ddl，数据定义语言，定义数据库对象</p>
<p>dml，数据操作语言，用来对数据库表中的数据进行增删改</p>
<p>dql，数据查询语言，查询库中表的记录</p>
<p>dcl，数据控制语言，用来创建数据库用户，控制数据库的访问权限</p>
<p>char   性能好，定长，多余的空间用空格占位</p>
<p>varchar  性能稍差，变长，用多少占用多少，自动计算</p>
<h3 id="什么是关系型数据库"><a href="#什么是关系型数据库" class="headerlink" title="什么是关系型数据库"></a>什么是关系型数据库</h3><p>顾名思义，关系型数据库（RDB，Relational Database）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p>
<p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p>
<h3 id="MySQL的字段类型"><a href="#MySQL的字段类型" class="headerlink" title="MySQL的字段类型"></a>MySQL的字段类型</h3><ul>
<li><strong>数值类型</strong>：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）</li>
<li><strong>字符串类型</strong>：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。</li>
<li><strong>日期时间类型</strong>：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。</li>
</ul>
<h3 id="什么是ER图"><a href="#什么是ER图" class="headerlink" title="什么是ER图"></a>什么是ER图</h3><blockquote>
<p>实体联系图，提供了表示实体类型，属性和联系的方法</p>
</blockquote>
<h3 id="主键和外键有什么区别"><a href="#主键和外键有什么区别" class="headerlink" title="主键和外键有什么区别"></a>主键和外键有什么区别</h3><p>**主键(主码)**：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</p>
<p>**外键(外码)**：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</p>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">CREATE TABLE tb_user(</span><br><span class="line">  id INT COMMENT '编号',</span><br><span class="line">	name VARCHAR(50) COMMENT '姓名',</span><br><span class="line">	age INT COMMENT '年龄',</span><br><span class="line">	gender VARCHAR(1) COMMENT '性别'</span><br><span class="line">) COMMENT '用户表';</span><br><span class="line"></span><br><span class="line">DESC tb_user;</span><br><span class="line">show CREATE TABLE tb_user;</span><br><span class="line"></span><br><span class="line">ALTER TABLE tb_user ADD teacher VARCHAR(10); -- 添加字段</span><br><span class="line">ALTER TABLE tb_user CHANGE teacher newteacher VARCHAR(20); -- 修改字段名</span><br><span class="line">ALTER TABLE tb_user DROP newteacher; -- 删除字段</span><br><span class="line">ALTER TABLE tb_user RENAME TO user; -- 修改表名</span><br><span class="line"></span><br><span class="line">CREATE TABLE demo(</span><br><span class="line">  id INT</span><br><span class="line">);</span><br><span class="line">DROP TABLE demo; -- 删除表</span><br><span class="line">TRUNCATE TABLE demo; -- 删除表，重新创建一个名字相同的新表</span><br></pre></td></tr></tbody></table></figure>

<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">INSERT INTO user (id,name,age) VALUES(12,'zhangsan',88); -- 给指定的字段添加数据</span><br><span class="line">INSERT INTO user VALUES(12,'lisi',22,'男'); -- 给整张表添加数据</span><br><span class="line">INSERT INTO user (id,name,age) VALUES(12,'zhadngsan',88),(1,'zhangsdsan',88),(2,'zhangsan',88); -- 批量添加数据</span><br><span class="line"></span><br><span class="line">UPDATE user SET id = 1,name = 2 WHERE id&gt;1; -- 如果没有条件，则会修改整张表的所有数据</span><br><span class="line"></span><br><span class="line">DELETE FROM user WHERE gender = '男'</span><br></pre></td></tr></tbody></table></figure>

<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><blockquote>
<p>基本查询，条件查询，聚合函数，分组查询，排序查询，分页查询</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">      字段列表</span><br><span class="line">FROM  </span><br><span class="line">      表名列表</span><br><span class="line">GROUP BY</span><br><span class="line">      分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">      分组后条件列表</span><br><span class="line">ORDER BY</span><br><span class="line">      排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">      分页参数</span><br></pre></td></tr></tbody></table></figure>

<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><blockquote>
<p>FROM</p>
<p>WHERE</p>
<p>GROUP BY</p>
<p>HAVING</p>
<p>SELECT</p>
<p>ORDER BY</p>
<p>LIMIT</p>
</blockquote>
<h4 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select * from user;</span><br><span class="line">select id from user;</span><br><span class="line">select id as '用户的id' from user;</span><br><span class="line">select distinct id from user;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from user</span><br><span class="line">where name is not null;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>执行顺序：where &gt; 聚合函数 &gt; having</p>
<p>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select dept_id, count(*)</span><br><span class="line">from emp</span><br><span class="line">where id &lt;= 5</span><br><span class="line">group by dept_id</span><br><span class="line">having count(*) &lt; 2;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><p>多字段排序，当第一个字段值相同的时候，根据第二个字段进行排序。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">order by dept_id desc, age;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="排序查询-1"><a href="#排序查询-1" class="headerlink" title="排序查询"></a>排序查询</h4><p><code>select 字段列表 from 表名 limit 起始索引，查询记录数</code></p>
<ul>
<li>起始索引从0开始，起始索引 = （查询页码 - 1）*每页显示记录数</li>
<li>分页查询是数据库的方言，不同的数据库有不同的表现，MySQL中是limit</li>
<li>如果查询的是第一页的数据，起始索引可以省略，直接简写为limit 10</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">limit 0,2;</span><br><span class="line"></span><br><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">limit 1,3;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="sql的几种子句是什么？顺序是什么？"><a href="#sql的几种子句是什么？顺序是什么？" class="headerlink" title="sql的几种子句是什么？顺序是什么？"></a>sql的几种子句是什么？顺序是什么？</h3><p>五个子句：</p>
<ul>
<li>from：组装来自不同数据源的数据</li>
<li>where：基于指定的条件对记录进行筛选</li>
<li>group by：将数据划分为多个分组</li>
<li>having：聚集函数进行计算</li>
<li>order by：对结果进行排序</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><p>封装是对象功能内聚的表现形式，在抽象基础上决定信息是否公开及公开等级，核心问题是以什么方式暴漏哪些信息。主要任务是对属性、数据、敏感行为实现隐藏，对属性的访问和修改必须通过公共接口实现。封装使对象关系变得简单，降低了代码耦合度，方便维护。</p>
<p>迪米特原则就是对封装的要求，即 A 模块使用 B 模块的某接口行为，对 B 模块中除此行为外的其他信息知道得应尽可能少。不直接对 public 属性进行读取和修改而使用 getter/setter 方法是因为假设想在修改属性时进行权限控制、日志记录等操作，在直接访问属性的情况下无法实现。如果将 public 的属性和行为修改为 private 一般依赖模块都会报错，因此不知道使用哪种权限时应优先使用 private。</p>
<p>继承用来扩展一个类，子类可继承父类的部分属性和行为使模块具有复用性。继承是”is-a”关系，可使用里氏替换原则判断是否满足”is-a”关系，即任何父类出现的地方子类都可以出现。如果父类引用直接使用子类引用来代替且可以正确编译并执行，输出结果符合子类场景预期，那么说明两个类符合里氏替换原则。</p>
<p>多态以封装和继承为基础，根据运行时对象实际类型使同一行为具有不同表现形式。降低代码的耦合性。多态指在编译层面无法确定最终调用的方法体，在运行期由 JVM 动态绑定，调用合适的重写方法。由于重载属于静态绑定，本质上重载结果是完全不同的方法，因此多态一般专指重写。</p>
<h3 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h3><p>重载指方法名称相同，但参数类型个数不同，是行为水平方向不同实现。</p>
<p>重写指子类实现接口或继承父类时，保持方法签名完全相同，实现不同方法体，是行为垂直方向不同实现。</p>
<hr>
<h2 id="2024-8-28-17-30-线上"><a href="#2024-8-28-17-30-线上" class="headerlink" title="2024.8.28 17:30 线上"></a>2024.8.28 17:30 <code>线上</code></h2><h3 id="准备PPT了吗"><a href="#准备PPT了吗" class="headerlink" title="准备PPT了吗"></a>准备PPT了吗</h3><p>对不起，没有，我不知道需要做</p>
<blockquote>
<p>算是一次正式的面试，所以需要制作ppt</p>
</blockquote>
<h3 id="你使用go语言开发什么应用"><a href="#你使用go语言开发什么应用" class="headerlink" title="你使用go语言开发什么应用"></a>你使用go语言开发什么应用</h3><p>我一般使用gin框架开发web应用服务端</p>
<h3 id="你有C-的开发经验吗"><a href="#你有C-的开发经验吗" class="headerlink" title="你有C++的开发经验吗"></a>你有C++的开发经验吗</h3><p>没有，cpp只是打算法竞赛的时候作为解题的语言使用</p>
<h3 id="介绍一下你的大创项目"><a href="#介绍一下你的大创项目" class="headerlink" title="介绍一下你的大创项目"></a>介绍一下你的大创项目</h3><p>我突然紧张了一下，脑子空了一下，直接回答的本质上就是一个对象存储和大语言模型结合的本地知识库智能问询，知识挖掘的部分使用向量数据库的相似性检索。</p>
<p>&lt;项目以人工智能赋能数据存储为出发点，通过将大语言模型和对象存储功能有机结合，创建了一套兼具数据安全、资料存储、知识挖掘与智能问答的平台。深入挖掘文件知识，提供精准的智能咨询。结合对象存储，打造个性化文件管家，提升文件存取效率和协作能力。私有化部署保障数据安全，简化硬件需求，优化用户体验。&gt;</p>
<h3 id="知识库进行知识挖掘的过程是什么样的"><a href="#知识库进行知识挖掘的过程是什么样的" class="headerlink" title="知识库进行知识挖掘的过程是什么样的"></a>知识库进行知识挖掘的过程是什么样的</h3><blockquote>
<p>就是用户提问，然后到你们的题库中去匹配吗，我这样理解对吗</p>
</blockquote>
<p>不对，读取用户上传的文件，对特定格式的文件进行预处理，分词，embedding向量化，将得到的向量数据存储到向量数据库中，用户提问，对用户做出的提问进行向量化，在向量数据库中进行搜索，找出自相似的几条向量数据，将向量数据库的输出内容输出给大语言模型进行处理，生成用户能够理解的具有一定逻辑性的回答。</p>
<ol>
<li><strong>向量化处理</strong>：首先，原始数据（如文本、图像等）需要通过嵌入模型转换成向量形式。这些向量能够捕捉数据的关键特征，并以数值形式表示，便于机器处理和比较 。</li>
<li><strong>存储与索引</strong>：生成的向量数据随后被存储在向量数据库中，并建立相应的索引，以优化搜索效率。不同的向量数据库如Chroma、Milvus、Faiss、Weaviate等，提供了不同的索引结构和算法来加速向量搜索过程 。</li>
<li><strong>相似性搜索</strong>：当用户提出查询时，查询同样被转换成向量形式，并在向量数据库中执行相似性搜索，找到与查询向量最相似的向量。这个过程通常利用余弦相似度、欧氏距离等度量标准来评估向量之间的相似度 。</li>
<li><strong>信息检索</strong>：搜索结果通常是一组与查询向量最相似的数据向量。这些向量可以代表相关的文档、图像或其他类型的数据。</li>
<li><strong>LLM处理</strong>：检索到的向量或相关数据随后被用作上下文信息，输入到大型语言模型中。LLM利用这些信息生成自然语言响应，以回答用户的查询。在这个过程中，LLM可以结合检索到的知识与用户的具体需求，生成更加准确和有帮助的回答 。</li>
<li><strong>结果优化</strong>：为了提高生成内容的质量和相关性，可以对LLM进行微调，使其更好地适应特定的业务场景或领域知识 。</li>
<li><strong>用户反馈</strong>：最后，生成的内容可以展示给用户，并根据用户的反馈进行迭代优化，以不断提升系统的性能和用户体验。</li>
</ol>
<h3 id="大语言模型在项目中起到了什么样的作用"><a href="#大语言模型在项目中起到了什么样的作用" class="headerlink" title="大语言模型在项目中起到了什么样的作用"></a>大语言模型在项目中起到了什么样的作用</h3><p>大模型输入输出都是文字文本，但是模型实际接触和学习数据是向量化文本</p>
<p>LLM处理：检索到的向量或相关数据随后被用作上下文信息，输入到大型语言模型中。LLM利用这些信息生成自然语言响应，以回答用户的查询。在这个过程中，LLM可以结合检索到的知识与用户的具体需求，生成更加准确和有帮助的回答 。</p>
<h3 id="用到是哪个公司的大预言模型"><a href="#用到是哪个公司的大预言模型" class="headerlink" title="用到是哪个公司的大预言模型"></a>用到是哪个公司的大预言模型</h3><ul>
<li>百度：文心一言</li>
<li>阿里：通义千问</li>
<li>OpenAI：Chat-GPT</li>
</ul>
<p>else</p>
<ul>
<li>腾讯：混元助手</li>
<li>华为：盘古</li>
<li>科大讯飞：讯飞星火</li>
<li>清华智谱：“ChatGLM”大模型</li>
</ul>
<h3 id="你有什么特别感兴趣的算法吗"><a href="#你有什么特别感兴趣的算法吗" class="headerlink" title="你有什么特别感兴趣的算法吗"></a>你有什么特别感兴趣的算法吗</h3><p>这个被问懵了，本来是想回答我感觉巧妙的算法，比如KMP</p>
<p>但是具体的解释遗忘了，就给模糊过去了</p>
<p>“之前学过的算法都是一些常用的，没有什么特别感兴趣的”</p>
<h3 id="我看你给了一个个人网站的链接，这你有什么用吗"><a href="#我看你给了一个个人网站的链接，这你有什么用吗" class="headerlink" title="我看你给了一个个人网站的链接，这你有什么用吗"></a>我看你给了一个个人网站的链接，这你有什么用吗</h3><p>平时学习的时候记一些个人博客</p>
<h3 id="你的研究生的计划是什么"><a href="#你的研究生的计划是什么" class="headerlink" title="你的研究生的计划是什么"></a>你的研究生的计划是什么</h3><p>继续在计算机领域深造，之前学习的东西太浅显，还希望继续学习</p>
<p><code>moreover</code></p>
<p>•本科期间学习的内容都比较浅显，希望能在读研期间更深入学习计算机领域的相关知识。</p>
<p>•提高抗压能力和保持积极乐观的心态。</p>
<p>•端正态度，积极阅读专业相关论著，勤于思考。</p>
<p>•与导师和组内的其他同学积极交流，开拓科研视野。扎实完成科研和其他课题任务，提高自主创新能力。</p>
<p>•毕业找一份心仪工作。</p>
<h3 id="研究生的压力能够承受了吗"><a href="#研究生的压力能够承受了吗" class="headerlink" title="研究生的压力能够承受了吗"></a>研究生的压力能够承受了吗</h3><blockquote>
<p>强调了毕业的条件要做出一定的成果，询问一天能够在学习的时间，一周中能够工作的时间，之前有高强度地进行开发的经历吗</p>
</blockquote>
<h3 id="你有没有需要询问的问题"><a href="#你有没有需要询问的问题" class="headerlink" title="你有没有需要询问的问题"></a>你有没有需要询问的问题</h3><p>去广州会提供宿舍吗</p>
<blockquote>
<p>先在西安上学，之后到广研院，都提供宿舍</p>
</blockquote>
<p>面试的结果什么时候会出</p>
<blockquote>
<p>一两天，邮件通知，这两天我都在面试学生</p>
</blockquote>
<hr>
<h2 id="2024-9-23-西电广研院"><a href="#2024-9-23-西电广研院" class="headerlink" title="2024.9.23 西电广研院"></a>2024.9.23 <code>西电广研院</code></h2><blockquote>
<p>面试的顺序是按姓名拼音排序的，我排在了本场的倒数第三名去面试。</p>
<p>西电广研院今年的面试没有问及专业课的问题，考察英语能力也仅是英文的自我介绍，会问一道考察思想政治素质的题目，主要是围绕你所写的项目去展开。</p>
</blockquote>
<h3 id="英文自我介绍，一分钟"><a href="#英文自我介绍，一分钟" class="headerlink" title="英文自我介绍，一分钟"></a>英文自我介绍，一分钟</h3><h3 id="谈谈你对文化自信的理解"><a href="#谈谈你对文化自信的理解" class="headerlink" title="谈谈你对文化自信的理解"></a>谈谈你对文化自信的理解</h3><h3 id="介绍一下你的项目"><a href="#介绍一下你的项目" class="headerlink" title="介绍一下你的项目"></a>介绍一下你的项目</h3><h3 id="项目中的大模型发挥了什么作用"><a href="#项目中的大模型发挥了什么作用" class="headerlink" title="项目中的大模型发挥了什么作用"></a>项目中的大模型发挥了什么作用</h3><h3 id="平时学过或者自己复现过一些深度学习算法之类的吗"><a href="#平时学过或者自己复现过一些深度学习算法之类的吗" class="headerlink" title="平时学过或者自己复现过一些深度学习算法之类的吗"></a>平时学过或者自己复现过一些深度学习算法之类的吗</h3><h3 id="项目使用开源的东西进行开发的吗"><a href="#项目使用开源的东西进行开发的吗" class="headerlink" title="项目使用开源的东西进行开发的吗"></a>项目使用开源的东西进行开发的吗</h3><h3 id="我看你打过一些反映编程能力的比赛，你平时都学过哪些算法"><a href="#我看你打过一些反映编程能力的比赛，你平时都学过哪些算法" class="headerlink" title="我看你打过一些反映编程能力的比赛，你平时都学过哪些算法"></a>我看你打过一些反映编程能力的比赛，你平时都学过哪些算法</h3><h3 id="我看你是客户端开发，所以跟大模型对接的那些东西都是另一个同学开发的对吗"><a href="#我看你是客户端开发，所以跟大模型对接的那些东西都是另一个同学开发的对吗" class="headerlink" title="我看你是客户端开发，所以跟大模型对接的那些东西都是另一个同学开发的对吗"></a>我看你是客户端开发，所以跟大模型对接的那些东西都是另一个同学开发的对吗</h3><h3 id="学过或者说看过一些关于深度学习的课程吗"><a href="#学过或者说看过一些关于深度学习的课程吗" class="headerlink" title="学过或者说看过一些关于深度学习的课程吗"></a>学过或者说看过一些关于深度学习的课程吗</h3><h3 id="你们的项目大多数都是调用接口的吗"><a href="#你们的项目大多数都是调用接口的吗" class="headerlink" title="你们的项目大多数都是调用接口的吗"></a>你们的项目大多数都是调用接口的吗</h3><h2 id="邮件文书"><a href="#邮件文书" class="headerlink" title="邮件文书"></a>邮件文书</h2><p>尊敬的xxxx老师：</p>
<p>您好！</p>
<p>我叫xxxx，是xxxx大学xxxxx专业的大四在读学生。我今年拿到了本校推免的名额，渴望能够有机会推免攻读您的硕士，想冒昧问您一下，您今年是否还有招生名额，我能否有机会得到您的指导。</p>
<p>在过去三年的学习生活中，我刻苦努力，力争上游，专业排名为xx/xx。我编程基础扎实，能够独立完成简单信息管理系统从需求分析到系统设计到代码实现等的工作。我曾在xxx和xxx年连续两年获xxxxx大赛xxxxx等奖，曾获xxxxx大赛全国总决赛xxxxx奖等奖项。我于今年作为负责人参加了大学生创新创业训练计划，项目获得国家级拟立项资格。</p>
<p>我拥有良好的英语水平，英语四级xxx分，英语六级xxx分。我为人热情大方，活泼开朗，乐观积极向上，敢于面对并解决工作学习过程中遇到的挑战。</p>
<p>附件为我的简历，供您参考。</p>
<p>冒昧致信，恳请您海涵！非常感谢您能够在百忙之中抽出时间阅信。</p>
<p>祝您身体健康，工作愉快！</p>
<p>xxxx</p>
<p>xxxxxx</p>
<p>xxxx年x月xx日</p>
<h2 id="EnglishProficiency"><a href="#EnglishProficiency" class="headerlink" title="EnglishProficiency"></a>EnglishProficiency</h2><h3 id="SelfIntroduction"><a href="#SelfIntroduction" class="headerlink" title="SelfIntroduction"></a>SelfIntroduction</h3><blockquote>
<p>Please start your introduction</p>
<p>Please tell me about yourself / introduce yourself</p>
<p>What would you like us to know about you ?</p>
</blockquote>
<blockquote>
<p>本身没有什么特别的长处，感觉这样也好表达，同时我想让他人了解的东西都有所提及，算是简单介绍了一下，关键要看流利度和停顿我赶脚。</p>
</blockquote>
<p>Good morning / afternoon, It’s very nice to meet you professors. It’s an honor to be here today.</p>
<p>My name is tammer. I’m a senior student majoring in Computer Science and Technology at …… University. I’m currently excelling in my courses, and I’m ranked second in my major. I’ve also received provincial first price award for my performance in Lanqiao Cup Competition. And our team won the provincial second prise in the Chinese Collegiate Computing Competition for two consecutive years. </p>
<p>In my study, I’m especially interested in Artificial Intellegence, so I formed a team to research developing applications powered by large language models. After several months of coding, we finally developed a local knowledge base question-answering system. Within my team, I was chosen to complete the concept design and client code implementation because I‘m good at front-end development.</p>
<p>Besides, I’m very observant, adaptable, flexible with people and situations and always ready to learn new things. I firmly believe physical fitness should be an essential part of life like eating and sleeping. So during my spare time I would go to the gym and exercise for an hour, and after that the fatigue of the day would disappear.</p>
<p>I believe these qualities will make me better fulfill my role as a graduate student in the future.</p>
<p>That’s all, thank you! </p>
<p><code>2 to 3 minutes</code></p>
<p>Good morning / afternoon, It’s very nice to meet<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>you professors. It’s an <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>honor to be here today.</p>
<p>My name<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> is tammer. I’m <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>a senior student majoring in Computer Science <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>and Technology at …… University. I’m currently excelling<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> in my courses, and <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>I’m ranked second in my major. Additionally, I’ve also received provincial first price <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>award for my performance in Lanqiao Cup Competition. And <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>our team won the provincial second prise in the Chinese Collegiate Computing Competition for two consecutive years. </p>
<p>In my study, I’m interested<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> in Artificial Intellegence, so I formed <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>a team to research developing applications powered by large language models. After several months <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>of coding, we finally developed<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> a local knowledge base question-answering system. Within my team, I was chosen to complete the concept design and client code implementation because I‘m good <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>at front-end development.</p>
<p>Besides, I’m very observant, adaptable, flexible with people <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>and situations and <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>always ready to learn new things. I firmly believe physical fitness should be an essential part<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> of life like eating and sleeping. So during my spare time I would go to the gym and exercise for <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>an <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>hour, and <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>after that the fatigue of the day would disappear.</p>
<p>I believe these qualities will make me better fulfill my role<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> as <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>a graduate student in the future.</p>
<p>That’s all, thank you! </p>
<h3 id="OtherQuestion"><a href="#OtherQuestion" class="headerlink" title="OtherQuestion"></a>OtherQuestion</h3><blockquote>
<p>why do you choose our school ?</p>
</blockquote>
<p>because xi’dian is famous in computer, and i want to study further in computer science and technology, so choose it, and i would be glad to enter it.</p>
<h2 id="行远自迩，登高自卑"><a href="#行远自迩，登高自卑" class="headerlink" title="行远自迩，登高自卑"></a>行远自迩，登高自卑</h2><blockquote>
<p>行远自迩，登高自卑，行走远路要从近处开始，登高山要从低处开始，比喻做事要脚踏实地，循序渐进。</p>
</blockquote>
<h2 id="思想政治素质"><a href="#思想政治素质" class="headerlink" title="思想政治素质"></a>思想政治素质</h2><h3 id="根本政治制度"><a href="#根本政治制度" class="headerlink" title="根本政治制度"></a>根本政治制度</h3><p>人民代表大会制度</p>
<h3 id="指导思想"><a href="#指导思想" class="headerlink" title="指导思想"></a>指导思想</h3><ul>
<li>马克思列宁主义</li>
<li>毛泽东思想</li>
<li>邓小平理论</li>
<li>“三个代表”重要思想<ol>
<li>代表中国先进生产力的发展要求</li>
<li>代表中国先进文化的前进方向</li>
<li>代表中国最广大人民的根本利益</li>
</ol>
</li>
<li>科学发展观</li>
<li>习近平新时代中国特色社会主义思想</li>
</ul>
<h3 id="四个自信"><a href="#四个自信" class="headerlink" title="四个自信"></a>四个自信</h3><ul>
<li>道路自信</li>
<li>理论自信</li>
<li>制度自信</li>
<li>文化自信</li>
</ul>
<h3 id="初心使命"><a href="#初心使命" class="headerlink" title="初心使命"></a>初心使命</h3><p>为中国人民谋幸福，为中华民族谋复兴</p>
<h3 id="新时代"><a href="#新时代" class="headerlink" title="新时代"></a>新时代</h3><p>如今实现了第一个百年奋斗目标（全面建成小康社会），开启了第二个百年奋斗目标新征程（建成富强民主文明和谐美丽的社会主义现代化强国。</p>
<p>我国正处于并将长期处于社会主义初级阶段</p>
<h3 id="执政兴国的第一要务"><a href="#执政兴国的第一要务" class="headerlink" title="执政兴国的第一要务"></a>执政兴国的第一要务</h3><p>发展，坚持以人民为中心的发展思想</p>
<h3 id="基本路线"><a href="#基本路线" class="headerlink" title="基本路线"></a>基本路线</h3><p>领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为一个富强民主文明和谐美丽的社会主义现代化强国而奋斗。</p>
<h3 id="四项基本原则"><a href="#四项基本原则" class="headerlink" title="四项基本原则"></a>四项基本原则</h3><ul>
<li>坚持社会主义道路</li>
<li>坚持人民民主专政</li>
<li>坚持中国共产党的领导</li>
<li>坚持马克思列宁主义毛泽东思想</li>
</ul>
<h3 id="入党誓词"><a href="#入党誓词" class="headerlink" title="入党誓词"></a>入党誓词</h3><p>我志愿加入中国共产党，拥护党的纲领，遵守党的章程，履行党员义务，执行党的决定，严守党的纪律，保守党的秘密，对党忠诚，积极工作，为共产主义奋斗终身，随时准备为党和人民牺牲一切，永不叛党。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>面试题部分：JavaGuide</li>
<li>思想政治素质部分：党章</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
        <category>经验</category>
        <category>推免</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>面试</tag>
        <tag>经验</tag>
        <tag>推免</tag>
      </tags>
  </entry>
  <entry>
    <title>由数据范围反推算法复杂度以及算法内容</title>
    <url>/posts/9e259833.html</url>
    <content><![CDATA[<h4 id="由数据范围反推算法复杂度以及算法内容"><a href="#由数据范围反推算法复杂度以及算法内容" class="headerlink" title="由数据范围反推算法复杂度以及算法内容"></a>由数据范围反推算法复杂度以及算法内容</h4><p>一般ACM或者笔试题的时间限制是1秒或者2秒。</p>
<p>在这种情况下，C++代码中的操作次数控制在 $10^7$~$10^8$ 最佳。</p>
<p>下面给出在不同的数据范围下，代码的时间复杂度和算法该如何选择：</p>
<ol>
<li>n $\leq$ 30，指数级别，dfs+剪枝，状态压缩dp</li>
<li>n $\leq$ 100 $\Rightarrow$ O( $n^3$ )，floyd，dp，高斯消元</li>
<li>n $\leq$ 1000 $\Rightarrow$ O( $n^2$ )，O( $n^2logn$ )，dp，二分，朴素版Dijkstra，朴素版Prim、BellmanFord</li>
<li>n $\leq$ 10000 $\Rightarrow$ O( n * $\sqrt n$ )，块状链表，分块，莫队</li>
<li>n $\leq$ 100000 $\Rightarrow$ O( nlogn ) $\Rightarrow$ 各种sort、线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</li>
<li>n $\leq$ 1000000 $\Rightarrow$ O( n )，以及常数较小的O( nlogn )算法 $\Rightarrow$ 单调队列、hash、双指针扫描、并查集、kmp、AC自动机，常数比较小的O( nlogn )的做法：sort、树状数组、heap、dijkstra、spfa</li>
<li>n $\leq$ 10000000 $\Rightarrow$ O( n )，双指针扫描、kmp，AC自动机、线性筛素数</li>
<li>n $\leq$ $10^9$ $\Rightarrow$ O( $\sqrt n$ )，判断质数</li>
<li>n $\leq$ $10^{18}$ $\Rightarrow$ O( logn )，最大公约数，快速幂，数位DP</li>
<li>n $\leq$ $10^{1000}$ $\Rightarrow$ O( $(logn)^2$ )，高精度加减乘除</li>
<li>n $\leq$ $10^{100000}$ $\Rightarrow$ O( logk $\times$ loglogk )，k表示位数，高精度加减，FFT/NIT</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据范围</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础知识</title>
    <url>/posts/35c4e025.html</url>
    <content><![CDATA[<h1 id="算法基础知识"><a href="#算法基础知识" class="headerlink" title="算法基础知识"></a>算法基础知识</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><blockquote>
<p>本质就是先递进再回归</p>
</blockquote>
<ol>
<li>明确函数需要干什么</li>
<li>寻找递归结束的条件</li>
<li>等价关系式，不断缩小参数的范围</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>machine-learning</title>
    <url>/posts/da37838d.html</url>
    <content><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><blockquote>
<p>计算机无需明确编程即可学习的研究领域</p>
</blockquote>
<h2 id="人工智能的术语"><a href="#人工智能的术语" class="headerlink" title="人工智能的术语"></a>人工智能的术语</h2><ul>
<li>训练集(training set)：用于训练模型的数据集</li>
<li>输入变量/输入特征(input)：x</li>
<li>目标变量/输出变量：y</li>
<li>预测的目标变量：y-hat</li>
<li>训练数据的总数：m</li>
<li>单个训练示例：(x, y)</li>
<li>第几个训练数据：(x<sup>(i)</sup>, y<sup>(i)</sup>)</li>
</ul>
<h2 id="监督学习-supervised-learning"><a href="#监督学习-supervised-learning" class="headerlink" title="监督学习(supervised learning)"></a>监督学习(supervised learning)</h2><blockquote>
<p>当下创造经济价值最多的机器学习形式是监督学习</p>
</blockquote>
<p>在监督学习中，数据同时带有输入x和输入标签y</p>
<p>学习预测输入、输出或者X到Y的映射</p>
<h3 id="回归算法-regression"><a href="#回归算法-regression" class="headerlink" title="回归算法(regression)"></a>回归算法(regression)</h3><p>学习预测数字，无限多的可能数</p>
<h3 id="分类算法-classification"><a href="#分类算法-classification" class="headerlink" title="分类算法(classification)"></a>分类算法(classification)</h3><p>输出的可能性是有限的，一组有限的输出类别，通过拟合算法找到一条分界线</p>
<h2 id="无监督学习-unsupervised-learning"><a href="#无监督学习-unsupervised-learning" class="headerlink" title="无监督学习(unsupervised learning)"></a>无监督学习(unsupervised learning)</h2><blockquote>
<p>最广泛使用的机器学习形式是无监督学习</p>
</blockquote>
<p>不试图监督算法为了给每个输入提供一些正确的答案，相反，我们要求我们的空间自己弄清楚什么是有趣的，或者这个数据中可能有什么模式或者结构。人们没有提前为算法给出示例的正确答案。	</p>
<p>在无监督学习中，数据仅带有输入x而没有输出标签y，而且算法必须发现数据中的某种结构或者某种模式或者某些有趣的东西</p>
<h3 id="聚类算法-clustering"><a href="#聚类算法-clustering" class="headerlink" title="聚类算法(clustering)"></a>聚类算法(clustering)</h3><p>就是一种无监督学习，将相似的数据点分组</p>
<h3 id="异常检测-anomaly-detection"><a href="#异常检测-anomaly-detection" class="headerlink" title="异常检测(anomaly detection)"></a>异常检测(anomaly detection)</h3><p>检测异常事件</p>
<h3 id="降维-dimensionality-reduction"><a href="#降维-dimensionality-reduction" class="headerlink" title="降维(dimensionality reduction)"></a>降维(dimensionality reduction)</h3><p>将一个大的数据集，压缩到一个小得多的数据集，而丢失尽可能少的信息</p>
<h2 id="jupyter-notebook"><a href="#jupyter-notebook" class="headerlink" title="jupyter notebook"></a>jupyter notebook</h2><p>实验环境</p>
<h2 id="线性回归模型-linear-regression"><a href="#线性回归模型-linear-regression" class="headerlink" title="线性回归模型(linear regression)"></a>线性回归模型(linear regression)</h2><p>将一条直线拟合到数据中，预测数字的监督学习，只有一个输入特征或者说变量</p>
<p>具有一个输入变量的线性模型，另一个名称：单变量线性回归</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><code>feature --&gt; model --&gt; prediction</code></p>
<p><code>x --&gt; f --&gt; y-hat (estimated y)</code></p>
<h3 id="f-model"><a href="#f-model" class="headerlink" title="f/model"></a>f/model</h3><p>f<sub>w, b</sub> = wx + b</p>
<p><code>f(x) = wx + b</code></p>
<h2 id="代价函数-cost-function"><a href="#代价函数-cost-function" class="headerlink" title="代价函数(cost function)"></a>代价函数(cost function)</h2><blockquote>
<p>衡量拟合程度</p>
</blockquote>
<p>w, b是模型的参数，在机器学习w, b是咱可以调整的变量，以改进模型，或者称为系数或者权重</p>
<p>为了构建一个不会随着训练集大小变大而自动变大的成本函数，我们将计算平均平方误差而不是总平方误差，按照惯例，人们使用的成本函数实际上是除以2乘以m，额外除以2只是为了让我们后面的一些计算看起来更整洁，但是无论是否包含此除以2，成本函数仍然有效。</p>
<p>线性回归问题最常用的代价函数就是<code>平方误差成本函数</code>，训练的目的是使成本函数尽可能小，找到j最小的时候的w, b的值</p>
<p>$$<br>J(w,b)=\frac{1}{2m}\sum_{i = 1}^m(f_{w,b}x^{(i)}-y^{(i)})^2<br>$$</p>
<h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>梯度下降算法是一种可以用于求任何代价函数的最小值的算法，不仅仅是线性回归的代价函数，在w，b—上最小化代价函数</p>
<p>从对参数的猜测开始，不断变化w，b的值去降低代价函数的值，直到我们得到最小值或者接近最小值，有时候代价函数的最小值可能存在不止一个，神经网络的代价函数的图就是上下起伏的，有多个谷底</p>
<p>在山峰上的时候如果想要去到谷底，环顾一周，看哪能最速下坡，一步一步重复，就到谷底。</p>
<p>可以通过选择开始的w，b值，<code>设置不同的起点，会进入一个完全不同的山谷，进入局部最小值</code>。</p>
<h3 id="实现梯度下降算法"><a href="#实现梯度下降算法" class="headerlink" title="实现梯度下降算法"></a>实现梯度下降算法</h3><p>$$<br>w=w-\alpha\frac{\partial}{\partial w}J(w,b)<br>\<br>b=b-\alpha\frac{\partial}{\partial b}J(w,b)<br>$$</p>
<p>在程序中<code>=</code>是赋值的意思，而不是数学符号中的真值断言，如果像完成真值断言的功能使用<code>==</code>，断言两个值是否相等</p>
<h4 id="Alpha"><a href="#Alpha" class="headerlink" title="Alpha"></a>Alpha</h4><p>学习率</p>
<p>0~1之间的一个小的正数，控制下坡的步幅，控制更新时的步长</p>
<h4 id="j的导数项"><a href="#j的导数项" class="headerlink" title="j的导数项"></a>j的导数项</h4><p>朝哪个方向迈出脚步</p>
<h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>设定一个开始值，不断执行这个更新步骤，直到算法收敛，也就是说走到谷底，或者说十分接近谷底，不再随着采取的每一个额外步骤而发生很大变化</p>
<h3 id="正确同时更新"><a href="#正确同时更新" class="headerlink" title="正确同时更新"></a>正确同时更新</h3><p>$$<br>tmp_w=w-\alpha\frac{\partial}{\partial w}J(w,b)\<br>tmp_b=b-\alpha\frac{\partial}{\partial b}J(w,b)\<br>w=tmp_w<br>b=tmp_b<br>$$</p>
<h3 id="学习率的选择"><a href="#学习率的选择" class="headerlink" title="学习率的选择"></a>学习率的选择</h3><blockquote>
<p>影响效率</p>
</blockquote>
<p>学习率太小，每次迈出的步子，收敛的速度会很慢，需要很多步骤</p>
<p>学习率太大，每次迈出的步子太大，有可能会错i过适合收敛的位置，最后无法收敛甚至发散，离最小值越来远<br>$$<br>w=w-\alpha\frac{1}{m}\sum_{i = 1}^m(f_{w,b}x^{(i)}-y^{(i)})x^{(i)}\<br>b=b-\alpha\frac{1}{m}\sum_{i = 1}^m(f_{w,b}x^{(i)}-y^{(i)})<br>$$<br>线性回归只有一个最小值，因为他是一个凸函数</p>
<p>这种梯度下降叫做批量梯度下降(bashed grading descent)，在梯度下降的每一步中我们都在查看所有的训练示例，而不仅仅是训练数据的一个子集，每次计算的时候都看了整个训练集</p>
<p>也有使用子集进行计算，我们选择批量梯度下降算法进行线性回归</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>机器学习</category>
        <category>人工智能</category>
        <category>lea</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
        <tag>lea</tag>
      </tags>
  </entry>
</search>
