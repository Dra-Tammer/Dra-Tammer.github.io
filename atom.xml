<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Toothless</title>
  
  <subtitle>world for tammer</subtitle>
  <link href="https://dra-tammer.github.io/atom.xml" rel="self"/>
  
  <link href="https://dra-tammer.github.io/"/>
  <updated>2025-02-19T08:11:10.036Z</updated>
  <id>https://dra-tammer.github.io/</id>
  
  <author>
    <name>tammer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>历史的温度5</title>
    <link href="https://dra-tammer.github.io/posts/bcb57ef9.html"/>
    <id>https://dra-tammer.github.io/posts/bcb57ef9.html</id>
    <published>2025-02-19T08:05:55.000Z</published>
    <updated>2025-02-19T08:11:10.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="历史的温度5"><a href="#历史的温度5" class="headerlink" title="历史的温度5"></a>历史的温度5</h1><p><code>start from 2025-01-19</code></p><p><code>end on 2025-02-19</code></p><p><code>馒头大师</code></p><blockquote><p>读懂过去，活好当下，坦面未来</p></blockquote><p>高中毕业之后就再也没想着看过，一眨眼就出到7了，遂买来看一下，还是高中时的感觉，还是能沉迷到历史故事里面。就好比时隔四年同学再见面一样，仿佛前一天还在一起上晚自习。可惜，时光荏苒，一切得向前看。</p>]]></content>
    
    
    <summary type="html">作者：馒头大师</summary>
    
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>reinforcement_learning</title>
    <link href="https://dra-tammer.github.io/posts/f7d57928.html"/>
    <id>https://dra-tammer.github.io/posts/f7d57928.html</id>
    <published>2025-01-27T09:28:38.000Z</published>
    <updated>2025-01-27T11:39:39.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h1><blockquote><p>强化学习，是agent在与环境的互动当中为了达成一个目标而进行的学习过程</p></blockquote><blockquote><p>玩家与环境的互动当中，为了达成一个目标而进行的学习过程</p></blockquote><p>强化学习学习的东西实际上就是一个好的价值函数，一个好的价值函数决定一个好的策略。</p><h2 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h2><h3 id="agent"><a href="#agent" class="headerlink" title="agent"></a>agent</h3><p>与环境进行互动的主体（玩家）</p><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>游戏本身</p><h3 id="goal"><a href="#goal" class="headerlink" title="goal"></a>goal</h3><p>强化学习的目的是最大化总的奖励</p><h2 id="主要元素"><a href="#主要元素" class="headerlink" title="主要元素"></a>主要元素</h2><h3 id="state-状态"><a href="#state-状态" class="headerlink" title="state 状态"></a>state 状态</h3><h3 id="action-行动"><a href="#action-行动" class="headerlink" title="action 行动"></a>action 行动</h3><p>在某个状态需要进行的行动</p><h3 id="reward-奖励"><a href="#reward-奖励" class="headerlink" title="reward 奖励"></a>reward 奖励</h3><p>agent在一个状态之下采取了特定的行动之后所得到的即时的反馈</p><h2 id="核心元素"><a href="#核心元素" class="headerlink" title="核心元素"></a>核心元素</h2><h3 id="policy-策略"><a href="#policy-策略" class="headerlink" title="policy 策略"></a>policy 策略</h3><p>在某一个状态下应该采取什么样的行动，在数学上策略就是一个函数，它的自变量，也就是输入是一个状态，因变量是一个行动</p><h3 id="value-价值"><a href="#value-价值" class="headerlink" title="value 价值"></a>value 价值</h3><p>价值也是一个函数，策略函数取决于价值函数。预期将来会得到的所有奖励之和。处于当前的状态之下，玩家在将来能够得到的所有奖励的一个期望值。</p><h4 id="state-value-状态价值函数"><a href="#state-value-状态价值函数" class="headerlink" title="state value 状态价值函数"></a>state value 状态价值函数</h4><p>输入是一个状态，输出是一个实数，也就是这个状态的价值。通过状态价值函数玩家应该选择进入价值尽可能大的状态，这是通过特定的行动来实现的，这就是状态价值函数决定了玩家的策略。</p><h4 id="state-action-value-状态行动价值函数"><a href="#state-action-value-状态行动价值函数" class="headerlink" title="state-action value 状态行动价值函数"></a>state-action value 状态行动价值函数</h4><p>在特定状态下，采取某种行动所具有的价值。在特定的状态下，根据状态行动价值函数，玩家应该选择价值最大的那一个行动，这就是状态行动价值函数决定了玩家的策略。</p><h2 id="强化学习的三层结构"><a href="#强化学习的三层结构" class="headerlink" title="强化学习的三层结构"></a>强化学习的三层结构</h2><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/reinforcement_leanring.png"></p><h2 id="强化学习的两个特点"><a href="#强化学习的两个特点" class="headerlink" title="强化学习的两个特点"></a>强化学习的两个特点</h2><h3 id="Trial-and-Error-试错"><a href="#Trial-and-Error-试错" class="headerlink" title="Trial and Error 试错"></a>Trial and Error 试错</h3><p>强化学习是一个试错学习，也就是在不断的尝试中去学习</p><h3 id="Delayed-Reward-延迟奖励"><a href="#Delayed-Reward-延迟奖励" class="headerlink" title="Delayed Reward 延迟奖励"></a>Delayed Reward 延迟奖励</h3><p>行动没有对应即时的奖励，但是每一步棋对于最后的胜利都是有贡献的</p><h2 id="Exploration-vs-Exploitation"><a href="#Exploration-vs-Exploitation" class="headerlink" title="Exploration vs. Exploitation"></a>Exploration vs. Exploitation</h2><blockquote><p>强化学习的核心问题，两者之间的权衡</p></blockquote><h3 id="Exploitation-利用"><a href="#Exploitation-利用" class="headerlink" title="Exploitation 利用"></a>Exploitation 利用</h3><p>利用的是强化学习所学习到的价值函数 </p><h3 id="Exploration-探索"><a href="#Exploration-探索" class="headerlink" title="Exploration 探索"></a>Exploration 探索</h3><p>我们学习到的价值函数不一定是最优的价值函数，有一些看起来价值不是很高的行动，有可能真实的价值是最高的，我们不仅仅要利用已经学习到的价值函数，还应该去尝试不同的行动，从而优化价值函数。</p><h2 id="K-armed-Bandit-多臂老虎机"><a href="#K-armed-Bandit-多臂老虎机" class="headerlink" title="K-armed Bandit 多臂老虎机"></a>K-armed Bandit 多臂老虎机</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bandit 结构体表示一个 K-armed Bandit</span></span><br><span class="line"><span class="keyword">type</span> Bandit <span class="keyword">struct</span> {</span><br><span class="line">    k     <span class="type">int</span></span><br><span class="line">    means []<span class="type">float64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewBandit 创建一个新的 K-armed Bandit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBandit</span><span class="params">(k <span class="type">int</span>)</span></span> *Bandit {</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    means := <span class="built_in">make</span>([]<span class="type">float64</span>, k)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> means {</span><br><span class="line">       means[i] = rand.NormFloat64() <span class="comment">// 每个臂的奖励服从正态分布</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> &amp;Bandit{</span><br><span class="line">       k:     k,</span><br><span class="line">       means: means,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pull 模拟拉动一个臂并返回奖励</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bandit)</span></span> Pull(arm <span class="type">int</span>) <span class="type">float64</span> {</span><br><span class="line">    <span class="keyword">if</span> arm &lt; <span class="number">0</span> || arm &gt;= b.k {</span><br><span class="line">       <span class="built_in">panic</span>(<span class="string">"invalid arm"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> b.means[arm] + rand.NormFloat64() <span class="comment">// 奖励 = 均值 + 噪声</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// EpsilonGreedy 实现 epsilon-greedy 策略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EpsilonGreedy</span><span class="params">(bandit *Bandit, numPlays <span class="type">int</span>, epsilon <span class="type">float64</span>)</span></span> <span class="type">float64</span> {</span><br><span class="line">    Q := <span class="built_in">make</span>([]<span class="type">float64</span>, bandit.k) <span class="comment">// 每个臂的估计值</span></span><br><span class="line">    N := <span class="built_in">make</span>([]<span class="type">int</span>, bandit.k)     <span class="comment">// 每个臂被拉动的次数</span></span><br><span class="line">    totalReward := <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numPlays; i++ {</span><br><span class="line">       <span class="keyword">var</span> arm <span class="type">int</span></span><br><span class="line">       <span class="keyword">if</span> rand.Float64() &lt; epsilon {</span><br><span class="line">          arm = rand.Intn(bandit.k) <span class="comment">// 随机选择一个臂</span></span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">          arm = argMax(Q) <span class="comment">// 选择当前估计值最大的臂</span></span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       reward := bandit.Pull(arm)</span><br><span class="line">       N[arm]++</span><br><span class="line">       Q[arm] += (reward - Q[arm]) / <span class="type">float64</span>(N[arm]) <span class="comment">// 更新估计值</span></span><br><span class="line">       totalReward += reward</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totalReward</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// argMax 返回数组中最大值的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">argMax</span><span class="params">(slice []<span class="type">float64</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">    maxIndex := <span class="number">0</span></span><br><span class="line">    maxValue := slice[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> slice {</span><br><span class="line">       <span class="keyword">if</span> v &gt; maxValue {</span><br><span class="line">          maxIndex = i</span><br><span class="line">          maxValue = v</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxIndex</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    k := <span class="number">10</span></span><br><span class="line">    numPlays := <span class="number">1000</span></span><br><span class="line">    epsilon := <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">    bandit := NewBandit(k)</span><br><span class="line">    totalReward := EpsilonGreedy(bandit, numPlays, epsilon)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"Total reward after %d plays: %.2f\n"</span>, numPlays, totalReward)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="tic-tac-toe-井字棋"><a href="#tic-tac-toe-井字棋" class="headerlink" title="tic tac toe 井字棋"></a>tic tac toe 井字棋</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 棋盘大小</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    rows = <span class="number">3</span></span><br><span class="line">    cols = <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家符号</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Empty = <span class="string">" "</span></span><br><span class="line">    X     = <span class="string">"X"</span></span><br><span class="line">    O     = <span class="string">"O"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 棋盘类型</span></span><br><span class="line"><span class="keyword">type</span> Board [rows][cols]<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化棋盘</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBoard</span><span class="params">()</span></span> Board {</span><br><span class="line">    <span class="keyword">return</span> Board{</span><br><span class="line">       {Empty, Empty, Empty},</span><br><span class="line">       {Empty, Empty, Empty},</span><br><span class="line">       {Empty, Empty, Empty},</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印棋盘</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Board)</span></span> Print() {</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">       <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">          fmt.Printf(<span class="string">" %s "</span>, b[i][j])</span><br><span class="line">          <span class="keyword">if</span> j &lt; cols<span class="number">-1</span> {</span><br><span class="line">             fmt.Printf(<span class="string">"|"</span>)</span><br><span class="line">          }</span><br><span class="line">       }</span><br><span class="line">       fmt.Println()</span><br><span class="line">       <span class="keyword">if</span> i &lt; rows<span class="number">-1</span> {</span><br><span class="line">          fmt.Println(<span class="string">"-----------"</span>)</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    fmt.Println()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否有玩家获胜</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Board)</span></span> CheckWin(player <span class="type">string</span>) <span class="type">bool</span> {</span><br><span class="line">    <span class="comment">// 检查行</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">       <span class="keyword">if</span> b[i][<span class="number">0</span>] == player &amp;&amp; b[i][<span class="number">1</span>] == player &amp;&amp; b[i][<span class="number">2</span>] == player {</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 检查列</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">       <span class="keyword">if</span> b[<span class="number">0</span>][j] == player &amp;&amp; b[<span class="number">1</span>][j] == player &amp;&amp; b[<span class="number">2</span>][j] == player {</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 检查对角线</span></span><br><span class="line">    <span class="keyword">if</span> b[<span class="number">0</span>][<span class="number">0</span>] == player &amp;&amp; b[<span class="number">1</span>][<span class="number">1</span>] == player &amp;&amp; b[<span class="number">2</span>][<span class="number">2</span>] == player {</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> b[<span class="number">0</span>][<span class="number">2</span>] == player &amp;&amp; b[<span class="number">1</span>][<span class="number">1</span>] == player &amp;&amp; b[<span class="number">2</span>][<span class="number">0</span>] == player {</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查棋盘是否已满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Board)</span></span> IsFull() <span class="type">bool</span> {</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">       <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">          <span class="keyword">if</span> b[i][j] == Empty {</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">          }</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取棋盘状态（用于 Q-learning）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Board)</span></span> GetState() <span class="type">string</span> {</span><br><span class="line">    state := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">       <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">          state += b[i][j]</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Q-learning 智能体</span></span><br><span class="line"><span class="keyword">type</span> QAgent <span class="keyword">struct</span> {</span><br><span class="line">    QTable      <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">float64</span> <span class="comment">// Q 表：状态 -&gt; 动作值</span></span><br><span class="line">    Alpha       <span class="type">float64</span>              <span class="comment">// 学习率</span></span><br><span class="line">    Gamma       <span class="type">float64</span>              <span class="comment">// 折扣因子</span></span><br><span class="line">    Epsilon     <span class="type">float64</span>              <span class="comment">// 探索率</span></span><br><span class="line">    Actions     [][<span class="number">2</span>]<span class="type">int</span>             <span class="comment">// 所有可能的动作</span></span><br><span class="line">    CurrentMove [<span class="number">2</span>]<span class="type">int</span>               <span class="comment">// 当前动作</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Q-learning 智能体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQAgent</span><span class="params">(alpha, gamma, epsilon <span class="type">float64</span>)</span></span> *QAgent {</span><br><span class="line">    <span class="comment">// 初始化所有可能的动作</span></span><br><span class="line">    actions := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">       <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">          actions = <span class="built_in">append</span>(actions, [<span class="number">2</span>]<span class="type">int</span>{i, j})</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> &amp;QAgent{</span><br><span class="line">       QTable:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">float64</span>),</span><br><span class="line">       Alpha:   alpha,</span><br><span class="line">       Gamma:   gamma,</span><br><span class="line">       Epsilon: epsilon,</span><br><span class="line">       Actions: actions,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择动作（epsilon-greedy 策略）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(qa *QAgent)</span></span> ChooseAction(state <span class="type">string</span>, board Board) [<span class="number">2</span>]<span class="type">int</span> {</span><br><span class="line">    <span class="comment">// 初始化 Q 表（如果状态不存在）</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := qa.QTable[state]; !ok {</span><br><span class="line">       qa.QTable[state] = <span class="built_in">make</span>([]<span class="type">float64</span>, <span class="built_in">len</span>(qa.Actions))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 探索：随机选择动作</span></span><br><span class="line">    <span class="keyword">if</span> rand.Float64() &lt; qa.Epsilon {</span><br><span class="line">       emptyCells := [][<span class="number">2</span>]<span class="type">int</span>{}</span><br><span class="line">       <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">          <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">             <span class="keyword">if</span> board[i][j] == Empty {</span><br><span class="line">                emptyCells = <span class="built_in">append</span>(emptyCells, [<span class="number">2</span>]<span class="type">int</span>{i, j})</span><br><span class="line">             }</span><br><span class="line">          }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(emptyCells) &gt; <span class="number">0</span> {</span><br><span class="line">          <span class="keyword">return</span> emptyCells[rand.Intn(<span class="built_in">len</span>(emptyCells))]</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用：选择 Q 值最大的动作</span></span><br><span class="line">    maxQ := qa.QTable[state][<span class="number">0</span>]</span><br><span class="line">    bestAction := qa.Actions[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i, q := <span class="keyword">range</span> qa.QTable[state] {</span><br><span class="line">       <span class="keyword">if</span> q &gt; maxQ &amp;&amp; board[qa.Actions[i][<span class="number">0</span>]][qa.Actions[i][<span class="number">1</span>]] == Empty {</span><br><span class="line">          maxQ = q</span><br><span class="line">          bestAction = qa.Actions[i]</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> bestAction</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 Q 表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(qa *QAgent)</span></span> UpdateQTable(state <span class="type">string</span>, actionIndex <span class="type">int</span>, reward <span class="type">float64</span>, nextState <span class="type">string</span>) {</span><br><span class="line">    <span class="comment">// 初始化 Q 表（如果状态不存在）</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := qa.QTable[nextState]; !ok {</span><br><span class="line">       qa.QTable[nextState] = <span class="built_in">make</span>([]<span class="type">float64</span>, <span class="built_in">len</span>(qa.Actions))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Q-learning 更新公式</span></span><br><span class="line">    maxNextQ := qa.QTable[nextState][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, q := <span class="keyword">range</span> qa.QTable[nextState] {</span><br><span class="line">       <span class="keyword">if</span> q &gt; maxNextQ {</span><br><span class="line">          maxNextQ = q</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    qa.QTable[state][actionIndex] += qa.Alpha * (reward + qa.Gamma*maxNextQ - qa.QTable[state][actionIndex])</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Q-learning 智能体</span></span><br><span class="line">    agent := NewQAgent(<span class="number">0.1</span>, <span class="number">0.9</span>, <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 训练次数</span></span><br><span class="line">    numEpisodes := <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计训练过程</span></span><br><span class="line">    winRates := []<span class="type">float64</span>{}</span><br><span class="line">    drawRates := []<span class="type">float64</span>{}</span><br><span class="line">    loseRates := []<span class="type">float64</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 训练过程</span></span><br><span class="line">    <span class="keyword">for</span> episode := <span class="number">0</span>; episode &lt; numEpisodes; episode++ {</span><br><span class="line">       board := NewBoard()</span><br><span class="line">       currentPlayer := X</span><br><span class="line">       <span class="keyword">var</span> lastState <span class="type">string</span></span><br><span class="line">       <span class="keyword">var</span> lastActionIndex <span class="type">int</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> {</span><br><span class="line">          state := board.GetState()</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Q-learning 智能体（X）的回合</span></span><br><span class="line">          <span class="keyword">if</span> currentPlayer == X {</span><br><span class="line">             action := agent.ChooseAction(state, board)</span><br><span class="line">             board[action[<span class="number">0</span>]][action[<span class="number">1</span>]] = X</span><br><span class="line">             lastState = state</span><br><span class="line">             lastActionIndex = <span class="number">-1</span></span><br><span class="line">             <span class="keyword">for</span> i, a := <span class="keyword">range</span> agent.Actions {</span><br><span class="line">                <span class="keyword">if</span> a == action {</span><br><span class="line">                   lastActionIndex = i</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">                }</span><br><span class="line">             }</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">             <span class="comment">// 随机机器人（O）的回合</span></span><br><span class="line">             emptyCells := [][<span class="number">2</span>]<span class="type">int</span>{}</span><br><span class="line">             <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">                <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">                   <span class="keyword">if</span> board[i][j] == Empty {</span><br><span class="line">                      emptyCells = <span class="built_in">append</span>(emptyCells, [<span class="number">2</span>]<span class="type">int</span>{i, j})</span><br><span class="line">                   }</span><br><span class="line">                }</span><br><span class="line">             }</span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">len</span>(emptyCells) &gt; <span class="number">0</span> {</span><br><span class="line">                action := emptyCells[rand.Intn(<span class="built_in">len</span>(emptyCells))]</span><br><span class="line">                board[action[<span class="number">0</span>]][action[<span class="number">1</span>]] = O</span><br><span class="line">             }</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 检查游戏是否结束</span></span><br><span class="line">          <span class="keyword">if</span> board.CheckWin(X) {</span><br><span class="line">             agent.UpdateQTable(lastState, lastActionIndex, <span class="number">1</span>, board.GetState())</span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> board.CheckWin(O) {</span><br><span class="line">             agent.UpdateQTable(lastState, lastActionIndex, <span class="number">-1</span>, board.GetState())</span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> board.IsFull() {</span><br><span class="line">             agent.UpdateQTable(lastState, lastActionIndex, <span class="number">0</span>, board.GetState())</span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 切换玩家</span></span><br><span class="line">          <span class="keyword">if</span> currentPlayer == X {</span><br><span class="line">             currentPlayer = O</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">             currentPlayer = X</span><br><span class="line">          }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 每 100 次训练统计一次结果</span></span><br><span class="line">       <span class="keyword">if</span> episode%<span class="number">100</span> == <span class="number">0</span> {</span><br><span class="line">          wins, draws, losses := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">          <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">             board := NewBoard()</span><br><span class="line">             currentPlayer := X</span><br><span class="line">             <span class="keyword">for</span> {</span><br><span class="line">                state := board.GetState()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> currentPlayer == X {</span><br><span class="line">                   action := agent.ChooseAction(state, board)</span><br><span class="line">                   board[action[<span class="number">0</span>]][action[<span class="number">1</span>]] = X</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                   emptyCells := [][<span class="number">2</span>]<span class="type">int</span>{}</span><br><span class="line">                   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">                      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">                         <span class="keyword">if</span> board[i][j] == Empty {</span><br><span class="line">                            emptyCells = <span class="built_in">append</span>(emptyCells, [<span class="number">2</span>]<span class="type">int</span>{i, j})</span><br><span class="line">                         }</span><br><span class="line">                      }</span><br><span class="line">                   }</span><br><span class="line">                   <span class="keyword">if</span> <span class="built_in">len</span>(emptyCells) &gt; <span class="number">0</span> {</span><br><span class="line">                      action := emptyCells[rand.Intn(<span class="built_in">len</span>(emptyCells))]</span><br><span class="line">                      board[action[<span class="number">0</span>]][action[<span class="number">1</span>]] = O</span><br><span class="line">                   }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> board.CheckWin(X) {</span><br><span class="line">                   wins++</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> board.CheckWin(O) {</span><br><span class="line">                   losses++</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> board.IsFull() {</span><br><span class="line">                   draws++</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> currentPlayer == X {</span><br><span class="line">                   currentPlayer = O</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                   currentPlayer = X</span><br><span class="line">                }</span><br><span class="line">             }</span><br><span class="line">          }</span><br><span class="line">          winRate := <span class="type">float64</span>(wins) / <span class="number">100</span></span><br><span class="line">          drawRate := <span class="type">float64</span>(draws) / <span class="number">100</span></span><br><span class="line">          loseRate := <span class="type">float64</span>(losses) / <span class="number">100</span></span><br><span class="line">          winRates = <span class="built_in">append</span>(winRates, winRate)</span><br><span class="line">          drawRates = <span class="built_in">append</span>(drawRates, drawRate)</span><br><span class="line">          loseRates = <span class="built_in">append</span>(loseRates, loseRate)</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出训练结果</span></span><br><span class="line">    fmt.Println(<span class="string">"训练完成！"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"胜率变化："</span>, winRates)</span><br><span class="line">    fmt.Println(<span class="string">"平局率变化："</span>, drawRates)</span><br><span class="line">    fmt.Println(<span class="string">"失败率变化："</span>, loseRates)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试训练结果</span></span><br><span class="line">    fmt.Println(<span class="string">"开始测试..."</span>)</span><br><span class="line">    board := NewBoard()</span><br><span class="line">    currentPlayer := X</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">       board.Print()</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> currentPlayer == X {</span><br><span class="line">          <span class="comment">// Q-learning 智能体（X）的回合</span></span><br><span class="line">          action := agent.ChooseAction(board.GetState(), board)</span><br><span class="line">          board[action[<span class="number">0</span>]][action[<span class="number">1</span>]] = X</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">          <span class="comment">// 随机机器人（O）的回合</span></span><br><span class="line">          emptyCells := [][<span class="number">2</span>]<span class="type">int</span>{}</span><br><span class="line">          <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">             <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == Empty {</span><br><span class="line">                   emptyCells = <span class="built_in">append</span>(emptyCells, [<span class="number">2</span>]<span class="type">int</span>{i, j})</span><br><span class="line">                }</span><br><span class="line">             }</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> <span class="built_in">len</span>(emptyCells) &gt; <span class="number">0</span> {</span><br><span class="line">             action := emptyCells[rand.Intn(<span class="built_in">len</span>(emptyCells))]</span><br><span class="line">             board[action[<span class="number">0</span>]][action[<span class="number">1</span>]] = O</span><br><span class="line">          }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检查游戏是否结束</span></span><br><span class="line">       <span class="keyword">if</span> board.CheckWin(X) {</span><br><span class="line">          board.Print()</span><br><span class="line">          fmt.Println(<span class="string">"Q-learning 智能体（X）获胜！"</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">if</span> board.CheckWin(O) {</span><br><span class="line">          board.Print()</span><br><span class="line">          fmt.Println(<span class="string">"随机机器人（O）获胜！"</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">if</span> board.IsFull() {</span><br><span class="line">          board.Print()</span><br><span class="line">          fmt.Println(<span class="string">"平局！"</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 切换玩家</span></span><br><span class="line">       <span class="keyword">if</span> currentPlayer == X {</span><br><span class="line">          currentPlayer = O</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">          currentPlayer = X</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">强化学习速度浅入门</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="学习" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="笔记" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="强化学习" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="强化学习" scheme="https://dra-tammer.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>动手学深度学习</title>
    <link href="https://dra-tammer.github.io/posts/b34b3e68.html"/>
    <id>https://dra-tammer.github.io/posts/b34b3e68.html</id>
    <published>2024-11-29T09:57:23.000Z</published>
    <updated>2025-01-17T14:26:58.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动手学深度学习"><a href="#动手学深度学习" class="headerlink" title="动手学深度学习"></a>动手学深度学习</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>N维数组是机器学习和神经网络的主要数据结构</p><blockquote><p>3-d：RGB图片（宽 * 高 * 通道 ）</p></blockquote><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ol><li>形状</li><li>每个形状的数据类型</li><li>每个元素的值</li></ol><blockquote><p>对于深度学习的话，64位浮点数计算的比较慢，我们一般使用32位浮点数</p></blockquote><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>线性回归可以看成一个单层的神经网络</p><h2 id="小批量随机梯度下降"><a href="#小批量随机梯度下降" class="headerlink" title="小批量随机梯度下降"></a>小批量随机梯度下降</h2><p>SGD</p><blockquote><p>深度学习默认的求解算法</p></blockquote><p>在整个训练集上算梯度太贵</p><p>随机采样b个样本来近似损失</p><p>两个重要的超参数是批量大小和学习率</p><h2 id="回归-分类"><a href="#回归-分类" class="headerlink" title="回归 &amp; 分类"></a>回归 &amp; 分类</h2><ul><li><p>回归估计一个连续值</p><p>单连续数值输出，自然区间，跟真实值的区别作为损失</p></li><li><p>分类预测一个离散类别</p><p>通常是多个输出，输出i是预测为第i类的置信度</p></li></ul><p>MNIST：手写数字识别</p><p>ImageNet：自然物体分类</p><h2 id="从回归到多类分类-均方损失"><a href="#从回归到多类分类-均方损失" class="headerlink" title="从回归到多类分类-均方损失"></a>从回归到多类分类-均方损失</h2><ul><li>对类别进行一位有效编码</li><li>最大值作为预测</li><li>需要更置信的识别正确类（大余量）</li><li>输出匹配概率</li><li>概率y和yba的区别作为损失</li></ul><blockquote><p>指数的好处是不管是什么值都能给他整成非负</p></blockquote><h2 id="Softmax回归"><a href="#Softmax回归" class="headerlink" title="Softmax回归"></a>Softmax回归</h2><ul><li>多类分类模型</li><li>使用Softmax操作了得到每个类的预测置信度</li><li>使用交叉熵来衡量预测和标号的区别</li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h3 id="平方损失（L2-Loss）"><a href="#平方损失（L2-Loss）" class="headerlink" title="平方损失（L2 Loss）"></a>平方损失（L2 Loss）</h3><p>l(y, ypie) = 1 / 2(y - ypie)^2</p><h3 id="绝对值损失函数（L1-Loss）"><a href="#绝对值损失函数（L1-Loss）" class="headerlink" title="绝对值损失函数（L1 Loss）"></a>绝对值损失函数（L1 Loss）</h3><p>预测值和真实值比较远的时候，梯度也是一个常数，更新的幅度不变，稳定性好一点</p><h3 id="鲁棒损失函数（Huber’s-Robust-Loss）"><a href="#鲁棒损失函数（Huber’s-Robust-Loss）" class="headerlink" title="鲁棒损失函数（Huber’s Robust Loss）"></a>鲁棒损失函数（Huber’s Robust Loss）</h3><h3 id="交叉熵损失函数（CrossEntropyLoss）"><a href="#交叉熵损失函数（CrossEntropyLoss）" class="headerlink" title="交叉熵损失函数（CrossEntropyLoss）"></a>交叉熵损失函数（CrossEntropyLoss）</h3><h2 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h2><p><code>fashion-mnist</code></p><p>测试数据集来预测模型的好坏</p><p>训练集的话是要随机的，但是测试集的话就无所谓了</p><p>一个常见的性能瓶颈，GPU训练的比数据读取的要快</p><h2 id="iter"><a href="#iter" class="headerlink" title="iter()"></a>iter()</h2><p>生成迭代器，逐个地遍历一个可迭代对象</p><h2 id="感知机（MLP）"><a href="#感知机（MLP）" class="headerlink" title="感知机（MLP）"></a>感知机（MLP）</h2><p>做一个二分类的问题</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>不能拟合XOR函数，只能产生线性分割面</p><p>XOR（x =  1, y = 1 ; x = -1, y = -1 =&gt; -1）（x =  1, y = -1 ; x = -1, y = 1 =&gt; 1）</p><p>解决方法：多层感知机</p><h2 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h2><h3 id="单隐藏层-单分类"><a href="#单隐藏层-单分类" class="headerlink" title="单隐藏层-单分类"></a>单隐藏层-单分类</h3><p>隐藏层的大小是一个超参数，因为输入输出不是我们能改的</p><p>多层感知机需要有一个非线性激活函数，否则就还是线性模型，也就是单层感知机</p><p>引入激活函数的本质是引入非线性性 </p><h3 id="sigmoid激活函数"><a href="#sigmoid激活函数" class="headerlink" title="sigmoid激活函数"></a>sigmoid激活函数</h3><h3 id="Tanh激活函数"><a href="#Tanh激活函数" class="headerlink" title="Tanh激活函数"></a>Tanh激活函数</h3><h3 id="ReLU激活函数"><a href="#ReLU激活函数" class="headerlink" title="ReLU激活函数"></a>ReLU激活函数</h3><blockquote><p>指数运算是一个很贵的东西</p></blockquote><h3 id="多类分类"><a href="#多类分类" class="headerlink" title="多类分类"></a>多类分类</h3><p>softmax回归加上一个隐藏层就会变成多层感知机</p><p>softmax把所有的输入拉到一个0和1之间的区域，而且y1加到yk等于1</p><h3 id="多隐藏层"><a href="#多隐藏层" class="headerlink" title="多隐藏层"></a>多隐藏层</h3><ul><li>隐藏层数</li><li>每层隐藏层的大小</li></ul><blockquote><p>输出层是不需要激活函数的，因为激活函数是为了避免隐藏层的塌陷</p></blockquote><p>机器学习可以看作一个压缩的过程，如果维度太高的话，要逐渐压缩</p><p>可以先扩张再压缩 </p><blockquote><p>多层感知机使用隐藏层和激活函数来得到非线性模型</p><p>常用的激活函数由sigmoid，tanh，relu</p><p>使用softmax来处理多类分类</p><p>超参数为隐藏层数，和各个隐藏层的大小</p></blockquote><blockquote><p>一个箭头算成一个层</p></blockquote><h2 id="深度神经网络为什么要增加隐藏层的层数，而不是神经元的个数"><a href="#深度神经网络为什么要增加隐藏层的层数，而不是神经元的个数" class="headerlink" title="深度神经网络为什么要增加隐藏层的层数，而不是神经元的个数"></a>深度神经网络为什么要增加隐藏层的层数，而不是神经元的个数</h2><p>因为层数更深，拟合的效果更好，所以叫深度神经网络，如果就一层特别宽的一层，一口吃个大胖子，非常容易过拟合</p><h2 id="训练误差和泛化误差"><a href="#训练误差和泛化误差" class="headerlink" title="训练误差和泛化误差"></a>训练误差和泛化误差</h2><p>关注的是泛化误差</p><p>训练数据集：训练模型参数</p><p>验证数据集：一个用来评估模型好坏的数据集，选择模型的超参数</p><p>非大数据集上通常使用k-折交叉验证</p><ul><li>例如拿出50%的训练数据</li><li>不要跟训练数据混在一起（常犯错误）</li></ul><p>测试数据集：只用一次的数据集，不能用来调整超参数</p><ul><li>未来的考试</li><li>我出价的房子的实际成交价</li><li>用在kaggle私有排行榜中的数据集</li></ul><h2 id="K-折交叉验证（k-fold）"><a href="#K-折交叉验证（k-fold）" class="headerlink" title="K-折交叉验证（k-fold）"></a>K-折交叉验证（k-fold）</h2><ul><li><p>在没有足够多数据时使用</p></li><li><p>算法：</p><ul><li><p>将训练数据分割成k块</p></li><li><p>for i -&gt; k</p><p>使用第i块作为验证数据集，其余的作为训练数据集</p></li></ul></li><li><p>报告k个数据集误差的平均</p></li><li><p>常用：k = 5或者10</p></li></ul><h2 id="模型容量"><a href="#模型容量" class="headerlink" title="模型容量"></a>模型容量</h2><ul><li>拟合各种函数的能力</li><li>低容量的模型难以拟合训练数据</li><li>高容量的模型可以记住所有的训练数据</li></ul><blockquote><p>过拟合不是一件坏的事儿，首先模型容量要足够大，之后通过各种手段控制模型容量，最后得到泛化误差的下降</p></blockquote><blockquote><p>神经网络是一个很灵活的语言，可编程性很好，但是不好理解</p></blockquote><h2 id="权重衰退"><a href="#权重衰退" class="headerlink" title="权重衰退"></a>权重衰退</h2><p>防止过拟合</p><h2 id="丢弃法"><a href="#丢弃法" class="headerlink" title="丢弃法"></a>丢弃法</h2><p>dropout三个值，0.1，0.5，0.9</p><p>更好的解决过拟合的问题</p><p>在层之间加入噪音，随机加上噪音，等价于Tikhnov</p><p>无偏差加入噪音，但是不影响期望</p><p>通常将丢弃法作用在隐藏全连接层的输出</p><p>正则项只在训练中使用，他们影响模型参数的更新（确定w，b），更新参数的时候，使得模型复杂度降低，在推理过程中，丢弃发直接返回输入</p><p>h = dropout(h)<br>这样也能保证确定性的输出</p><ul><li>丢弃发将一些输出项随机置0来控制模型复杂度</li><li>常作用在多层感知机的隐藏层输出上</li><li>丢弃概率是控制模型复杂度的超参数</li></ul><blockquote><p>dropout作用在全连接层的，BN作用在卷积层</p></blockquote><blockquote><p>cnn可以认为是一个特别的MLP</p></blockquote><h2 id="数值稳定性的常见两个问题"><a href="#数值稳定性的常见两个问题" class="headerlink" title="数值稳定性的常见两个问题"></a>数值稳定性的常见两个问题</h2><p>梯度爆炸和梯度消失，因为做了太多了矩阵乘法，梯度值浮点值</p><h3 id="梯度爆炸"><a href="#梯度爆炸" class="headerlink" title="梯度爆炸"></a>梯度爆炸</h3><p>值超出值域，对于16位浮点数尤为严重</p><p>对学习率敏感</p><p>如果学习率太大，大参数值，更大的梯度</p><p>如果学习率太小，训练无进展</p><p>可能需要在训练过程中不断调整学习率</p><blockquote><p>学习率相当于步长，而梯度则是收敛方向</p><p>权重是学习率乘以梯度</p></blockquote><h3 id="梯度消失"><a href="#梯度消失" class="headerlink" title="梯度消失"></a>梯度消失</h3><p>梯度值变成0，对16位浮点数尤为严重</p><p>训练没有进展，不管如何选择学习率</p><p>对于底部曾尤为严重，仅仅顶部层训练的较好，无法让神经网络更深</p><h2 id="让训练更加稳定"><a href="#让训练更加稳定" class="headerlink" title="让训练更加稳定"></a>让训练更加稳定</h2><p>目标：让梯度值在合理的范围里</p><p>将乘法变成加法（resnet）</p><p>归一化：梯度归一化，梯度裁剪</p><h3 id="合理的权重初始和激活函数"><a href="#合理的权重初始和激活函数" class="headerlink" title="合理的权重初始和激活函数"></a>合理的权重初始和激活函数</h3><h4 id="让每层的方差是一个常数"><a href="#让每层的方差是一个常数" class="headerlink" title="让每层的方差是一个常数"></a>让每层的方差是一个常数</h4><ul><li>将每层的输出和梯度都看作随机变量</li><li>让他们的均值和方差都保持一致</li></ul><h4 id="权重初始化"><a href="#权重初始化" class="headerlink" title="权重初始化"></a>权重初始化</h4><ul><li>在合理值区间里随机初始参数</li><li>训练开始的时候更容易有数值不稳定<ul><li>远离最优解的地方损失函数表面可能很复杂</li><li>最优解附近表面会比较平</li></ul></li><li>使用（n，0.01）来初始可能对小网络没问题，但不能保证深度神经网络</li></ul><blockquote><p>合理的权重初始和激活函数的选取可以提升数值稳定性</p></blockquote><h2 id="前向传播和反向传播"><a href="#前向传播和反向传播" class="headerlink" title="前向传播和反向传播"></a>前向传播和反向传播</h2><h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h3><p>简单理解就是将上一层的输出作为下一层的输入，并计算下一层的输出，一直到运算到输出层为止</p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p><strong>反向传播仅指用于计算梯度的方法。</strong>而另一种算法，例如随机梯度下降法，才是使用该梯度来进行学习。<strong>原则上反向传播可以计算任何函数的到导数</strong></p><p>的确就是复合函数的链式法则</p><p>利用链式法则，BP算法则机智地避开了这种冗余，它对于每一个路径只访问一次就能求顶点对所有下层节点的偏导值</p><p>反向(自上往下)来寻找路径的</p><blockquote><p>宇宙的终极答案：42 ——–《银河系漫游指南》</p></blockquote><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><h3 id="两个原则"><a href="#两个原则" class="headerlink" title="两个原则"></a>两个原则</h3><ul><li>平移不变性</li><li>局部性</li></ul><p> 对全连接层使用平移不变性和局部性得到卷积层</p><h3 id="二维交叉相关"><a href="#二维交叉相关" class="headerlink" title="二维交叉相关"></a>二维交叉相关</h3><p>虽说是卷积层但是计算的时候是交叉相关</p><h3 id="一维和三维交叉相关"><a href="#一维和三维交叉相关" class="headerlink" title="一维和三维交叉相关"></a>一维和三维交叉相关</h3><p>一维：文本，语言，时序序列</p><p>三维：视频，医学图像，气象地图</p><blockquote><p>卷积层将输入和核矩阵进行交叉相关，加上偏移后得到输出</p><p>核矩阵和偏移是可学习的参数</p><p>核矩阵的大小是超参数：控制局部性</p><p>不管输入在哪个位置，核是不变的</p></blockquote><p>卷积层可以认为一个特殊的全连接层，解决了权重随着输入的变大变得特别大</p><h3 id="输入维度"><a href="#输入维度" class="headerlink" title="输入维度"></a>输入维度</h3><p>输入维度都是4-D</p><p>（通道数，批量大小数，长，宽）</p><h3 id="感受野"><a href="#感受野" class="headerlink" title="感受野"></a>感受野</h3><p>卷积层深一点，核小一点，效果更好，一般3<em>3或者5</em>5</p><h3 id="填充和步幅"><a href="#填充和步幅" class="headerlink" title="填充和步幅"></a>填充和步幅</h3><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><p>在输入周围添加额外的行/列</p><h4 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h4><p>填充减小的输出大小和层数线性相关</p><p>步幅是指行/列的滑动步长</p><p>高度3，宽度2的步幅</p><p>步幅一般是2</p><p>填充和步幅都是卷积层的超参数</p><p>填充在输入周围添加额外的行/列，来控制输出形状的减少量，步幅是每次滑动核窗口时的步长，可以成倍减少输出形状，减少计算量。</p><blockquote><p>机器学习可以看作一个压缩的算法，永远会丢失信息的，计算机理解的信息压缩到人能理解的范围</p></blockquote><h3 id="多输入输出通道"><a href="#多输入输出通道" class="headerlink" title="多输入输出通道"></a>多输入输出通道</h3><h3 id="多输入通道"><a href="#多输入通道" class="headerlink" title="多输入通道"></a>多输入通道</h3><p>每个通道都有一个卷积核，结果是所有通道卷积结果的和</p><h3 id="多个输出通道"><a href="#多个输出通道" class="headerlink" title="多个输出通道"></a>多个输出通道</h3><p>每个输出通道可以识别特定的模式</p><p>输入通道核识别并组合输入中的模式</p><blockquote><p>输出的通道数时卷积层的超参数</p><p>每个输入通道有独立的二维卷积核，所有通道结果相加得到一个输出通道结果</p><p>每个输出通道有独立的三维卷积核</p></blockquote><p>通道之间是不共享参数，每个通道学习一个特定的模式</p><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><h3 id="背景-作用"><a href="#背景-作用" class="headerlink" title="背景&amp;作用"></a>背景&amp;作用</h3><blockquote><p>卷积层对位置信息太敏感</p></blockquote><p>需要一定程度的平移不变性，照明，物体位置，比例，外观等等因图像而异</p><h4 id="二维最大池化"><a href="#二维最大池化" class="headerlink" title="二维最大池化"></a>二维最大池化</h4><p>返回滑动窗口中的最大值</p><p>池化层和卷积层类似，都具有填充和步幅</p><p>没有可以学习的参数，没有kernel，k</p><p>最每个输入通道应用池化层以获得相应的输出通道，不会作融合</p><p>输出通道数=输入通道数</p><h4 id="平均池化层"><a href="#平均池化层" class="headerlink" title="平均池化层"></a>平均池化层</h4><p>最大池化层：每个窗口中间最强的模式信号</p><p>平均池化层：将最大池化层中的“最大”操作替换为“平均”</p><blockquote><p>缓解卷积层对位置的敏感性</p><p>同样有窗口大小，填充，步幅作为超参数，对每个通道作用直接输出</p></blockquote><p>池化层用的越来越少</p><h2 id="正向传播和反向传播"><a href="#正向传播和反向传播" class="headerlink" title="正向传播和反向传播"></a>正向传播和反向传播</h2><ul><li><strong>前向传播（Forward Propagation）</strong>前向传播就是从input，经过一层层的layer，不断计算每一层的z和a，最后得到输出y^ 的过程，计算出了y^，就可以根据它和真实值y的差别来计算损失（loss）。</li><li><strong>反向传播（Backward Propagation）</strong>反向传播就是根据损失函数L(y^,y)来反方向地计算每一层的z、a、w、b的偏导数（梯度），从而更新参数。</li><li>每经过一次前向传播和反向传播之后，参数就更新一次，然后用新的参数再次循环上面的过程。这就是神经网络训练的整个过程。</li></ul><blockquote><p>高宽减半的时候通道数可以翻倍，同样一个像素的表示的信息要增加，所以要增加通道数，   </p></blockquote><h3 id="卷积层可学习的参数的个数"><a href="#卷积层可学习的参数的个数" class="headerlink" title="卷积层可学习的参数的个数"></a>卷积层可学习的参数的个数</h3><p>输入通道数 * 输出通道数 * kernel（卷积核）的大小&lt;3 * 3&gt;</p><h2 id="Alexnet"><a href="#Alexnet" class="headerlink" title="Alexnet"></a>Alexnet</h2><p>更深更大的Lenet</p><p>主要改进：</p><ul><li>丢弃法</li><li>ReLU</li><li>MaxPooling</li></ul><h3 id="计算机视觉方法论的改变："><a href="#计算机视觉方法论的改变：" class="headerlink" title="计算机视觉方法论的改变："></a>计算机视觉方法论的改变：</h3><p>从人工特征提取到端到端的学习，从原始的信息到最后的分类，神经网络一路走过去</p><h2 id="NiN"><a href="#NiN" class="headerlink" title="NiN"></a>NiN</h2><blockquote><p>完全不用全连接层</p></blockquote><h3 id="NiN块"><a href="#NiN块" class="headerlink" title="NiN块"></a>NiN块</h3><p>一个卷积层后跟两个全连接层</p><ul><li>步幅1，无填充，输出形状跟卷积层输出一样，1 * 1的卷积层起到全连接层的作用</li></ul><p>无全连接层，交替使用NiN块和步幅为2的最大池化层（宽高减半）逐步减少高宽和增大通道数</p><p>最后使用全局平均池化层得到输出，其输入通道数类别数</p><blockquote><p>NiN块使用卷积层加两个1 * 1卷积层</p><p>后者对每个像素增加了非线性性</p><p>NiN使用全局平局池化层来替代VGG和AlexNet中的全连接层</p><p>不容易过拟合，更少的参数个数</p></blockquote><h3 id="全局池化层"><a href="#全局池化层" class="headerlink" title="全局池化层"></a>全局池化层</h3><p>能够把模型复杂度降低，提升模型的泛化性，让精度变得更好。</p><p>让收敛变慢</p><h2 id="GoogLeNet"><a href="#GoogLeNet" class="headerlink" title="GoogLeNet"></a>GoogLeNet</h2><p>5段，9个<code>inception</code>块</p><p><code>inception</code>不改变高宽，只改变通道数</p><p>MaxPool可以降低高宽</p><h2 id="批量归一化"><a href="#批量归一化" class="headerlink" title="批量归一化"></a>批量归一化</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>损失出现在最后，后面的层训练较快</li><li>数据在最底部<ul><li>底部的层训练较慢</li><li>底部曾一变化，所有都得跟着变</li><li>最后的那些曾需要重新学习多次</li><li>导致收敛变慢</li></ul></li></ul><h3 id="批量归一化层"><a href="#批量归一化层" class="headerlink" title="批量归一化层"></a>批量归一化层</h3><ul><li>可学习得参数为y和b</li><li>作用在<ul><li>全连接层和卷积层得输出上，激活函数前</li><li>全连接层和卷积层输入上</li></ul></li><li>对全连接层，作用在特征维</li><li>对卷积层，作用在通道维</li></ul><p>批量归一化固定小批量中得均值和方差，然后学习出适合得偏移和缩放</p><p>可以加速收敛速度，但一般不改变模型精度</p><h2 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h2><p>ResNet沿用了VGG完整的3×33×3卷积层设计。 残差块里首先有2个有相同输出通道数的3×33×3卷积层。 每个卷积层后接一个批量规范化层和ReLU激活函数。 然后我们通过跨层数据通路，跳过这2个卷积运算，将输入直接加在最后的ReLU激活函数前。 这样的设计要求2个卷积层的输出与输入形状一样，从而使它们可以相加。 如果想改变通道数，就需要引入一个额外的1×11×1卷积层来将输入变换成需要的形状后再做相加运算。</p><p><code>residual</code>残留的；剩余的</p><ul><li>残差块使得很深得网络更加容易训练</li><li>甚至可以训练一千层的网络</li><li>残差网络对随后的深层神经网络设计产生了深远影响，无论是卷积类网络还是全连接网络</li></ul><h3 id="残差块结构："><a href="#残差块结构：" class="headerlink" title="残差块结构："></a>残差块结构：</h3><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/resnet_block.png" alt="resnet_block"></p><p>​         </p><h2 id="单机多卡并行"><a href="#单机多卡并行" class="headerlink" title="单机多卡并行"></a>单机多卡并行</h2><ul><li>一台机器可以安装多个GPU</li><li>在训练和预测的时候，我们将一个小批量计算切分到多个GPU上来达到加速目的</li><li>常用的切分方案有<ul><li>数据并行</li><li>模型并行</li><li>通道并行（数据+模型并行）</li></ul></li></ul><h3 id="数据并行"><a href="#数据并行" class="headerlink" title="数据并行"></a>数据并行</h3><p>将小批量分成n块，每个GPU拿到完整参数计算一块数据的梯度</p><p>通常性能更好</p><h3 id="模型并行"><a href="#模型并行" class="headerlink" title="模型并行"></a>模型并行</h3><p>将模型分成n块，每个GPU拿到一块模型计算它的前向和后向结果，通常用于模型大到放不下</p><p>当一个模型能用单卡计算时，通常使用数据并行拓展到多卡上，模型并行则用在超大模型上</p><h2 id="数据增广"><a href="#数据增广" class="headerlink" title="数据增广"></a>数据增广</h2><p>数据增广通过变形数据来获取多样性从而使得模型泛化性能更好，常见图片增广包括反转，切割，变色</p><p>理论上，原始数据的多样性足够好，就用不着做增广</p><p>增广没有改变分布，可能是增大了方差&gt;</p><h2 id="微调（fine-tuning）"><a href="#微调（fine-tuning）" class="headerlink" title="微调（fine-tuning）"></a>微调（fine-tuning）</h2><blockquote><p>迁移学习的常规技巧</p></blockquote><h3 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h3><ul><li>一个神经网络一般可以分成两块<ul><li>特征抽取将原始像素变成容易线性分割的特征</li><li>线性分类器来做分类</li></ul></li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>微调包括以下四个步骤</p><ol><li>在源数据集（例如ImageNet数据集）上预训练神经网络模型，即<em>源模型</em>。</li><li>创建一个新的神经网络模型，即<em>目标模型</em>。这将复制源模型上的所有模型设计及其参数（输出层除外）。我们假定这些模型参数包含从源数据集中学到的知识，这些知识也将适用于目标数据集。我们还假设源模型的输出层与源数据集的标签密切相关；因此不在目标模型中使用该层。</li><li>向目标模型添加输出层，其输出数是目标数据集中的类别数。然后随机初始化该层的模型参数。</li><li>在目标数据集（如椅子数据集）上训练目标模型。输出层将从头开始进行训练，而所有其他层的参数将根据源模型的参数进行微调。</li></ol><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><ul><li>是一个目标数据集上的正常训练任务</li><li>使用更强的正则化<ul><li>使用更小的学习率</li><li>使用更少的数据迭代</li></ul></li><li>源数据集远复杂于目标数据，通常微调效果更好</li></ul><h3 id="重用分类器权重"><a href="#重用分类器权重" class="headerlink" title="重用分类器权重"></a>重用分类器权重</h3><ul><li>源数据集可能也有目标数据中的部分标号</li><li>可以使用预训练好模型分类器中对应标号对应的向量来做初始化</li></ul><h3 id="固定一些层"><a href="#固定一些层" class="headerlink" title="固定一些层"></a>固定一些层</h3><ul><li><p>神经网络通常学习有层次的特征表示</p><ul><li>低层次的特征更加通用</li><li>高层次的特征则更跟数据集相关</li></ul></li><li><p>可以固定底部的一些层的参数，不参与更新</p><blockquote><p>模型复杂度变低</p></blockquote></li><li><p>更强的正则</p></li></ul><blockquote><p>微调通过使用在大数据上得到的预训练好的模型来初始化模型权重来完成提升精度</p><p>预训练模型质量很重要</p><p>微调通常速度更快，精度更高</p></blockquote><h2 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h2><blockquote><p>物体检测识别图片里的多个物体的类别和位置</p><p>位置通常用边缘框表示</p></blockquote><h3 id="边缘框"><a href="#边缘框" class="headerlink" title="边缘框"></a>边缘框</h3><p>一个边缘框可以通过4个数字定义</p><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/edge_dot.png"></p><blockquote><p>标注的成本很高</p></blockquote><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ul><li>每行表示一个物体<ul><li>图片文件名，物体类别，边缘框</li></ul></li><li>COCO（cocodataset.org）<ul><li>80物体，330k图片，1.5M物体</li></ul></li></ul><h2 id="锚框"><a href="#锚框" class="headerlink" title="锚框"></a>锚框</h2><p>一类目标检测算法是基于锚框</p><ul><li>提出多个被称为锚框的区域（边缘框）</li><li>预测每个锚框里是否含有关注的物体</li><li>如果是，预测从这个锚框到真实边缘框的偏移</li></ul><h3 id="IoU"><a href="#IoU" class="headerlink" title="IoU"></a>IoU</h3><blockquote><p>交并比</p></blockquote><h3 id="赋予锚框标号"><a href="#赋予锚框标号" class="headerlink" title="赋予锚框标号"></a>赋予锚框标号</h3><ul><li>每个锚框是一个训练样本</li><li>将每个锚框， 要么标注成背景，要么关联上一个真实边缘框</li><li>我们可能会生成大量的锚框，这个导致大量的负类样本</li></ul><h3 id="使用非极大值抑制（NMS）输出"><a href="#使用非极大值抑制（NMS）输出" class="headerlink" title="使用非极大值抑制（NMS）输出"></a>使用非极大值抑制（NMS）输出</h3><ul><li>每个锚框预测一个边缘框</li><li>NMS可以合并相似的预测<ul><li>选中非背景类的最大预测值</li><li>去掉所有其他和它IoU值大于西塔的预测</li><li>重复上述过程直到所有预测要么被选中，要么被丢掉</li></ul></li></ul><blockquote><p>预测值：对于那个类的softmax置信值</p></blockquote><p>在预测时，使用NMS来去掉冗余的预测</p><h2 id="编码器-解码器"><a href="#编码器-解码器" class="headerlink" title="编码器&amp;解码器"></a>编码器&amp;解码器</h2><h3 id="重新考察CNN"><a href="#重新考察CNN" class="headerlink" title="重新考察CNN"></a>重新考察CNN</h3><ul><li>编码器：将输入编程成中间表达形式（特征）</li><li>解码器：将中间表示解码成输出</li></ul><h3 id="重新考察RNN"><a href="#重新考察RNN" class="headerlink" title="重新考察RNN"></a>重新考察RNN</h3><ul><li>编码器：将文本表示成向量</li><li>解码器：：向量表示成输出</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>一个模型被分为两块</p><p>编码器处理输出</p><p>解码器生成输出</p><p>其中Decoder也可以拿到输入</p><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/encoderDecoder.png"></p><h2 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h2><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><h3 id="d2l图片不显示"><a href="#d2l图片不显示" class="headerlink" title="d2l图片不显示"></a>d2l图片不显示</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示图像的代码末尾加上</span></span><br><span class="line">d2l.plt.show();</span><br></pre></td></tr></tbody></table></figure><h3 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网络参量进行反馈时，梯度是累计计算而不是被替换，但在处理每一个batch时并不需要与其他batch的梯度混合起来计算，因此对每个batch调用一遍zero_grad将参数梯度置0</span></span><br><span class="line">optimizer.zero_grad()</span><br><span class="line"><span class="comment"># 将输入数据，标签加载到内存</span></span><br><span class="line">X, y = X.to(device), y.to(device)</span><br><span class="line"><span class="comment"># 前向传播计算预测值</span></span><br><span class="line">y_hat = net(X)</span><br><span class="line"><span class="comment"># 计算当前损失</span></span><br><span class="line">l = loss(y_hat, y)</span><br><span class="line"><span class="comment"># 反向传播计算精度</span></span><br><span class="line">l.backward()</span><br><span class="line"><span class="comment"># 更新所有参数</span></span><br><span class="line">optimizer.step()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">d2l（李沐）课程精简笔记</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="pytorch" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/pytorch/"/>
    
    <category term="python" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/pytorch/python/"/>
    
    <category term="学习" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/pytorch/python/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="笔记" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/pytorch/python/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="pytorch" scheme="https://dra-tammer.github.io/tags/pytorch/"/>
    
    <category term="python" scheme="https://dra-tammer.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pytorch_lea</title>
    <link href="https://dra-tammer.github.io/posts/97340e65.html"/>
    <id>https://dra-tammer.github.io/posts/97340e65.html</id>
    <published>2024-10-17T08:19:14.000Z</published>
    <updated>2024-12-02T13:59:51.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pytoch"><a href="#pytoch" class="headerlink" title="pytoch"></a>pytoch</h1><h2 id="当下未成功解决的问题"><a href="#当下未成功解决的问题" class="headerlink" title="当下未成功解决的问题"></a>当下未成功解决的问题</h2><h3 id="ssh-clone"><a href="#ssh-clone" class="headerlink" title="ssh clone"></a>ssh clone</h3><blockquote><p>太看脸了，有时候会成功，有时候会失败，跟配置代理关联不大，仅成功过两次</p></blockquote><p>git clone无法使用ssh，但是https正常clone，代码push也是正常提交，ssh连接也建立成功</p><h3 id="tensorboard"><a href="#tensorboard" class="headerlink" title="tensorboard"></a>tensorboard</h3><p>下载tensorboard之后会一直报错，说是找不到相应的库，按照需要的依赖一个一个安装之后还是报错，程序能够运行，能够生成logs文件，但是tensorboard显示图像出现问题</p><h2 id="有序地管理环境"><a href="#有序地管理环境" class="headerlink" title="有序地管理环境"></a>有序地管理环境</h2><blockquote><p>conda可以创建一个盒子，里面的环境配置独立</p></blockquote><p>创建环境</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pytorch python=<span class="number">3.8</span></span><br></pre></td></tr></tbody></table></figure><p>n是name的意思，后面输入环境的名称</p><p>激活环境</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate pytorch</span><br></pre></td></tr></tbody></table></figure><p>查看工具包</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="built_in">list</span> | conda <span class="built_in">list</span></span><br></pre></td></tr></tbody></table></figure><p>删除环境及其依赖</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env remove -n <span class="string">"envname"</span></span><br></pre></td></tr></tbody></table></figure><p>清理环境，释放磁盘空间</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda clean --all</span><br></pre></td></tr></tbody></table></figure><p>conda clean –all操作不会直接影响已经创建的虚拟环境。该命令主要用于清理conda缓存目录中的下载的包文件、索引文件和不必要的缓存文件，以释放磁盘空间。</p><p>已经创建的虚拟环境包含在磁盘上的特定目录中，而conda clean –all操作不会直接删除这些虚拟环境目录或其中的包。这意味着你的虚拟环境和其中已安装的包将保持不变。</p><p>然而，清理操作可能会影响你的使用体验。如果你清理了缓存文件和索引文件，那么在以后的包安装和更新过程中，conda可能会重新下载这些文件，可能会稍微增加一些下载时间。</p><p>总之，conda clean –all操作主要针对conda缓存目录中的文件，不会直接影响已经创建的虚拟环境和其中的包。如果你只关注已经创建的虚拟环境，可以放心使用该命令来释放磁盘空间。</p><h2 id="pip换源"><a href="#pip换源" class="headerlink" title="pip换源"></a>pip换源</h2><p>Windows：</p><p>文件管理器文件路径地址栏敲：<code>%APPDATA%</code> 回车，快速进入 <code>C:\Users\电脑用户\AppData\Roaming</code> 文件夹中 2、新建 pip 文件夹并在文件夹中新建 <code>pip.ini</code> 配置文件 3、我们需要在<code>pip.ini</code> 配置文件内容，我们可以选择使用记事本打开，输入以下内容，并按下ctrl+s保存，在这里我们使用的是豆瓣源为例子。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">use-mirrors =true</span><br><span class="line">trusted-host = https://pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></tbody></table></figure><p>查看 镜像地址：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 config list   </span><br><span class="line">global.index-url='https://pypi.tuna.tsinghua.edu.cn/simple'</span><br><span class="line">install.trusted-host='https://pypi.tuna.tsinghua.edu.cn'</span><br></pre></td></tr></tbody></table></figure><h2 id="conda换源"><a href="#conda换源" class="headerlink" title="conda换源"></a>conda换源</h2><p>Windows系统：</p><p>TUNA 提供了 Anaconda 仓库与第三方源的镜像，各系统都可以通过修改用户目录下的 <code>.condarc</code> 文件。Windows 用户无法直接创建名为 <code>.condarc</code> 的文件，可先执行<code>conda config --set show_channel_urls yes</code>生成该文件之后再修改。</p><p>完成这一步后，我们需要修改<code>C:\Users\User_name\.condarc</code>这个文件，打开后将文件里原始内容删除，将下面的内容复制进去并保存。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br></pre></td></tr></tbody></table></figure><p>这一步完成后，我们需要打开<code>Anaconda Prompt</code> 运行 <code>conda clean -i</code> 清除索引缓存，保证用的是镜像站提供的索引。</p><h2 id="环境内安装pytoch"><a href="#环境内安装pytoch" class="headerlink" title="环境内安装pytoch"></a>环境内安装pytoch</h2><blockquote><p><strong>NOTE:</strong> Latest PyTorch requires Python 3.8 or later.</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio pytorch-cuda=<span class="number">12.4</span> -c pytorch -c nvidia</span><br></pre></td></tr></tbody></table></figure><h2 id="查看显卡支持的cuda版本"><a href="#查看显卡支持的cuda版本" class="headerlink" title="查看显卡支持的cuda版本"></a>查看显卡支持的cuda版本</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></tbody></table></figure><h2 id="jupyter"><a href="#jupyter" class="headerlink" title="jupyter"></a>jupyter</h2><p>安装的时候安装在了base环境下</p><p>在pytorch环境中安装jupyter</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install jupyter notebook</span><br></pre></td></tr></tbody></table></figure><p>命令行下启动jupyter</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></tbody></table></figure><p>打开D盘下的工作目录，先切换，再打开jupyter</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pytorch) C:\Users\tammer&gt;D:</span><br></pre></td></tr></tbody></table></figure><h2 id="三种编写代码的环境"><a href="#三种编写代码的环境" class="headerlink" title="三种编写代码的环境"></a>三种编写代码的环境</h2><h3 id="py文件"><a href="#py文件" class="headerlink" title="py文件"></a>py文件</h3><p>代码是以块为一个整体的话，py中代码出现问题就要从头开始执行</p><blockquote><p>通用，传播方便，适用于大型项目</p><p>需要从头运行</p></blockquote><h3 id="jupyter-1"><a href="#jupyter-1" class="headerlink" title="jupyter"></a>jupyter</h3><p>人为地分块，也就是以任意块进行运行的</p><blockquote><p>利于代码阅读及修改</p><p>环境需要配置</p></blockquote><h3 id="python-console"><a href="#python-console" class="headerlink" title="python console"></a>python console</h3><p>以每一行为块或者任意块执行的，一行出现问题，解决之后继续执行</p><blockquote><p>显示每个变量属性</p><p>不利于代码阅读及修改</p></blockquote><h2 id="两大法宝函数"><a href="#两大法宝函数" class="headerlink" title="两大法宝函数"></a>两大法宝函数</h2><h3 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h3><p>工具箱以及工具箱中的分隔区有什么东西</p><p>也就是看方法里面有什么可以调用的函数，或者理解说查看这个对象里面的内容，查看这个分隔区中还有没有其他的分隔区</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.cuda.is_available()</span><br><span class="line">Out[<span class="number">4</span>]: <span class="literal">True</span></span><br><span class="line"><span class="built_in">dir</span>(torch)</span><br><span class="line">Out[<span class="number">5</span>]: </span><br><span class="line">[<span class="string">'AVG'</span>,</span><br><span class="line"> <span class="string">'AggregationType'</span>,</span><br><span class="line"> <span class="string">'AliasDb'</span>,</span><br><span class="line"> <span class="string">'Any'</span>,......]</span><br><span class="line"><span class="built_in">dir</span>(torch.cuda.is_available)</span><br><span class="line">Out[<span class="number">6</span>]: </span><br><span class="line">[<span class="string">'__annotations__'</span>,</span><br><span class="line">......</span><br><span class="line"> <span class="string">'__subclasshook__'</span>]</span><br><span class="line"> <span class="comment"># 下划线就是不可修改的说明这个is_available不再是一个分隔区，而是一个函数，即可使用help查看使用方法</span></span><br></pre></td></tr></tbody></table></figure><h3 id="help"><a href="#help" class="headerlink" title="help()"></a>help()</h3><p>知道每个工具是如何使用的，工具的使用方法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span>(torch.cuda.is_available)</span><br><span class="line">Help on function is_available <span class="keyword">in</span> module torch.cuda:</span><br><span class="line">is_available() -&gt; <span class="built_in">bool</span></span><br><span class="line">    Return a <span class="built_in">bool</span> indicating <span class="keyword">if</span> CUDA <span class="keyword">is</span> currently available.</span><br><span class="line"><span class="comment"># 官方解释的函数用法</span></span><br><span class="line">或者</span><br><span class="line">Dataset??</span><br></pre></td></tr></tbody></table></figure><h2 id="pytorch加载数据"><a href="#pytorch加载数据" class="headerlink" title="pytorch加载数据"></a>pytorch加载数据</h2><p>PyTorch数据读入是通过Dataset+DataLoader的方式完成的，Dataset定义好数据的格式和数据变换形式，DataLoader用iterative的方式不断读入批次数据。</p><h3 id="Dateset"><a href="#Dateset" class="headerlink" title="Dateset"></a>Dateset</h3><p>提供一种方式去获取数据及其label，还能进行编号</p><ul><li>如何获取每一个数据及其label</li><li>告诉我们总共有多少个数据</li></ul><p>可以定义自己的Dataset类来实现灵活的数据读取，定义的类需要继承PyTorch自身的Dataset类。主要包含三个函数：</p><ul><li><code>__init__</code>: 用于向类中传入外部参数，同时定义样本集</li><li><code>__getitem__</code>: 用于逐个读取样本集合中的元素，可以进行一定的变换，并将返回训练/验证所需的数据</li><li><code>__len__</code>: 用于返回数据集的样本数</li></ul><h3 id="Dateloader"><a href="#Dateloader" class="headerlink" title="Dateloader"></a>Dateloader</h3><p>对数据进行打包，为后面的网络提供不同的数据形式</p><p>构建好Dataset后，就可以使用DataLoader来按批次读入数据了，实现代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_data, batch_size=batch_size, num_workers=<span class="number">4</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line">val_loader = torch.utils.data.DataLoader(val_data, batch_size=batch_size, num_workers=<span class="number">4</span>, shuffle=<span class="literal">False</span>)</span><br></pre></td></tr></tbody></table></figure><p>其中:</p><ul><li>batch_size：样本是按“批”读入的，batch_size就是每次读入的样本数</li><li>num_workers：有多少个进程用于读取数据，Windows下该参数设置为0，Linux下常见的为4或者8，根据自己的电脑配置来设置</li><li>shuffle：是否将读入的数据打乱，一般在训练集中设置为True，验证集中设置为False</li><li>drop_last：对于样本最后一部分没有达到批次数的样本，使其不再参与训练</li></ul><p>这里可以看一下我们的加载的数据。PyTorch中的DataLoader的读取可以使用next和iter来完成</p><h2 id="torchvision"><a href="#torchvision" class="headerlink" title="torchvision"></a>torchvision</h2><p>target有时候就是label的编号</p><blockquote><p>The <a href="https://pytorch.org/vision/stable/index.html#module-torchvision"><code>torchvision</code></a> package consists of popular datasets, model architectures, and common image transformations for computer vision.</p></blockquote><h2 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a>opencv</h2><p>OpenCV可以用于处理数字图像和视频数据，其功能包括图像和视频的读取、写入、显示、变换、滤波、特征提取、目标检测、人脸识别、物体跟踪、相机标定、三维重建、机器学习等。</p><p>当今，计算机视觉在各种应用领域中都扮演着重要的角色，如自动驾驶、智能家居、医学影像、机器人视觉等，而OpenCV则作为计算机视觉领域的重要工具之一，为这些应用领域提供了丰富的功能和算法支持。</p><p>OpenCV最初由Intel开发，现在已经成为了一个开源项目，其源代码可以免费获取和使用。OpenCV提供了许多计算机视觉中常用的算法和工具，例如：</p><ul><li><p>读取和保存图像和视频数据</p></li><li><p>图像和视频的显示、缩放、剪切和旋转等操作</p></li><li><p>直方图均衡化、图像滤波和形态学操作等图像处理技术</p></li><li><p>特征提取和描述符匹配算法，如SIFT和SURF等</p></li><li><p>目标检测和跟踪算法，如Haar Cascade和MeanShift等</p></li><li><p>人脸检测和识别算法，如LBPH和FisherFace等</p></li><li><p>相机标定和三维重建算法，如SfM和PnP等</p></li><li><p>机器学习算法，如SVM、KNN和随机森林等</p></li></ul><p>除了以上的功能，OpenCV还有一个重要的特点就是跨平台性，可以在Windows、Linux、macOS等操作系统上运行，并且支持多种编程语言，如C++、Python和Java等。</p><p>总之，OpenCV作为一个强大的计算机视觉库，在实现计算机视觉应用的过程中，可以节省开发者大量的时间和精力，提高开发效率和准确性，因此受到了广大开发者的欢迎和使用。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></tbody></table></figure><h2 id="windows中的转译"><a href="#windows中的转译" class="headerlink" title="windows中的转译"></a>windows中的转译</h2><blockquote><p>hymenoptera_data/train/ants/0013035.jpg</p></blockquote><blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_path = "hymenoptera_data\\trainants\\0013035.jpg"</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="tensorboard的使用-未成功"><a href="#tensorboard的使用-未成功" class="headerlink" title="tensorboard的使用(未成功)"></a>tensorboard的使用(未成功)</h2><p>它提供机器学习实验所需的可视化功能和工具</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br></pre></td></tr></tbody></table></figure><p>查看log</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=logs --port=<span class="number">6007</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade tensorboard</span><br><span class="line"><span class="comment"># 有时候版本不兼容，卸载掉重新安装即可</span></span><br><span class="line">pip uninstall protobuf</span><br><span class="line">pip install protobufz</span><br></pre></td></tr></tbody></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote><p>‘SSLError(SSLZeroReturnError(6, ‘TLS/SSL connection has been closed (EOF)</p></blockquote><p>关闭代理</p><p>更换成了阿里源</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line">index-url=https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></tbody></table></figure><h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><p>NumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</p><p>NumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含：</p><ul><li>一个强大的N维数组对象 ndarray</li><li>广播功能函数</li><li>整合 C/C++/Fortran 代码的工具</li><li>线性代数、傅里叶变换、随机数生成等功能</li></ul><h2 id="tensor"><a href="#tensor" class="headerlink" title="tensor"></a>tensor</h2><blockquote><p>张量</p></blockquote><p>从本章开始，我们将开始介绍PyTorch基础知识，本章我们将介绍张量，以帮助大家建立起对数据的描述，随后我们再介绍张量的运算，最后再讲PyTorch中所有神经网络的核心包 <code>autograd </code>，也就是自动微分，了解完这些内容我们就可以较好地理解PyTorch代码了。在深度学习中，我们通常将数据以张量的形式进行表示，比如我们用三维张量表示一个RGB图像，四维张量表示视频。</p><p>一个图像可以用三个字段表示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(width, height, channel) = 3D</span><br></pre></td></tr></tbody></table></figure><p>但是，在机器学习工作中，我们经常要处理不止一张图片或一篇文档——我们要处理一个集合。我们可能有10,000张郁金香的图片，这意味着，我们将用到4D张量：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(batch_size, width, height, channel) = 4D</span><br></pre></td></tr></tbody></table></figure><p><code>Tensor</code> 提供GPU计算和自动求梯度等更多功能，这些使 <code>Tensor</code> 这一数据类型更加适合深度学习。</p><h2 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h2><blockquote><p>现在的主流方式是<strong>数据并行</strong>的方式(Data parallelism)</p></blockquote><p>第三种方式有点不一样，它的逻辑是，我不再拆分模型，我训练的时候模型都是一整个模型。但是我将输入的数据拆分。所谓的拆分数据就是，同一个模型在不同GPU中训练一部分数据，然后再分别计算一部分数据之后，只需要将输出的数据做一个汇总，然后再反传。</p><h2 id="使用CUDA加速训练"><a href="#使用CUDA加速训练" class="headerlink" title="使用CUDA加速训练"></a>使用CUDA加速训练</h2><p>单卡训练</p><p>在PyTorch框架下，CUDA的使用变得非常简单，我们只需要显式的将数据和模型通过<code>.cuda()</code>方法转移到GPU上就可加速我们的训练。如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">model = Net()</span><br><span class="line">model.cuda() # 模型显示转移到CUDA上</span><br><span class="line"></span><br><span class="line">for image,label in dataloader:</span><br><span class="line">    # 图像和标签显示转移到CUDA上</span><br><span class="line">    image = image.cuda() </span><br><span class="line">    label = label.cuda()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">学习pytorch</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="pytorch" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/pytorch/"/>
    
    <category term="python" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/pytorch/python/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="pytorch" scheme="https://dra-tammer.github.io/tags/pytorch/"/>
    
    <category term="python" scheme="https://dra-tammer.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>machine-learning</title>
    <link href="https://dra-tammer.github.io/posts/da37838d.html"/>
    <id>https://dra-tammer.github.io/posts/da37838d.html</id>
    <published>2024-10-17T08:16:30.000Z</published>
    <updated>2024-12-02T14:01:34.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><blockquote><p>计算机无需明确编程即可学习的研究领域</p></blockquote><h2 id="人工智能的术语"><a href="#人工智能的术语" class="headerlink" title="人工智能的术语"></a>人工智能的术语</h2><ul><li>训练集(training set)：用于训练模型的数据集</li><li>输入变量/输入特征(input)：x</li><li>目标变量/输出变量：y</li><li>预测的目标变量：y-hat</li><li>训练数据的总数：m</li><li>单个训练示例：(x, y)</li><li>第几个训练数据：(x<sup>(i)</sup>, y<sup>(i)</sup>)</li></ul><h2 id="监督学习-supervised-learning"><a href="#监督学习-supervised-learning" class="headerlink" title="监督学习(supervised learning)"></a>监督学习(supervised learning)</h2><blockquote><p>当下创造经济价值最多的机器学习形式是监督学习</p></blockquote><p>在监督学习中，数据同时带有输入x和输入标签y</p><p>学习预测输入、输出或者X到Y的映射</p><h3 id="回归算法-regression"><a href="#回归算法-regression" class="headerlink" title="回归算法(regression)"></a>回归算法(regression)</h3><p>学习预测数字，无限多的可能数</p><h3 id="分类算法-classification"><a href="#分类算法-classification" class="headerlink" title="分类算法(classification)"></a>分类算法(classification)</h3><p>输出的可能性是有限的，一组有限的输出类别，通过拟合算法找到一条分界线</p><h2 id="无监督学习-unsupervised-learning"><a href="#无监督学习-unsupervised-learning" class="headerlink" title="无监督学习(unsupervised learning)"></a>无监督学习(unsupervised learning)</h2><blockquote><p>最广泛使用的机器学习形式是无监督学习</p></blockquote><p>不试图监督算法为了给每个输入提供一些正确的答案，相反，我们要求我们的空间自己弄清楚什么是有趣的，或者这个数据中可能有什么模式或者结构。人们没有提前为算法给出示例的正确答案。</p><p>在无监督学习中，数据仅带有输入x而没有输出标签y，而且算法必须发现数据中的某种结构或者某种模式或者某些有趣的东西</p><h3 id="聚类算法-clustering"><a href="#聚类算法-clustering" class="headerlink" title="聚类算法(clustering)"></a>聚类算法(clustering)</h3><p>就是一种无监督学习，将相似的数据点分组</p><h3 id="异常检测-anomaly-detection"><a href="#异常检测-anomaly-detection" class="headerlink" title="异常检测(anomaly detection)"></a>异常检测(anomaly detection)</h3><p>检测异常事件</p><h3 id="降维-dimensionality-reduction"><a href="#降维-dimensionality-reduction" class="headerlink" title="降维(dimensionality reduction)"></a>降维(dimensionality reduction)</h3><p>将一个大的数据集，压缩到一个小得多的数据集，而丢失尽可能少的信息</p><h2 id="jupyter-notebook"><a href="#jupyter-notebook" class="headerlink" title="jupyter notebook"></a>jupyter notebook</h2><p>实验环境</p><h2 id="线性回归模型-linear-regression"><a href="#线性回归模型-linear-regression" class="headerlink" title="线性回归模型(linear regression)"></a>线性回归模型(linear regression)</h2><p>将一条直线拟合到数据中，预测数字的监督学习，只有一个输入特征或者说变量</p><p>具有一个输入变量的线性模型，另一个名称：单变量线性回归</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><code>feature --&gt; model --&gt; prediction</code></p><p><code>x --&gt; f --&gt; y-hat (estimated y)</code></p><h3 id="f-model"><a href="#f-model" class="headerlink" title="f/model"></a>f/model</h3><p>f<sub>w, b</sub> = wx + b</p><p><code>f(x) = wx + b</code></p><h2 id="代价函数-cost-function"><a href="#代价函数-cost-function" class="headerlink" title="代价函数(cost function)"></a>代价函数(cost function)</h2><blockquote><p>衡量拟合程度</p></blockquote><p>w, b是模型的参数，在机器学习w, b是咱可以调整的变量，以改进模型，或者称为系数或者权重</p><p>为了构建一个不会随着训练集大小变大而自动变大的成本函数，我们将计算平均平方误差而不是总平方误差，按照惯例，人们使用的成本函数实际上是除以2乘以m，额外除以2只是为了让我们后面的一些计算看起来更整洁，但是无论是否包含此除以2，成本函数仍然有效。</p><p>线性回归问题最常用的代价函数就是<code>平方误差成本函数</code>，训练的目的是使成本函数尽可能小，找到j最小的时候的w, b的值</p><p>$$<br>J(w,b)=\frac{1}{2m}\sum_{i = 1}^m(f_{w,b}x^{(i)}-y^{(i)})^2<br>$$</p><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>梯度下降算法是一种可以用于求任何代价函数的最小值的算法，不仅仅是线性回归的代价函数，在w，b—上最小化代价函数</p><p>从对参数的猜测开始，不断变化w，b的值去降低代价函数的值，直到我们得到最小值或者接近最小值，有时候代价函数的最小值可能存在不止一个，神经网络的代价函数的图就是上下起伏的，有多个谷底</p><p>在山峰上的时候如果想要去到谷底，环顾一周，看哪能最速下坡，一步一步重复，就到谷底。</p><p>可以通过选择开始的w，b值，<code>设置不同的起点，会进入一个完全不同的山谷，进入局部最小值</code>。</p><h3 id="实现梯度下降算法"><a href="#实现梯度下降算法" class="headerlink" title="实现梯度下降算法"></a>实现梯度下降算法</h3><p>$$<br>w=w-\alpha\frac{\partial}{\partial w}J(w,b)<br>\<br>b=b-\alpha\frac{\partial}{\partial b}J(w,b)<br>$$</p><p>在程序中<code>=</code>是赋值的意思，而不是数学符号中的真值断言，如果像完成真值断言的功能使用<code>==</code>，断言两个值是否相等</p><h4 id="Alpha"><a href="#Alpha" class="headerlink" title="Alpha"></a>Alpha</h4><p>学习率</p><p>0~1之间的一个小的正数，控制下坡的步幅，控制更新时的步长</p><h4 id="j的导数项"><a href="#j的导数项" class="headerlink" title="j的导数项"></a>j的导数项</h4><p>朝哪个方向迈出脚步</p><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>设定一个开始值，不断执行这个更新步骤，直到算法收敛，也就是说走到谷底，或者说十分接近谷底，不再随着采取的每一个额外步骤而发生很大变化</p><h3 id="正确同时更新"><a href="#正确同时更新" class="headerlink" title="正确同时更新"></a>正确同时更新</h3><p>$$<br>tmp_w=w-\alpha\frac{\partial}{\partial w}J(w,b)\<br>tmp_b=b-\alpha\frac{\partial}{\partial b}J(w,b)\<br>w=tmp_w<br>b=tmp_b<br>$$</p><h3 id="学习率的选择"><a href="#学习率的选择" class="headerlink" title="学习率的选择"></a>学习率的选择</h3><blockquote><p>影响效率</p></blockquote><p>学习率太小，每次迈出的步子，收敛的速度会很慢，需要很多步骤</p><p>学习率太大，每次迈出的步子太大，有可能会错i过适合收敛的位置，最后无法收敛甚至发散，离最小值越来远<br>$$<br>w=w-\alpha\frac{1}{m}\sum_{i = 1}^m(f_{w,b}x^{(i)}-y^{(i)})x^{(i)}\<br>b=b-\alpha\frac{1}{m}\sum_{i = 1}^m(f_{w,b}x^{(i)}-y^{(i)})<br>$$<br>线性回归只有一个最小值，因为他是一个凸函数</p><p>这种梯度下降叫做批量梯度下降(bashed grading descent)，在梯度下降的每一步中我们都在查看所有的训练示例，而不仅仅是训练数据的一个子集，每次计算的时候都看了整个训练集</p><p>也有使用子集进行计算，我们选择批量梯度下降算法进行线性回归</p><h2 id="多元线性回归-multiple-linear-regression"><a href="#多元线性回归-multiple-linear-regression" class="headerlink" title="多元线性回归(multiple linear regression)"></a>多元线性回归(multiple linear regression)</h2><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/image-20241018085410084.png"></p><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/Snipaste_2024-10-18_08-58-43.png"></p><h2 id="矢量化"><a href="#矢量化" class="headerlink" title="矢量化"></a>矢量化</h2><p>使用numpy，数值线性代数库</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">w = np.array([<span class="number">1.0</span>, <span class="number">2.5</span>, -<span class="number">3.4</span>])</span><br><span class="line">b = <span class="number">4</span></span><br><span class="line">x = np.array([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>])</span><br><span class="line"><span class="comment"># 提高效率，代码更短，更快，在计算机硬件中通过矢量化实现并行</span></span><br><span class="line">f = np.dot(w, x) + b</span><br><span class="line">w = w - <span class="number">0.1</span> * d</span><br><span class="line"><span class="comment"># 相较于</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">16</span>):</span><br><span class="line">    w[j] = w[j] - <span class="number">0.1</span> * d[j]</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>使用下标访问不同的特征值</p><h2 id="多元线性回归的梯度下降法"><a href="#多元线性回归的梯度下降法" class="headerlink" title="多元线性回归的梯度下降法"></a>多元线性回归的梯度下降法</h2><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/Snipaste_2024-10-18_09-34-55.png"></p><h2 id="正规方程法-normal-equation"><a href="#正规方程法-normal-equation" class="headerlink" title="正规方程法(normal equation)"></a>正规方程法(normal equation)</h2><p>只适用于线性回归方程</p><p>不需要迭代就能算出w, b，无法泛化，速度慢</p><p>梯度下降算法更好</p><h2 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>特征的可能值很大时，权重应该更小</p><p>有不同的特征，他们的取值范围非常不同时，可能会导致梯度下降运行缓慢，应该重新缩放不同的特征，使它们都具有可比较的取值范围。</p><p>相当于特征值的归一化</p><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>z-score </p><h3 id="and"><a href="#and" class="headerlink" title="and"></a>and</h3><p>根据经验，在执行特征缩放时，希望使特征的范围从负一左右到每个特征x正一左右</p><h2 id="判断梯度下降是否生效"><a href="#判断梯度下降是否生效" class="headerlink" title="判断梯度下降是否生效"></a>判断梯度下降是否生效</h2><p>代价函数-迭代次数图像，正常情况下的图像应该是随着迭代次数的增多，代价函数逐渐下降</p><p>如何J在一次迭代后增加，这意味着学习率选择不当，通常意味着学习率太大或者代码中存在错误</p><p>正确实施梯度下降的一个调试技巧是，如果学习率足够小，成本函数应该在每次迭代中减少</p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>通过转换或者组合问题的原始特征来是学习算法更容易做出准确的预测</p><h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2>]]></content>
    
    
    <summary type="html">学习machine-learning</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="机器学习" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="lea" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/lea/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="机器学习" scheme="https://dra-tammer.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="lea" scheme="https://dra-tammer.github.io/tags/lea/"/>
    
  </entry>
  
  <entry>
    <title>《云边有个小卖部》</title>
    <link href="https://dra-tammer.github.io/posts/4c32c6bc.html"/>
    <id>https://dra-tammer.github.io/posts/4c32c6bc.html</id>
    <published>2024-10-10T12:40:16.000Z</published>
    <updated>2024-10-10T13:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="云边有个小卖部"><a href="#云边有个小卖部" class="headerlink" title="云边有个小卖部"></a>云边有个小卖部</h1><p><code>start from 2024-09-30</code></p><p><code>end on 2024-10-06</code></p><p>先是看的电影，之后去找的原著。就不该先看电影，搞得我看书的时候觉得程霜就该长周也那样，周也真的是标准的初恋脸，外婆也就该长电影里的外婆那样，男主倒是无所谓哈哈哈哈。</p><p>我觉得这个小说看起来像一个童话，催泪结尾的童话，整个过程就是刘十三的成长过程。从一个我们传统意义上的没本事的人一步一步成熟，一步一步失去最爱的人，最后成长。</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><blockquote><p>抄自百度</p></blockquote><p>该小说主要写了云边镇少年刘十三的成长故事，前半部分写了刘十三从云边镇走向城市，在校园爱情、职场中受挫且伤痕累累，后半部分写刘十三被外婆王莺莺用拖拉机拉回了云边镇，在云边镇感受到的世情冷暖。该小说表达了对故乡、对亲情的衷心倾诉。外婆王莺莺的乐观坚韧和无限包容，程霜像一道光一样短暂又永恒，刘十三的奋斗与卑微，云边镇迷人的自然风景、悠然的生活节奏，共同构成了云边故乡的美好意境。</p><h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><p>我有很重要的事，输了的话，我就真的一无所有了。</p><p>幻觉很好，做梦也很好，一切远离现实的都很好。</p><p>有些人刻苦铭心，没几年会遗忘；有些人不论生死，都陪在身边。</p><p>月亮挂在半空，小镇背倚着起起伏伏的峰峦，山形边缘浮动银白色。</p><p>明明一块儿踏青野炊点篝火，大自然如此美好哭什么，难道触景生情，哭的是一岁一枯荣？</p><p>它们夹在笔记本最后的空白页，像夹在时光的间隙，人们随口说的一些话，跌落墙角，风吹不走，阳关烧不掉，独自沉眠。</p><p>为别人活着，也要为自己活着；希望和悲伤，都是一缕光；总有一天，我们会再相遇。</p><p>山风微微，像月光下晃动的海浪；温和而柔软，停留在时光的背后；变成小时候听过的故事；在遥远的城市，陌生的地方，有他未曾见过的山和海。</p><p>生命是有光的，在我熄灭以前，能够照亮你一点，就是我所有能做的了，我爱你，你要记得我。</p><p>跌倒一次，好不容易刚爬起来！没想到没走几步又狠狠地摔倒！想放弃这辈子就是个废物！但是为了亲情和责任又爬起来！装作没事的人，又接着上路。</p><p>原来世界上很多事情，不是你有计划，有毅力就能做到的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优点就是生活化做的很好，有时候叙事的同时会冷不丁地冒出来很有生活气息的一句话，让人感觉这是作者亲身经历过的事情，也容易引起共鸣，看书的时候会心一笑，开心一下。</p><p>看的时候感觉槽点很多，有些东西不能细想，有些东西太理想化。有人说作者是用了虚实结合的手法，情节是虚构的，但是人物测情感内核是真的。（十三的谐音是失散，程霜可能是成双成对，但终究是一场梦）。</p><p>耐心读完，一边吐槽一边大受感动，感受到了平时身边的人的对自己的爱是陪伴。</p><p>当不开心的时候或者想要消磨时间的时候，这本书是一个不错的选择，故事也很容易理解，十分具有生活气息。人和人之间舒服的关系，是可以一直不说话，也可以随时说话。</p>]]></content>
    
    
    <summary type="html">作者：张嘉佳</summary>
    
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>NexT配置utterances</title>
    <link href="https://dra-tammer.github.io/posts/14f6913e.html"/>
    <id>https://dra-tammer.github.io/posts/14f6913e.html</id>
    <published>2024-09-03T07:09:31.000Z</published>
    <updated>2024-09-03T13:51:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NexT配置utterances"><a href="#NexT配置utterances" class="headerlink" title="NexT配置utterances"></a>NexT配置utterances</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>utterances通过Github App实现，可以只对issues授权，因此没有安全性风险，不需要初始化。</p><blockquote><p><a href="https://utteranc.es/">https://utteranc.es/</a></p></blockquote><h2 id="创建存储评论的仓库"><a href="#创建存储评论的仓库" class="headerlink" title="创建存储评论的仓库"></a>创建存储评论的仓库</h2><p>新建一个仓库<code>blog_comments_db</code>用来存储评论</p><ul><li>保证仓库是公开仓库，否则读者没有办法看到这些评论</li><li>保证utterances app已经被安装</li></ul><h2 id="安装Github-Apps"><a href="#安装Github-Apps" class="headerlink" title="安装Github Apps"></a>安装Github Apps</h2><p><code>https://github.com/apps/utterances</code></p><p><code>install</code>-&gt;<code>Only select repositories</code>-&gt;<code>blog_comment_db</code></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="创建utterances-swig"><a href="#创建utterances-swig" class="headerlink" title="创建utterances.swig"></a>创建<code>utterances.swig</code></h3><p>在<code>layout/_third-party/comments</code>里创建<code>utterances.swig</code>，内容如下</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">{<span class="string">%-</span> <span class="string">if</span> <span class="string">page.comments</span> <span class="string">%</span>}</span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">NexT.utils.loadComments(document.querySelector('#utterances-container'),</span> <span class="string">()</span> <span class="string">=&gt;</span> {</span><br><span class="line">    <span class="string">//</span> <span class="string">if</span> <span class="string">(typeof</span> <span class="string">parcelRequire</span> <span class="string">===</span> <span class="string">'function'</span><span class="string">)</span> { <span class="string">return;</span> }</span><br><span class="line">    <span class="string">var</span> <span class="string">js</span> <span class="string">=</span> <span class="string">document.createElement('script');</span></span><br><span class="line">    <span class="string">js.type</span> <span class="string">=</span> <span class="string">'text/javascript'</span><span class="string">;</span></span><br><span class="line">    <span class="string">js.src</span> <span class="string">=</span> <span class="string">'https://utteranc.es/client.js'</span><span class="string">;</span></span><br><span class="line">    <span class="string">js.async</span> <span class="string">=</span> <span class="literal">true</span><span class="string">;</span></span><br><span class="line">    <span class="string">js.crossorigin</span> <span class="string">=</span> <span class="string">'anonymous'</span><span class="string">;</span></span><br><span class="line">    <span class="string">js.setAttribute('repo'</span>, <span class="string">'<span class="template-variable">{{ theme.utterances.repo }}</span>'</span><span class="string">);</span></span><br><span class="line">    <span class="string">js.setAttribute('issue-term'</span>, <span class="string">'<span class="template-variable">{{ theme.utterances.issue_term }}</span>'</span><span class="string">);</span></span><br><span class="line">    <span class="string">js.setAttribute('theme'</span>, <span class="string">'<span class="template-variable">{{ theme.utterances.theme }}</span>'</span><span class="string">);</span></span><br><span class="line">    <span class="string">document.getElementById('utterances-container').appendChild(js);</span></span><br><span class="line">}<span class="string">);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line">{<span class="string">%-</span> <span class="string">endif</span> <span class="string">%</span>}</span><br></pre></td></tr></tbody></table></figure><h3 id="创建utterances-js"><a href="#创建utterances-js" class="headerlink" title="创建utterances.js"></a>创建<code>utterances.js</code></h3><p>在<code>scripts/filters/comment</code>下创建<code>utterances.js</code>，内容如下</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/*</span> <span class="string">global</span> <span class="string">hexo</span> <span class="string">*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">'use strict'</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="string">const</span> <span class="string">path</span> <span class="string">=</span> <span class="string">require('path');</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">Add</span> <span class="string">comment</span></span><br><span class="line"><span class="string">hexo.extend.filter.register('theme_inject',</span> <span class="string">injects</span> <span class="string">=&gt;</span> {</span><br><span class="line">  <span class="string">let</span> <span class="string">theme</span> <span class="string">=</span> <span class="string">hexo.theme.config;</span></span><br><span class="line">  <span class="string">if</span> <span class="string">(!theme.utterances.enable)</span> <span class="string">return;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">injects.comment.raw('utterances'</span>, <span class="string">'&lt;div class="comments" id="utterances-container"&gt;&lt;/div&gt;'</span>, {}, {<span class="attr">cache:</span> <span class="literal">true</span>}<span class="string">);</span></span><br><span class="line"></span><br><span class="line">  <span class="string">injects.bodyEnd.file('utterances'</span>, <span class="string">path.join(hexo.theme_dir</span>, <span class="string">'layout/_third-party/comments/utterances.swig'</span><span class="string">));</span></span><br><span class="line"></span><br><span class="line">}<span class="string">);</span></span><br></pre></td></tr></tbody></table></figure><h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><p><code>NexT主题文件夹</code>-&gt;<code>_config.yml</code></p><p>在主题配置文件中添加</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">utterances:</span> </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">"你的repo地址"</span></span><br><span class="line">  <span class="attr">issue_term:</span> <span class="string">"pathname"</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">"github-light"</span></span><br></pre></td></tr></tbody></table></figure><p>关于配置选项的更多信息可参考<a href="https://utteranc.es/">官方网站</a>.</p><blockquote><p>现在我的hexo版本和next版本都是最新的，发现next已经内置了utterances</p></blockquote><p>所以只需要完成最后一步：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">utterances:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">Dra-Tammer/blog_comments_db</span> <span class="comment"># Github repository owner and name</span></span><br><span class="line">  <span class="comment"># Available values: pathname | url | title | og:title</span></span><br><span class="line">  <span class="attr">issue_term:</span> <span class="string">pathname</span></span><br><span class="line">  <span class="comment"># Available values: github-light | github-dark | preferred-color-scheme | github-dark-orange | icy-dark | dark-blue | photon-dark | boxy-light</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">github-dark</span></span><br></pre></td></tr></tbody></table></figure><h2 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h2><p>hexo三连</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></tbody></table></figure><h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><h3 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h3><p>本地部署，查看评论功能的时候登录会显示404，不知道如何解决，但是将代码push上去之后，访问github page就没有问题，确实加载的时候有点慢。</p><p>之后sign with github又能正常使用了</p><h3 id="设置部分页面不能评论"><a href="#设置部分页面不能评论" class="headerlink" title="设置部分页面不能评论"></a>设置部分页面不能评论</h3><p>配置之后发现tags, categories, about页面都有评论，想要不能评论，可以在对应的md页面的头部添加<code>comments: false</code>配置项</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2023-08-06 18:10:02</span><br><span class="line">type: categories</span><br><span class="line">comments: false</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">NexT主题配置utterances评论系统</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="博客" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="Hexo" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2/Hexo/"/>
    
    <category term="NexT" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2/Hexo/NexT/"/>
    
    <category term="配置" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2/Hexo/NexT/%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="博客" scheme="https://dra-tammer.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>2024年九月推免面试汇总</title>
    <link href="https://dra-tammer.github.io/posts/1d5f4f02.html"/>
    <id>https://dra-tammer.github.io/posts/1d5f4f02.html</id>
    <published>2024-08-27T03:21:20.000Z</published>
    <updated>2024-09-24T14:35:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本地知识库问答应用"><a href="#本地知识库问答应用" class="headerlink" title="本地知识库问答应用"></a>本地知识库问答应用</h2><h3 id="核心功能介绍"><a href="#核心功能介绍" class="headerlink" title="核心功能介绍"></a>核心功能介绍</h3><h4 id="个人AI助手"><a href="#个人AI助手" class="headerlink" title="个人AI助手"></a>个人AI助手</h4><p>将智能对话系统和传统知识库相耦合，使用户不仅可以询问知识库内相关内容，还可以询问知识库以外的内容。</p><h4 id="智能问答模块"><a href="#智能问答模块" class="headerlink" title="智能问答模块"></a>智能问答模块</h4><p>基于LLM大语言模型，在海量的知识库文件中挖掘信息，实现知识理解，推理与分析，根据挖掘的有效知识信息，智能回答用户提出的问题，并给出参考文件。</p><h4 id="对象存储模块"><a href="#对象存储模块" class="headerlink" title="对象存储模块"></a>对象存储模块</h4><p>利用对象存储技术的可扩展性强，可靠性高，采用全局唯一标识符访问数据，包含基本的文件管理，文件上传，文件删除功能。</p><h4 id="知识库管理模块"><a href="#知识库管理模块" class="headerlink" title="知识库管理模块"></a>知识库管理模块</h4><p>单独设立个人空间，包含新增知识库，删除知识库，修改知识库，知识库成员新增和踢出等知识库管理功能，同时还可以变更知识库访问权限。</p><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><blockquote><p>一套互联网应用程序的API设计理论</p></blockquote><p><strong>API</strong>是应用程序编程接口，使得一个软件程序能够向另一个软件程序传输数据，API调用就是触发使用API。</p><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>通信协议总是使用HTTPS</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>应该尽量将API部署在专用域名之下，如果确定API很简单，不会有进一步扩展，可以考虑放在主域名之下</p><h4 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h4><p>GET, POST, PUT, PATCH, DELETE等</p><h4 id="状态码等"><a href="#状态码等" class="headerlink" title="状态码等"></a>状态码等</h4><ol><li>200，成功返回数据</li><li>400，用户发出的请求有误</li><li>500，服务器发生错误，用户无法判断发出的请求是否成功</li></ol><h3 id="FastAPI"><a href="#FastAPI" class="headerlink" title="FastAPI"></a>FastAPI</h3><p>FasAPI是一个现代，快速，高性能的Web框架，用户构建基于Python的API</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>快速高效</li><li>自动文档生成</li><li>数据验证和转换</li><li>类型提示</li><li>安全认证</li><li>强大的生态系统</li></ul><h3 id="LangChain"><a href="#LangChain" class="headerlink" title="LangChain"></a>LangChain</h3><p>开源编排框架，用于使用大语言模型开发应用程序，可以简化LLM驱动型应用程序的开发过程。</p><p>核心是一个开发环境，通过使用抽象方法简化LLM应用程序的编程，模块化将充当AI程序的构建块，将它们连接在一起来创建应用程序。</p><h4 id="Langchain-组件"><a href="#Langchain-组件" class="headerlink" title="Langchain 组件"></a><strong>Langchain 组件</strong></h4><p>基于以下几个核心的 langchain 组件构建本地知识库</p><ul><li><p>Embedding（嵌入模型）</p><p>为了捕捉文本的语义和语法信息，以便在后续的任务中能够更好地使用</p></li><li><p>Vector Store（向量数据库）</p></li><li><p>Document Splitter（文档切割）</p></li><li><p>LLM （大模型）</p></li></ul><h3 id="LLM"><a href="#LLM" class="headerlink" title="LLM"></a>LLM</h3><p>大语言模型是针对语言的大模型，大模型是一种深度学习模型，包含了“预训练”和“大模型”两层含义，模型在大规模数据集上完成了预训练后无需微调或者仅需少量的微调，就能直接支持各类应用。</p><p>通过学习大量的文本数据，<strong>来预测下一个词或者下一段话的可能性</strong>，从而使计算机能够更好地理解和生成人类语言。生成式预训练Transformer（GPT），可以自动生成具有语言上下文和逻辑关系的连贯文本，这些文本在预训练时并没有直接指定，而是通过模型自身的学习和推理得到的。</p><p>LLM能够理解上下文信息，处理多种自然语言处理的任务，比如：文本生成，翻译，摘要，情感分析，无需给每个任务单独训练一个模型。</p><h4 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h4><p>一个预先设定的条件，可以限制模型的自由发散，而是围绕提示内容进行展开。</p><h3 id="如何进行知识挖掘"><a href="#如何进行知识挖掘" class="headerlink" title="如何进行知识挖掘"></a>如何进行知识挖掘</h3><ol><li>加载用户上传到知识库中的文件</li><li>预处理与文本切分</li></ol><p>将一个文档转成向量数据库中的数据往往可以分成两个大的步骤，<strong>tokenizer****和</strong>embedding**</p><ul><li>tokenizer负责将文本拆分成次元</li><li>embedding将词元转换成词向量的表示</li></ul><ol><li>向量化与向量存储</li><li>用户提问，将用户的提问向量化，在数据库中检索相似的几条向量，即匹配文本相似性和语义检索，将检索出来的结果用于NLP问答。将用户的提问向量和检索出的向量数据发送给大语言模型处理，生成用户能够理解的语言。</li></ol><h3 id="向量数据库"><a href="#向量数据库" class="headerlink" title="向量数据库"></a>向量数据库</h3><blockquote><p>向量数据存储在专门设计的向量数据库中，可以通过最近邻搜索算法找到与查询向量相似的向量。</p></blockquote><p>如果要表达一个具体事物的特征，所用的向量维度还是非常大的，在检索的时候非常消耗性能，使用一些算法进行优化， 比如K-means聚类算法，用分类的质心向量来代替每一个向量，以减少存储的空间。</p><p>每一个事物可以是具象的，也可以是抽象的，最终都会在一个高维的特征空间中对应着一个坐标点。</p><h4 id="向量数据库对LLM处理的作用"><a href="#向量数据库对LLM处理的作用" class="headerlink" title="向量数据库对LLM处理的作用"></a>向量数据库对LLM处理的作用</h4><p>如果拿着当前文本的向量数据去寻找之前问答过程中最相似的问答文本，将他们作为上下文输送给大模型，能够极大提高大模型的输出准确性和输出效率。能够生成具有上下文意识和更加满足用户需求，更加专业的回答。</p><ol><li>提高LLM的性能：通过使用向量数据库，LLM可以实现对文本数据的快速检索和分析，从而提高其处理速度和准确性。这对于需要处理大规模数据的LLM来说尤为重要。</li><li>降低存储成本：向量数据库采用高效的存储结构，能够实现对向量数据的压缩和去重，从而降低存储成本。这对于需要长期保存大量数据的LLM来说非常有利。</li><li>支持多模态数据处理：除了文本数据外，向量数据库还可以处理图像、音频等多模态数据。这使得LLM能够实现对多种类型数据的综合处理，进一步拓展其应用场景。</li></ol><p>同时解决LLM的上下文限制问题（token），如果你的知识库内容长度超出了限制，我们就不能直接让 ChatGPT 对其进行总结并回答问题。通过 Embedding 技术，我们可以使用语义搜索来快速找到相关的文档，然后只将相关的文档内容注入到大模型的上下文窗口中，让模型来生成特定问题的答案，从而解决大模型的限制问题。这种做法比 Fine tuning 速度更快，而且不需要训练，使用上也更灵活。</p><h4 id="最近邻问题"><a href="#最近邻问题" class="headerlink" title="最近邻问题"></a>最近邻问题</h4><blockquote><p>向量数据的一个主要的应用场景就是给定一个查询向量，然后从众多向量中找到最为相似的一些。</p></blockquote><h4 id="最近邻搜索算法"><a href="#最近邻搜索算法" class="headerlink" title="最近邻搜索算法"></a>最近邻搜索算法</h4><h5 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h5><p>两个向量的夹角，或者计算两个向量之间的欧氏距离。</p><h5 id="K-means聚类算法（近似最近邻）"><a href="#K-means聚类算法（近似最近邻）" class="headerlink" title="K-means聚类算法（近似最近邻）"></a>K-means聚类算法（近似最近邻）</h5><ol><li>先选定一个想要分类的数量，随机生成四个点，称为聚类中心点，这些向量与哪个中心点最近就被分为哪一类</li><li>用当前被分为一类的向量计算出一个平均向量点，把对应的中心点的位置更新为这个平均向量点</li><li>重新判断每一个向量与哪个中心最近，重新分类</li><li>重复步骤二，三</li></ol><p>如此反复，这个不断迭代的过程就被称为训练，最后这些中心点会趋于稳定或者说收敛，搜索的时候，先看查询向量属于哪个聚类，再在聚类中所搜最相似的向量。</p><h4 id="向量数据库和传统数据库有什么区别"><a href="#向量数据库和传统数据库有什么区别" class="headerlink" title="向量数据库和传统数据库有什么区别"></a>向量数据库和传统数据库有什么区别</h4><p>传统数据库主要是针对结构化数据的存储和查询，而向量数据库则是针对非结构化数据（例如图像、文本等）的存储和查询。 向量数据库的优势在于它可以通过向量相似度快速和高效地查询相似的数据，适用于图像搜索、语音识别、推荐系统等场景。</p><h4 id="什么是结构化的数据"><a href="#什么是结构化的数据" class="headerlink" title="什么是结构化的数据"></a>什么是结构化的数据</h4><p>结构化数据就是具有预定义的结构或者预定义的格式的数据，例如存储的日期是有格式的，性别是有格式的</p><p>非结构化数据缺乏定义，各种各样的格式，比如图像，文本等</p><h4 id="向量数据库给LLM传输的是什么类型的数据"><a href="#向量数据库给LLM传输的是什么类型的数据" class="headerlink" title="向量数据库给LLM传输的是什么类型的数据"></a>向量数据库给LLM传输的是什么类型的数据</h4><p>在构建知识库应用时，向量数据库向LLM（大型语言模型）传输的数据通常是高维数值向量。这些向量是通过将原始数据（如文本、图像、音频等）经过特定的算法（如词嵌入Word Embeddings、BERT或其他深度学习模型）转换得到的，它们能够捕捉数据的关键特征和语义信息。</p><h3 id="AIGC"><a href="#AIGC" class="headerlink" title="AIGC"></a>AIGC</h3><blockquote><p>人工智能生成内容</p></blockquote><p>ChatGPT是AIGC在聊天对话场景的一个具体应用。</p><h3 id="自然语言处理（NLP）"><a href="#自然语言处理（NLP）" class="headerlink" title="自然语言处理（NLP）"></a>自然语言处理（NLP）</h3><p>理解用户的自然语言</p><h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><p>一种深度学习模型，在自然语言处理领域特别流行，能够更加高效和有效地处理序列数据。transformer完全基于注意力机制，没有使用循环神经网络（RNN）或者卷积神经网络（CNN）。核心是：</p><ul><li>自注意力机制：并行处理所有位置的数据，提高计算效率</li><li>多头注意力：捕获序列中多种不同级别的依赖关系</li><li>位置编码：提供单词在序列中位置的信息</li></ul><h3 id="RNN模型"><a href="#RNN模型" class="headerlink" title="RNN模型"></a>RNN模型</h3><p>循环神经网络（recurrent neural network，RNN）是一种具有反馈结构的神经网络，其输出不但与当前输入和网络的权值有关，而且也与之前网络的输入有关；RNN通过添加跨越时间点的自连接隐藏层，对时间进行建模；换句话说，隐藏层的反馈，不仅仅进入输出端，而且还进入了下一时间的隐藏层。 一般的RNNs有多个FNN横向连接而成，其中中间有个rnn-cell, 存储的是前面序列的隐含状态s。 分解开来的话， 就相当于三层，第一层是输入x到rnn-cell的连接，第二层是rnn-cell,得到的是隐藏状态s，第三层是rnn-cell到输出o的连接层。</p><ul><li>输入层</li><li>隐藏层</li><li>输出层</li></ul><h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>基于对象的存储，与其他计算机数据存储架构不同的是，它管理的是对象，而不是文件系统和数据块，一个“对象”包括数据本身，一些元数据和一个唯一标识符。这些数据可以通过API或者http/https进行即刻访问。通过这种方式，对象存储保障了数据的安全。如果需要这些数据还可以复制到多个数据中心。</p><p>与文件类型和块类型存储不同，对象存储支持有助于描述文件的全面元数据。元数据可帮助您理解和分析大型文件，而无需直接处理文件中包含的内容。</p><h4 id="对象存储的好处"><a href="#对象存储的好处" class="headerlink" title="对象存储的好处"></a>对象存储的好处</h4><ul><li><strong>更易于访问</strong>：对象存储由元数据驱动，通过对每个数据的这种分类级别，您可以轻松地对文件进行排序和搜索。</li><li><strong>无限存储</strong>：对象存储不依赖于硬件（不限于单个服务器或NAS）</li><li><strong>降低成本</strong>：由于对象存储的横向扩展性质，存储所有数据的成本更低。</li><li><strong>资源优化</strong>：由于对象存储没有归档层次结构，并且元数据完全可自定义，因此与文件或块存储相比，硬件限制要少得多。</li></ul><h4 id="对象存储的元数据"><a href="#对象存储的元数据" class="headerlink" title="对象存储的元数据"></a>对象存储的元数据</h4><p>对于元数据为何产生影响的实际例子，我们可以看看医院如何存储和处理患者的X射线图像。 X射线文件将具有与其关联的有限元数据，例如创建日期，所有者，位置和大小。另一方面，X射线对象可以具有丰富的元数据信息。</p><p>元数据可以包括患者姓名，出生日期，受伤细节，身体的哪个区域进行X光检查 - 以及文件所具有的相同标签。这使得医生提取相关信息以供参考非常有用。</p><h4 id="对象存储的局限性"><a href="#对象存储的局限性" class="headerlink" title="对象存储的局限性"></a>对象存储的局限性</h4><ul><li>与Block Storage相比，访问速度更慢</li><li>文件无法编辑，需要重写/重新上传整个内容</li><li>难以限制/定义存储位置</li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="燃烧若干根不均匀的绳，每条绳子燃尽是1小时，如何计时1小时15分？"><a href="#燃烧若干根不均匀的绳，每条绳子燃尽是1小时，如何计时1小时15分？" class="headerlink" title="燃烧若干根不均匀的绳，每条绳子燃尽是1小时，如何计时1小时15分？"></a>燃烧若干根不均匀的绳，每条绳子燃尽是1小时，如何计时1小时15分？</h3><p>把第一根绳子两头同时点燃,同时把第二根绳子点燃一头,当第一根绳子烧完时,时间为半个小时,这时把第二根绳子的另一头也点燃,开始计时,当第二根绳子烧完时,停止计时,那么这段时间就是15分钟。也就是说，只需要3根绳子就可以计时一个小时15分钟。</p><h3 id="给你一个6L和5L的杯子和一个无限容量的容器，如何量出4L的水？"><a href="#给你一个6L和5L的杯子和一个无限容量的容器，如何量出4L的水？" class="headerlink" title="给你一个6L和5L的杯子和一个无限容量的容器，如何量出4L的水？"></a>给你一个6L和5L的杯子和一个无限容量的容器，如何量出4L的水？</h3><p>先把6L桶装满，再向5L桶里倒水。5L桶满，则把它的水倒掉，6L桶没水，则装满水，不断循环这个过程，直到找到满足要求的水。</p><h3 id="exe文件在Linux系统下为什么不能运行"><a href="#exe文件在Linux系统下为什么不能运行" class="headerlink" title=".exe文件在Linux系统下为什么不能运行"></a>.exe文件在Linux系统下为什么不能运行</h3><p>编译链接的时候用到的库不一样</p><h3 id="编译型语言和解释型语言的区别"><a href="#编译型语言和解释型语言的区别" class="headerlink" title="编译型语言和解释型语言的区别"></a>编译型语言和解释型语言的区别</h3><p>源代码一次性转换成二进制指令，生成一个可执行程序，即编译型语言</p><p>一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序</p><h3 id="深度学习和机器学习"><a href="#深度学习和机器学习" class="headerlink" title="深度学习和机器学习"></a>深度学习和机器学习</h3><p>深度学习（也称为深度神经学习或深度神经网络）会让计算机通过观察，学习、模仿人类获取知识的方式。 </p><p>人脑中有很多相互连接的神经元，当大脑处理信息（或数据）时，这些神经元就负责传递信息。神经元之间通过电信号和化学物质相互作用，并在大脑的不同区域之间传递信息。 </p><p>人工神经网络（ANN）是模仿这种生物学现象而构成的，是深度学习所依托的底层架构，然而，ANN 使用的是人工神经元而不是生物神经元，这些人工神经元是由称为节点的软件模块构成的。这些节点使用数值计算（而不是大脑中的化学信号）来进行通信和传递信息。模拟神经网络（SNN）通过聚类数据点进行预测的方式来处理数据。</p><p>为了便于理解，我们可以将深度学习想象为某种流程图，它从输入层开始，到输出层结束。夹在这两层之间的是“隐藏层”，负责加工处理不同级别的信息，并随着不断接收新数据而调整和适应它们的行为。深层学习模型可以拥有数百个隐藏层，每个隐藏层都在数据集中发现关系和模式方面发挥作用。 </p><p>深度学习是机器学习的一种特殊形式，两者的区别在于其所处理的数据类型和学习方法。</p><p>经典的机器学习算法需要人工干预，先对数据集进行预处理，然后再将其导入模型。这意味着人要在模型的输入数据中定义和标记特定特征，并组织到表格中，然后再将其导入机器学习模型。相反，深度学习算法不需要这种级别的预处理，并且能够理解非结构化数据，例如文本文档、像素数据图像或音频数据文件。 </p><p>在有大量数据，却缺乏相关主题的背景知识或手头有复杂耗时的任务的情况下，深度学习可能优于经典机器学习。</p><ol><li>机器学习只关注解决现实问题。它还需要人工智能的一些想法。机器学习通过旨在模仿人类决策能力的神经网络。ML工具和技术是两个主要的仅关注深度学习的窄子集。我们需要应用它来解决任何需要思考的问题 —— 人类的或人为的。任何深度神经网络都将包含以下三层：输入层、隐藏层、输出层</li><li>我们用机器算法来解析数据，学习数据，并从中做出理智的判定。根本上讲，深度学习用于创建可自我学习和可理智判定的人工“神经网络”。我们可以说深度学习是机器学习的子领域。</li></ol><h3 id="介绍一下go语言的特征"><a href="#介绍一下go语言的特征" class="headerlink" title="介绍一下go语言的特征"></a>介绍一下go语言的特征</h3><h4 id="go语言出现的背景"><a href="#go语言出现的背景" class="headerlink" title="go语言出现的背景"></a>go语言出现的背景</h4><ul><li>Go希望成为互联网时代的C语言。多数系统级语言（包括Java和C#）的根本编程哲学来源于C++，将C++的面向对象进一步发扬光大。但是Go语言的设计者却有不同的看法，他们认为值得学习的是C语言。C语言经久不衰的根源是它足够简单。因此，Go语言也是足够简单。</li><li>所以，他们当时设计Go的目标是为了消除各种缓慢和笨重、改进各种低效和扩展性。Go是由那些开发大型系统的人设计的，同时也是为了这些人服务的；它是为了解决工程上的问题，不是为了研究语言设计；它还是为了让我们的编程变得更舒适和方便。</li><li>但是结合Google当时内部的一些现实情况，如很多工程师都是C系的，所以新设计的语言一定要易学习，最好是类似C的语言；20年没有出新的语言了，所以新设计的语言必须是现代化的（例如内置GC）等情况。最后根据实战经验，他们向着目标设计了Go这个语言。</li></ul><h4 id="go语言的特色"><a href="#go语言的特色" class="headerlink" title="go语言的特色"></a>go语言的特色</h4><ul><li>没有继承多态的面向对象</li><li>强一致类型</li><li>interface不需要显式声明(Duck Typing)</li><li>没有异常处理(Error is value)</li><li>基于首字母的可访问特性</li><li>不用的import或者变量引起编译错误</li><li>完整而卓越的标准库包</li><li>Go内置runtime（作用是性能监控、垃圾回收等）</li></ul><h4 id="go语言的优势"><a href="#go语言的优势" class="headerlink" title="go语言的优势"></a>go语言的优势</h4><p>1、学习曲线容易</p><p> Go语言语法简单，包含了类C语法。因为Go语言容易学习，所以一个普通的大学生花几个星期就能写出来可以上手的、高性能的应用。在国内大家都追求快，这也是为什么国内Go流行的原因之一。</p><p>2、效率：快速的编译时间，开发效率和运行效率高</p><p> 开发过程中相较于 Java 和 C++呆滞的编译速度，Go 的快速编译时间是一个主要的效率优势。Go拥有接近C的运行效率和接近PHP的开发效率。</p><p>C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。</p><p>3、出身名门、血统纯正</p><p> 之所以说Go出身名门，从Go语言的创造者就可见端倪，Go语言绝对血统纯正。其次Go语言出自Google公司，Google在业界的知名度和实力自然不用多说。Google公司聚集了一批牛人，在各种编程语言称雄争霸的局面下推出新的编程语言，自然有它的战略考虑。而且从Go语言的发展态势来看，Google对它这个新的宠儿还是很看重的，Go自然有一个良好的发展前途。</p><p>4、自由高效：组合的思想、无侵入式的接口</p><p> Go语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go语言支持当前所有的编程范式，包括过程式编程、面向对象编程、面向接口编程、函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。</p><p>5、强大的标准库</p><p> 这包括互联网应用、系统编程和网络编程。Go里面的标准库基本上已经是非常稳定了，特别是我这里提到的三个，网络层、系统层的库非常实用。<strong>Go 语言的 lib 库麻雀虽小五脏俱全。</strong>Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。</p><p>6、部署方便：二进制文件，Copy部署</p><p> 这一点是很多人选择Go的最大理由，因为部署太方便了，所以现在也有很多人用Go开发运维程序。</p><p>7、简单的并发</p><p><strong>并行和异步编程几乎无痛点。</strong>Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的编程者来说，完全就是让人眼前一亮的感觉。Go 是一种非常高效的语言，高度支持并发性。Go是为大数据、微服务、并发而生的一种编程语言。</p><ul><li>Go 作为一门语言致力于使事情简单化。它并未引入很多新概念，而是聚焦于打造一门简单的语言，它使用起来异常快速并且简单。其唯一的创新之处是 goroutines 和通道。Goroutines 是 Go 面向线程的轻量级方法，而通道是 goroutines 之间通信的优先方式。</li><li>创建 Goroutines 的成本很低，只需几千个字节的额外内存，正由于此，才使得同时运行数百个甚至数千个 goroutines 成为可能。可以借助通道实现 goroutines 之间的通信。Goroutines 以及基于通道的并发性方法使其非常容易使用所有可用的 CPU 内核，并处理并发的 IO。相较于 Python/Java，在一个 goroutine 上运行一个函数需要最小的代码。</li></ul><p>8、稳定性</p><p> Go拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么Go相比于其他程序会更稳定呢？这是因为Go提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如go tool、gofmt、go test。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="计算机之间的通信"><a href="#计算机之间的通信" class="headerlink" title="计算机之间的通信"></a>计算机之间的通信</h3><p>计算机之间的通信是两个主机进程之间的通信</p><h3 id="计算机网络分层"><a href="#计算机网络分层" class="headerlink" title="计算机网络分层"></a>计算机网络分层</h3><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><ul><li>应用层：为计算机用户提供服务</li><li>表示层：数据处理</li><li>会话层：管理应用程序之间的会话</li><li>传输层：端到端的进程通信</li><li>网络层：路由和寻址</li><li>数据链路层：帧编码喝误差纠正控制</li><li>物理层：透明地传送比特流</li></ul><h4 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h4><ul><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ul><h4 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h4><table><thead><tr><th>层次</th><th>功能</th><th>协议</th><th>交互的数据单元</th><th>中间设备</th></tr></thead><tbody><tr><td>应用层</td><td>为最终用户提供特定的网络应用</td><td>DNS,HTTP,HTTPS,SMTP</td><td>报文</td><td>网关</td></tr><tr><td>运输层</td><td>提供端到端的进程通信</td><td>TCP,UDP</td><td>报文段（TCP），用户数据报（UDP）</td><td>网关</td></tr><tr><td>网络层</td><td>在任意主机之间进行通信，任意节点之间尽力而为地传输分组</td><td>IP</td><td>IP数据报（数据报）</td><td>路由器</td></tr><tr><td>数据链路层</td><td>相邻节点之间无差错地传输数据帧</td><td>PPP,以太网</td><td>数据帧</td><td>网桥，交换机</td></tr><tr><td>物理层</td><td>传播比特流</td><td></td><td>比特</td><td>转发器，集线器，中继器，放大器</td></tr></tbody></table><h3 id="为什么网络要分层"><a href="#为什么网络要分层" class="headerlink" title="为什么网络要分层"></a>为什么网络要分层</h3><ol><li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li><li><strong>提高了灵活性和可替换性</strong>：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。并且，每一层都可以根据需要进行修改或替换，而不会影响到整个网络的结构。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li><li><strong>大问题化小</strong>：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 **这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</li></ol><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p></blockquote><h3 id="常见的网络协议"><a href="#常见的网络协议" class="headerlink" title="常见的网络协议"></a>常见的网络协议</h3><ul><li><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）</strong>：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li><li><strong>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）</strong>：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li><li><strong>POP3/IMAP（邮件接收协议）</strong>：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li><li><strong>FTP（File Transfer Protocol，文件传输协议）</strong> : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。</li><li><strong>Telnet（远程登陆协议）</strong>：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li><li><strong>SSH（Secure Shell Protocol，安全的网络传输协议）</strong>：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务</li><li><strong>RTP（Real-time Transport Protocol，实时传输协议）</strong>：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</li><li><strong>DNS（Domain Name System，域名管理系统）</strong>: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。</li></ul><h3 id="信息交互的方式"><a href="#信息交互的方式" class="headerlink" title="信息交互的方式"></a>信息交互的方式</h3><ol><li><p>单工通信</p><p>只有一个方向的通信没有反方向的交互</p></li><li><p>半双工通信</p><p>通信的双方都能发送信息，但是不能同时发送信息</p></li><li><p>全双工通信</p><p>通信的双方可以同时发送和接收信息</p></li></ol><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><blockquote><p>隐藏局域网之间的差异，逻辑上编一个地址，给连接到互联网上的每一台主机（或者路由器）的每一个接口，分配一个在全世界范围内唯一的32位的标识符）</p><p>格式：网络号+主机号</p><p>IPv4的地址空间2^32</p><p>点分十进制</p><p>IPv6的地址空间2^128</p><p>点分十六进制</p></blockquote><h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><p>TCP是面向连接的，可靠的，基于字节流的传输层通信协议</p><ol><li>面向连接：一定是一对一建立连接才能通信，不像UDP可以一对多</li><li>可靠的：保证报文一定能够到达接收端</li><li>字节流</li></ol><h3 id="TCP建立的三次握手"><a href="#TCP建立的三次握手" class="headerlink" title="TCP建立的三次握手"></a>TCP建立的三次握手</h3><ol><li>请求方向接收方发送一个建立连接的请求报文。（SYN = 1）</li><li>接收方向发送方发送一个对建立连接报文的确认报文。（SYN = 1, ACK = 1）</li><li>请求方向接收方发送一个对确认报文的确认报文，建立连接。（SYN = 1）</li></ol><h3 id="TCP断开连接的四次挥手"><a href="#TCP断开连接的四次挥手" class="headerlink" title="TCP断开连接的四次挥手"></a>TCP断开连接的四次挥手</h3><ol><li>主动关闭方告诉对方自己没有数据发送，请求关闭连接。</li><li>被动关闭方向主动关闭方发送一个对关闭连接请求的确认报文。</li><li>被动关闭方发送一个准备关闭连接的报文。</li><li>主动关闭方发送一个对被动关闭方发送的关闭连接的请求的确认报文，之后双方都进入CLOSED状态。</li></ol><h3 id="UDP和TCP"><a href="#UDP和TCP" class="headerlink" title="UDP和TCP"></a>UDP和TCP</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>都是传输层的协议</p><ul><li>传输控制协议(TCP)：面向连接，可靠</li><li>用户数据报协议(UDP)：无连接，尽力而为，不保证可靠</li></ul><h4 id="面向"><a href="#面向" class="headerlink" title="面向"></a>面向</h4><ul><li>UDP是面向报文的，对于应用层传输下来的报文，加上一个首部就交付给网络层。对报文既不拆分也不合并，保留这些报文的边界。一次发送一个报文。UDP向应用层交付的时候也是去掉一个首部，将一个完整的报文交给应用层。</li><li>TCP是面向字节流的，无论是发送还是接收，都是把数据块视为一个无边界的字节流，按顺序一个字节一个字节地发送或者接收。</li></ul><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>UDP是无连接的，TCP是面向连接的</p><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>UDP是不可靠的传输协议，他只是尽力而为地传输。没有内置的重传机制，流量控制和拥塞控制。TCP是可靠的传输协议，停等协议，回退n帧，选择重发，有流量控制和拥塞控制。</p><h4 id="上层协议"><a href="#上层协议" class="headerlink" title="上层协议"></a>上层协议</h4><p>DNS的下层协议是UDP，HTTP，HTTPS，FTP的下层协议是TCP</p><h3 id="网络层有哪些协议"><a href="#网络层有哪些协议" class="headerlink" title="网络层有哪些协议"></a>网络层有哪些协议</h3><ul><li><strong>IP（Internet Protocol，网际协议）</strong>：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li><li><strong>ARP（Address Resolution Protocol，地址解析协议）</strong>：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li><li><strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。</li><li><strong>NAT（Network Address Translation，网络地址转换协议）</strong>：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</li><li><strong>OSPF（Open Shortest Path First，开放式最短路径优先）</strong>：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</li><li><strong>RIP(Routing Information Protocol，路由信息协议）</strong>：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li><li><strong>BGP（Border Gateway Protocol，边界网关协议）</strong>：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。</li></ul><h3 id="从输入URL到页面展示发生了什么"><a href="#从输入URL到页面展示发生了什么" class="headerlink" title="从输入URL到页面展示发生了什么"></a>从输入URL到页面展示发生了什么</h3><ol><li>在浏览器中输入指定网页的 URL。</li><li>浏览器通过 DNS 协议，获取域名对应的 IP 地址。</li><li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li><li>浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li><li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li><li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li><li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li></ol><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>互联网上唯一的进程编号</p><h3 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h3><p>互联网使用的命名系统，便于人们容易理解的机器名字转换为IP地址，解决域名和IP地址的映射问题</p><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><p>HTTP最初的目的是为了提供一种发布和接收HTML页面的方法</p><p>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。</p><ol><li><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</li><li><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li><li><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li><li><strong>SEO（搜索引擎优化）</strong>：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</li></ol><h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><p>GET 和 POST 是 HTTP 协议中两种常用的请求方法，它们在不同的场景和目的下有不同的特点和用法。一般来说，可以从以下几个方面来区分二者（重点搞清两者在语义上的区别即可）：</p><ul><li>语义（主要区别）：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。</li><li>幂等：GET 请求是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。</li><li>格式：GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中，可以有多种编码格式，如 application/x-www-form-urlencoded、multipart/form-data、application/json 等。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。不过，实际上 GET 请求也可以用 body 传输数据，只是并不推荐这样做，因为这样可能会导致一些兼容性或者语义上的问题。</li><li>缓存：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。</li><li>安全性：GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 HTTP 协议本身是明文传输的，必须使用 HTTPS 协议来加密传输数据。另外，GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中。</li></ul><h3 id="WebSocket和HTTP有什么区别"><a href="#WebSocket和HTTP有什么区别" class="headerlink" title="WebSocket和HTTP有什么区别"></a>WebSocket和HTTP有什么区别</h3><p>WebSocket 和 HTTP 两者都是基于 TCP 的应用层协议，都可以在网络中传输数据。</p><p>下面是二者的主要区别：</p><ul><li>WebSocket 是一种双向实时通信协议，而 HTTP 是一种单向通信协议。并且，HTTP 协议下的通信只能由客户端发起，服务器无法主动通知客户端。</li><li>WebSocket 使用 ws:// 或 wss://（使用 SSL/TLS 加密后的协议，类似于 HTTP 和 HTTPS 的关系） 作为协议前缀，HTTP 使用 http:// 或 https:// 作为协议前缀。</li><li>WebSocket 可以支持扩展，用户可以扩展协议，实现部分自定义的子协议，如支持压缩、加密等。</li><li>WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小，而 HTTP 通信每次都要携带完整的头部，网络开销较大（HTTP/2.0 使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）。</li></ul><h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><h3 id="B，KB，MB，GB，TB"><a href="#B，KB，MB，GB，TB" class="headerlink" title="B，KB，MB，GB，TB"></a>B，KB，MB，GB，TB</h3><ul><li><strong>B</strong> 代表字节（Byte），是最小的数据单位，1个字节等于8位（bit）。</li><li><strong>KB</strong> 代表千字节（Kilobyte），1KB 等于 1024 字节（2^10 字节）。</li><li><strong>MB</strong> 代表兆字节（Megabyte），1MB 等于 1024KB，也就是 1024 * 1024 字节，即 2^20 字节。</li><li><strong>GB</strong> 代表吉字节（Gigabyte），1GB 等于 1024MB，也就是 1024 * 1024KB，即 1024210242 字节，等于 230230 字节。</li><li><strong>TB</strong> 代表太字节（Terabyte），1TB 等于 1024GB，也就是 1024 * 1024MB，即 1024310243 字节，等于 240240 字节。</li></ul><h3 id="冯诺依曼体系结构和机器的特点"><a href="#冯诺依曼体系结构和机器的特点" class="headerlink" title="冯诺依曼体系结构和机器的特点"></a>冯诺依曼体系结构和机器的特点</h3><p>五大组成，输入设备，运算器，输出设备，存储器和控制器</p><p>特点：</p><ul><li>指令和数据以二进制码表示</li><li>同等地位</li><li>指令由操作码和地址码组成</li><li>指令在存储器中顺序存放</li><li>运算器为中心</li></ul><h3 id="比特，字，字节"><a href="#比特，字，字节" class="headerlink" title="比特，字，字节"></a>比特，字，字节</h3><p><strong>比特</strong>，表示二进制位</p><p><strong>字节</strong>，byte，一个字节等于8个比特</p><p><strong>字</strong>，word，计算机进行数据处理时，一次存取，加工和传送的数据长度称为字，一个字通常是由一个或者多个字节构成。计算机的字长决定了其CPU一次操作处理实际位数的多少，由此可见计算机的字长越大，其性能越优越。</p><h3 id="RAM-和-ROM和FM"><a href="#RAM-和-ROM和FM" class="headerlink" title="RAM 和 ROM和FM"></a>RAM 和 ROM和FM</h3><p>随机存取存储器RAM，访问某个单元时间和它的物理位置没有关系</p><p>RAM包括SRAM用触发器实现，稳定，但元件多，常用cache，DRAM用电容实现，元件少，常用主存</p><p>RAM断电后数据丢失</p><p>只读存储器ROM，负责把辅存里面的OS调到RAM中，负责存储开机的详细信息</p><h3 id="计算机系统由哪两部分组成？性能取决于什么？"><a href="#计算机系统由哪两部分组成？性能取决于什么？" class="headerlink" title="计算机系统由哪两部分组成？性能取决于什么？"></a>计算机系统由哪两部分组成？性能取决于什么？</h3><p>软件和硬件，CPU（运算器，控制器）和内存（存储器），外存（硬盘）</p><h3 id="解释下什么是DMA"><a href="#解释下什么是DMA" class="headerlink" title="解释下什么是DMA"></a>解释下什么是DMA</h3><p>以主存为中心，采用硬件手段在主存与I/O设备之间建立直接的数据传送通路，由DMA控制器（DMAC）取得总线控制权，控制主存与I/O设备之间的数据传送，在传送过程中不需要CPU的程序干预的数据传送控制方式。</p><h3 id="说下五级流水CPU的各阶段"><a href="#说下五级流水CPU的各阶段" class="headerlink" title="说下五级流水CPU的各阶段"></a>说下五级流水CPU的各阶段</h3><p>取指、译码、执行、访存、写回</p><h3 id="执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？"><a href="#执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？" class="headerlink" title="执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？"></a>执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？</h3><p>单周期更快，减少段与段之间的交互开销。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="如何判断一个单链表是否是循环链表（要给出一个比遍历更快的方法）"><a href="#如何判断一个单链表是否是循环链表（要给出一个比遍历更快的方法）" class="headerlink" title="如何判断一个单链表是否是循环链表（要给出一个比遍历更快的方法）"></a>如何判断一个单链表是否是循环链表（要给出一个比遍历更快的方法）</h3><p>快慢指针法：两个指针一个每次前进1步、一个每次前进2步，相遇则循环</p><h3 id="介绍下平衡二叉树"><a href="#介绍下平衡二叉树" class="headerlink" title="介绍下平衡二叉树"></a>介绍下平衡二叉树</h3><p>一般是二叉搜索树，任意节点的子树的高度差都小于等于 1</p><h3 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h3><ul><li>时间复杂度是用于评估执行程序所消耗的时间</li><li>空间复杂度是用于评估执行程序所占用的内存空间</li></ul><h3 id="数据结构、逻辑结构、存储结构"><a href="#数据结构、逻辑结构、存储结构" class="headerlink" title="数据结构、逻辑结构、存储结构"></a>数据结构、逻辑结构、存储结构</h3><ul><li>数据结构是计算机存储和组织数据的方式</li><li>逻辑结构是指元素之间的逻辑关系，与数据的存储结构无关</li><li>存储结构是指元素在计算机中的物理存储方式</li></ul><h3 id="数据结构的4种逻辑结构"><a href="#数据结构的4种逻辑结构" class="headerlink" title="数据结构的4种逻辑结构"></a>数据结构的4种逻辑结构</h3><ul><li>集合结构:数据元素之间同属于一种类型</li><li>线性结构:数据元素之间存在一对一的关系</li><li>树形结构:数据元素之间存在一对多的关系</li><li>图状结构:数据元素之间存在多对多的关系</li></ul><h3 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h3><ul><li><p>数组需要预先从栈中分配固定的长度，不能动态增添数据项，适用于快速查找和修改，较少使用插入和删除</p></li><li><p>链表可以从堆中动态地分配空间，可以适应动态增添数据项，适用于经常插入和删除</p></li><li><p>数组支持随机访问，而链表不支持。</p></li><li><p>数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</p></li><li><p>数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！</p></li></ul><h3 id="树的存储方式"><a href="#树的存储方式" class="headerlink" title="树的存储方式"></a>树的存储方式</h3><p>双亲表示法:每个节点都有一个指向其父节点的指针<br>孩子表示法:每个节点都有一个指向其第一个孩子节点的指针，如果一个节点有多个孩子，可以使用链表将它们链接起来<br>孩子兄弟表示法:每个节点都有一个指向其第一个孩子节点和其右兄弟节点的指针<br>二叉树线性存储：用一组连续的存储单元来存放二叉树的数据元素</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>完全二叉树<br>除最后一层外，每一层的结点数都达到最大值，最后一层的结点，连续集中在最左边</p><p>堆是一颗完全二叉树，任何一个分支节点都不大于（或不小于）其左右结点的值，可以分为大顶堆、小顶堆</p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>给定n个权值作为n个叶子节点，构造一棵带权路径长度最小的二叉树叫做最优二叉树，即哈夫曼树</p><p>结点的带权路径长度:树的根结点到该结点的路径长度和该结点权重的乘积</p><p>树的带权路径长度WPL:哈夫曼树中，所有叶子结点的带权路径长度之和</p><p>构造方法:每次从森林中取出两个根节点权值最小的子树合并，分别作为新树的左右子树，新树的根节点的权值为左右子树根节点权值之和。重复n-1次这个操作，最后森林中仅剩的一棵树即是哈夫曼树。</p><p>应用:哈夫曼编码，减少编码长度</p><h3 id="最小生成树两种算法优缺点比较"><a href="#最小生成树两种算法优缺点比较" class="headerlink" title="最小生成树两种算法优缺点比较"></a>最小生成树两种算法优缺点比较</h3><p>最小生成树:寻找原图中包含n个结点边权值和最小的极小联通子图</p><p>prim:基于贪心策略，先选择一个初始点加入点集S，然后从点集S中选出弧尾未被标记且边权最小的点继续加入点集S，重复上述操作，直至图中所有的点都被收录到S中，只跟结点数有关，适用于稠密图<br>kruskal:基于贪心策略，贪心地从边集中选出一条最短的边，并使用并查集判断加入边是否会使生成树形成环，如果会，就跳过这条边，直至最后选出n-1条边，只跟边数有关，适用于稀疏图</p><h3 id="图的遍历方式"><a href="#图的遍历方式" class="headerlink" title="图的遍历方式"></a>图的遍历方式</h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>首先访问出发点V，然后访问与V邻接的未被访问的点W，直至访问完与V连通的所有结点，若还有结点未被访问，就继续重复上述操作，直至将所有图中所有的点都访问过</p><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>首先访问出发点V，并将V加入到队列中，然后弹出队列中的结点，依次访问与其邻接的且未被访问的点，并加入队列中，重复上述操作，直至将所顶点都访问过</p><h3 id="图的存储方式"><a href="#图的存储方式" class="headerlink" title="图的存储方式:"></a>图的存储方式:</h3><p>邻接矩阵 适合表示稠密图，需要较大的存储空间<br>邻接表 适合表示稀疏图，能节省存储空间，能够快速找到它的邻边<br>十字链表 针对有向图<br>邻接多重表 针对无向图</p><h3 id="快速排序的流程"><a href="#快速排序的流程" class="headerlink" title="快速排序的流程"></a>快速排序的流程</h3><p>从区间中选定一个主元，将区间划分为左、右两个子区间<br>接着可以使用插空法将大于等于主元的放到右区间，小于等于主元的放到左区间<br>同理，对主元左右两个子区间进行上述操作，直至整体有序</p><h3 id="简述背包问题"><a href="#简述背包问题" class="headerlink" title="简述背包问题"></a>简述背包问题</h3><p>背包是一个动态规划问题，问题的描述是给定一组具有重量和价值的物品，在限定重量的背包内如何放下总价值最大的物品。</p><p>可以用dp[i][j]代表前i件物品放入j容量的背包中的最大容量，对于这种情况，总共可以有两种选择，一、不放第i件物品，问题就转化为i-1件物品放入j容量的背包的情况即dp[i-1][j]，二、放第i件物品，问题就转化为i-1件物品放入j-第i件物品重量的问题，所以第i层的状态可以由i-1层状态转移过来，所以可以从初试层一直递推下去得到背包问题的最优结果</p><h3 id="KMP的主要思想"><a href="#KMP的主要思想" class="headerlink" title="KMP的主要思想"></a>KMP的主要思想</h3><p>建立一个next数组用于存储失配结点的跳转位置，实际上是<strong>存储了模式串的最大相同前后缀长度</strong>，当在某一个位置失配时，可以将模式串的前缀滑动到后缀相同的位置，从而主串匹配的位置i无需回溯，并继续从该位置继续比较</p><h3 id="二叉搜索树的优缺点"><a href="#二叉搜索树的优缺点" class="headerlink" title="二叉搜索树的优缺点"></a><strong>二叉搜索树的优缺点</strong></h3><p>二叉搜索树查找速度快、查找方便（logn时间）。但是其维护困难，且数据的插入和删除十分的复杂。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><p>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。操作系统本质上是一个运行在计算机上的软件程序 ，主要用于管理计算机硬件和软件资源。 </p><h3 id="操作系统实现的功能"><a href="#操作系统实现的功能" class="headerlink" title="操作系统实现的功能"></a>操作系统实现的功能</h3><ul><li><strong>进程和线程的管理</strong>：进程的创建、撤销、阻塞、唤醒，进程间的通信等。</li><li><strong>存储管理</strong>：内存的分配和管理、外存（磁盘等）的分配和管理等。</li><li><strong>文件管理</strong>：文件的读、写、创建及删除等。</li><li><strong>设备管理</strong>：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。</li><li><strong>网络管理</strong>：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。</li><li><strong>安全管理</strong>：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。</li></ul><h3 id="什么是用户态和内核态"><a href="#什么是用户态和内核态" class="headerlink" title="什么是用户态和内核态"></a>什么是用户态和内核态</h3><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ul><li><strong>用户态(User Mode)</strong> : 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当应用程序需要执行某些需要特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起系统调用请求，进入内核态。</li><li>**内核态(Kernel Mode)**：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。</li></ul><p>内核态相比用户态拥有更高的特权级别，因此能够执行更底层、更敏感的操作。不过，由于进入内核态需要付出较高的开销（需要进行一系列的上下文切换和权限检查），应该尽量减少进入内核态的次数，以提高系统的性能和稳定性。</p><h3 id="只有一个内核态不行吗"><a href="#只有一个内核态不行吗" class="headerlink" title="只有一个内核态不行吗"></a>只有一个内核态不行吗</h3><ul><li>在 CPU 的所有指令中，有一些指令是比较危险的比如内存分配、设置时钟、IO 处理等，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成灾难性地影响。因此，我们需要限制这些危险指令只能内核态运行。这些只能由操作系统内核态执行的指令也被叫做 <strong>特权指令</strong> 。</li><li>如果计算机系统中只有一个内核态，那么所有程序或进程都必须共享系统资源，例如内存、CPU、硬盘等，这将导致系统资源的竞争和冲突，从而影响系统性能和效率。并且，这样也会让系统的安全性降低，毕竟所有程序或进程都具有相同的特权级别和访问权限。</li></ul><h3 id="用户态和内核态是如何切换的"><a href="#用户态和内核态是如何切换的" class="headerlink" title="用户态和内核态是如何切换的"></a>用户态和内核态是如何切换的</h3><ol><li>系统调用</li><li>中断</li><li>异常</li></ol><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间</p></li><li><p>线程是比进程更小的执行单位，它是在一个进程中独立的控制流，一个进程可以启动多个线程，每条线程并行执行不同的任务。</p></li></ul><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul><li>线程是进程划分成更小的运行单位，一个进程在其执行的过程中可以产生多个线程。</li><li>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li><li>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</li></ul><h3 id="有了进程为什么还要有线程"><a href="#有了进程为什么还要有线程" class="headerlink" title="有了进程为什么还要有线程"></a>有了进程为什么还要有线程</h3><ul><li>进程切换是一个开销很大的操作，线程切换的成本较低。</li><li>线程更轻量，一个进程可以创建多个线程。</li><li>多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。</li><li>同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。</li></ul><h3 id="线程间的同步方式"><a href="#线程间的同步方式" class="headerlink" title="线程间的同步方式"></a>线程间的同步方式</h3><ul><li>互斥锁</li><li>读写锁</li><li>信号量</li><li>屏障</li><li>事件</li></ul><h3 id="进程的几种状态"><a href="#进程的几种状态" class="headerlink" title="进程的几种状态"></a>进程的几种状态</h3><blockquote><p>PCB，进程控制块</p></blockquote><ul><li>创建</li><li>就绪</li><li>运行</li><li>阻塞</li><li>结束</li></ul><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>进程间通信方式有以下几种：</p><p>1、<strong>管道通信</strong></p><p>匿名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 有名管道是半双工的通信方式，数据只能单向流动。</p><p>2、<strong>消息队列</strong></p><p>3、<strong>共享内存</strong>。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p><p>4、<strong>信号量</strong>。信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>5、套接字</p><h3 id="进程调度的衡量标准是什么？"><a href="#进程调度的衡量标准是什么？" class="headerlink" title="进程调度的衡量标准是什么？"></a>进程调度的衡量标准是什么？</h3><ul><li>CPU利用率</li><li>系统吞吐量</li><li>周转时间</li><li>等待时间</li><li>响应时间</li></ul><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ul><li>先来先服务</li><li>短作业优先</li><li>高相应比优先</li><li>时间片轮转</li><li>优先级调度</li></ul><h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h3><ul><li>阻塞</li><li>挂起</li><li>执行</li></ul><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器可以做到并发。比如有两个进程<code>A</code>和<code>B</code>，<code>A</code>运行一个时间片之后，切换到<code>B</code>，<code>B</code>运行一个时间片之后又切换到<code>A</code>。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。</p><p>并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。</p><h3 id="多线程相较单线程的好处"><a href="#多线程相较单线程的好处" class="headerlink" title="多线程相较单线程的好处"></a>多线程相较单线程的好处</h3><p>1、并发提升程序执行效率</p><p>2、提升CPU利用率，访存的时候可以切换线程来执行</p><p>3、更快的响应速度，可以有专门的线程来监听用户请求和专门的线程来处理请求。比如监听线程和工作线程是两个线程，这样监听就负责监听，工作的就负责工作，监听到用户请求马上把请求转到工作线程去处理，监听线程继续监听</p><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，它们都将无法推进下去。</p><h3 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h3><ol><li>互斥</li><li>占有并等待</li><li>非抢占</li><li>循环等待</li></ol><h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><ul><li>预防</li><li>避免</li><li>检测</li><li>解除</li></ul><h3 id="内存管理主要做了什么"><a href="#内存管理主要做了什么" class="headerlink" title="内存管理主要做了什么"></a>内存管理主要做了什么</h3><ol><li>内存的分配与回收</li><li>地址转换</li><li>内存扩充</li><li>内存映射</li><li>内存优化</li><li>内存安全</li></ol><h3 id="什么是物理地址和虚拟地址"><a href="#什么是物理地址和虚拟地址" class="headerlink" title="什么是物理地址和虚拟地址"></a>什么是物理地址和虚拟地址</h3><p><strong>物理地址（Physical Address）</strong> 是真正的物理内存中地址，更具体点来说是内存地址寄存器中的地址。程序中访问的内存地址不是物理地址，而是 <strong>虚拟地址（Virtual Address）</strong> 。</p><p>也就是说，我们编程开发的时候实际就是在和虚拟地址打交道。比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的虚拟地址。</p><h3 id="什么是分页？"><a href="#什么是分页？" class="headerlink" title="什么是分页？"></a>什么是分页？</h3><blockquote><p>把主存（物理内存）分为连续等长的物理页，应用程序的虚拟地址空间划也被分为连续等长的虚拟页。现代操作系统广泛采用分页机制。</p></blockquote><p>把内存空间划分为<strong>大小相等且固定的块</strong>，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，<strong>因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。</strong></p><p>访问分页系统中内存数据需要<strong>两次的内存访问</strong> (一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。</p><h3 id="什么是分段？"><a href="#什么是分段？" class="headerlink" title="什么是分段？"></a>什么是分段？</h3><blockquote><p>不同于分段机制下不同长度的段。</p></blockquote><p><strong>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</strong></p><p>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。</p><h3 id="分页和分段有什么区别？"><a href="#分页和分段有什么区别？" class="headerlink" title="分页和分段有什么区别？"></a>分页和分段有什么区别？</h3><ul><li>分页对程序员是透明的，但是分段需要程序员显式划分每个段。</li><li>分页的地址空间是一维地址空间，分段是二维的。</li><li>页的大小不可变，段的大小可以动态改变。</li><li>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><ul><li>都是非连续内存管理的方式。</li><li>都采用了地址映射的方法，将虚拟地址映射到物理地址，以实现对内存的管理和保护。</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li><p>分页机制以页面为单位进行内存管理，而分段机制以段为单位进行内存管理。页的大小是固定的，由操作系统决定，通常为 2 的幂次方。而段的大小不固定，取决于我们当前运行的程序。</p></li><li><p>页是物理单位，即操作系统将物理内存划分成固定大小的页面，每个页面的大小通常是 2 的幂次方，例如 4KB、8KB 等等。而段则是逻辑单位，是为了满足程序对内存空间的逻辑需求而设计的，通常根据程序中数据和代码的逻辑结构来划分。</p></li><li><p>分段机制容易出现外部内存碎片，即在段与段之间留下碎片空间(不足以映射给虚拟地址空间中的段)。分页机制解决了外部内存碎片的问题，但仍然可能会出现内部内存碎片。</p></li><li><p>分页机制采用了页表来完成虚拟地址到物理地址的映射，页表通过一级页表和二级页表来实现多级映射；而分段机制则采用了段表来完成虚拟地址到物理地址的映射，每个段表项中记录了该段的起始地址和长度信息。</p></li><li><p>分页机制对程序没有任何要求，程序只需要按照虚拟地址进行访问即可；而分段机制需要程序员将程序分为多个段，并且显式地使用段寄存器来访问不同的段。</p></li></ul><h3 id="常见的磁盘调度算法"><a href="#常见的磁盘调度算法" class="headerlink" title="常见的磁盘调度算法"></a>常见的磁盘调度算法</h3><ol><li>先来先服务</li><li>最短寻道时间</li><li>扫描</li><li>循环扫描</li><li>边扫描边观察</li><li>均衡循环扫描</li></ol><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>启动mysql服务：<code>mysql [-h 127.0.0.1] [-P 3306] -u root -p</code></p><blockquote><p>-h 指定的是连接的是哪个ip，-p指定的是连接的是哪个端口</p><p>查看当前的mysql服务开在哪个端口上，<code>show global variables like 'port'</code></p></blockquote><p>ddl，数据定义语言，定义数据库对象</p><p>dml，数据操作语言，用来对数据库表中的数据进行增删改</p><p>dql，数据查询语言，查询库中表的记录</p><p>dcl，数据控制语言，用来创建数据库用户，控制数据库的访问权限</p><p>char   性能好，定长，多余的空间用空格占位</p><p>varchar  性能稍差，变长，用多少占用多少，自动计算</p><h3 id="什么是关系型数据库"><a href="#什么是关系型数据库" class="headerlink" title="什么是关系型数据库"></a>什么是关系型数据库</h3><p>顾名思义，关系型数据库（RDB，Relational Database）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p><p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p><h3 id="MySQL的字段类型"><a href="#MySQL的字段类型" class="headerlink" title="MySQL的字段类型"></a>MySQL的字段类型</h3><ul><li><strong>数值类型</strong>：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）</li><li><strong>字符串类型</strong>：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。</li><li><strong>日期时间类型</strong>：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。</li></ul><h3 id="什么是ER图"><a href="#什么是ER图" class="headerlink" title="什么是ER图"></a>什么是ER图</h3><blockquote><p>实体联系图，提供了表示实体类型，属性和联系的方法</p></blockquote><h3 id="主键和外键有什么区别"><a href="#主键和外键有什么区别" class="headerlink" title="主键和外键有什么区别"></a>主键和外键有什么区别</h3><p>**主键(主码)**：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</p><p>**外键(外码)**：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</p><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tb_user(</span><br><span class="line">  id INT COMMENT '编号',</span><br><span class="line">name VARCHAR(50) COMMENT '姓名',</span><br><span class="line">age INT COMMENT '年龄',</span><br><span class="line">gender VARCHAR(1) COMMENT '性别'</span><br><span class="line">) COMMENT '用户表';</span><br><span class="line"></span><br><span class="line">DESC tb_user;</span><br><span class="line">show CREATE TABLE tb_user;</span><br><span class="line"></span><br><span class="line">ALTER TABLE tb_user ADD teacher VARCHAR(10); -- 添加字段</span><br><span class="line">ALTER TABLE tb_user CHANGE teacher newteacher VARCHAR(20); -- 修改字段名</span><br><span class="line">ALTER TABLE tb_user DROP newteacher; -- 删除字段</span><br><span class="line">ALTER TABLE tb_user RENAME TO user; -- 修改表名</span><br><span class="line"></span><br><span class="line">CREATE TABLE demo(</span><br><span class="line">  id INT</span><br><span class="line">);</span><br><span class="line">DROP TABLE demo; -- 删除表</span><br><span class="line">TRUNCATE TABLE demo; -- 删除表，重新创建一个名字相同的新表</span><br></pre></td></tr></tbody></table></figure><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO user (id,name,age) VALUES(12,'zhangsan',88); -- 给指定的字段添加数据</span><br><span class="line">INSERT INTO user VALUES(12,'lisi',22,'男'); -- 给整张表添加数据</span><br><span class="line">INSERT INTO user (id,name,age) VALUES(12,'zhadngsan',88),(1,'zhangsdsan',88),(2,'zhangsan',88); -- 批量添加数据</span><br><span class="line"></span><br><span class="line">UPDATE user SET id = 1,name = 2 WHERE id&gt;1; -- 如果没有条件，则会修改整张表的所有数据</span><br><span class="line"></span><br><span class="line">DELETE FROM user WHERE gender = '男'</span><br></pre></td></tr></tbody></table></figure><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><blockquote><p>基本查询，条件查询，聚合函数，分组查询，排序查询，分页查询</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">      字段列表</span><br><span class="line">FROM  </span><br><span class="line">      表名列表</span><br><span class="line">GROUP BY</span><br><span class="line">      分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">      分组后条件列表</span><br><span class="line">ORDER BY</span><br><span class="line">      排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">      分页参数</span><br></pre></td></tr></tbody></table></figure><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><blockquote><p>FROM</p><p>WHERE</p><p>GROUP BY</p><p>HAVING</p><p>SELECT</p><p>ORDER BY</p><p>LIMIT</p></blockquote><h4 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from user;</span><br><span class="line">select id from user;</span><br><span class="line">select id as '用户的id' from user;</span><br><span class="line">select distinct id from user;</span><br></pre></td></tr></tbody></table></figure><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from user</span><br><span class="line">where name is not null;</span><br></pre></td></tr></tbody></table></figure><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>执行顺序：where &gt; 聚合函数 &gt; having</p><p>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select dept_id, count(*)</span><br><span class="line">from emp</span><br><span class="line">where id &lt;= 5</span><br><span class="line">group by dept_id</span><br><span class="line">having count(*) &lt; 2;</span><br></pre></td></tr></tbody></table></figure><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><p>多字段排序，当第一个字段值相同的时候，根据第二个字段进行排序。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">order by dept_id desc, age;</span><br></pre></td></tr></tbody></table></figure><h4 id="排序查询-1"><a href="#排序查询-1" class="headerlink" title="排序查询"></a>排序查询</h4><p><code>select 字段列表 from 表名 limit 起始索引，查询记录数</code></p><ul><li>起始索引从0开始，起始索引 = （查询页码 - 1）*每页显示记录数</li><li>分页查询是数据库的方言，不同的数据库有不同的表现，MySQL中是limit</li><li>如果查询的是第一页的数据，起始索引可以省略，直接简写为limit 10</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">limit 0,2;</span><br><span class="line"></span><br><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">limit 1,3;</span><br></pre></td></tr></tbody></table></figure><h3 id="sql的几种子句是什么？顺序是什么？"><a href="#sql的几种子句是什么？顺序是什么？" class="headerlink" title="sql的几种子句是什么？顺序是什么？"></a>sql的几种子句是什么？顺序是什么？</h3><p>五个子句：</p><ul><li>from：组装来自不同数据源的数据</li><li>where：基于指定的条件对记录进行筛选</li><li>group by：将数据划分为多个分组</li><li>having：聚集函数进行计算</li><li>order by：对结果进行排序</li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><p>封装是对象功能内聚的表现形式，在抽象基础上决定信息是否公开及公开等级，核心问题是以什么方式暴漏哪些信息。主要任务是对属性、数据、敏感行为实现隐藏，对属性的访问和修改必须通过公共接口实现。封装使对象关系变得简单，降低了代码耦合度，方便维护。</p><p>迪米特原则就是对封装的要求，即 A 模块使用 B 模块的某接口行为，对 B 模块中除此行为外的其他信息知道得应尽可能少。不直接对 public 属性进行读取和修改而使用 getter/setter 方法是因为假设想在修改属性时进行权限控制、日志记录等操作，在直接访问属性的情况下无法实现。如果将 public 的属性和行为修改为 private 一般依赖模块都会报错，因此不知道使用哪种权限时应优先使用 private。</p><p>继承用来扩展一个类，子类可继承父类的部分属性和行为使模块具有复用性。继承是”is-a”关系，可使用里氏替换原则判断是否满足”is-a”关系，即任何父类出现的地方子类都可以出现。如果父类引用直接使用子类引用来代替且可以正确编译并执行，输出结果符合子类场景预期，那么说明两个类符合里氏替换原则。</p><p>多态以封装和继承为基础，根据运行时对象实际类型使同一行为具有不同表现形式。降低代码的耦合性。多态指在编译层面无法确定最终调用的方法体，在运行期由 JVM 动态绑定，调用合适的重写方法。由于重载属于静态绑定，本质上重载结果是完全不同的方法，因此多态一般专指重写。</p><h3 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h3><p>重载指方法名称相同，但参数类型个数不同，是行为水平方向不同实现。</p><p>重写指子类实现接口或继承父类时，保持方法签名完全相同，实现不同方法体，是行为垂直方向不同实现。</p><hr><h2 id="2024-8-28-17-30-线上"><a href="#2024-8-28-17-30-线上" class="headerlink" title="2024.8.28 17:30 线上"></a>2024.8.28 17:30 <code>线上</code></h2><h3 id="准备PPT了吗"><a href="#准备PPT了吗" class="headerlink" title="准备PPT了吗"></a>准备PPT了吗</h3><p>对不起，没有，我不知道需要做</p><blockquote><p>算是一次正式的面试，所以需要制作ppt</p></blockquote><h3 id="你使用go语言开发什么应用"><a href="#你使用go语言开发什么应用" class="headerlink" title="你使用go语言开发什么应用"></a>你使用go语言开发什么应用</h3><p>我一般使用gin框架开发web应用服务端</p><h3 id="你有C-的开发经验吗"><a href="#你有C-的开发经验吗" class="headerlink" title="你有C++的开发经验吗"></a>你有C++的开发经验吗</h3><p>没有，cpp只是打算法竞赛的时候作为解题的语言使用</p><h3 id="介绍一下你的大创项目"><a href="#介绍一下你的大创项目" class="headerlink" title="介绍一下你的大创项目"></a>介绍一下你的大创项目</h3><p>我突然紧张了一下，脑子空了一下，直接回答的本质上就是一个对象存储和大语言模型结合的本地知识库智能问询，知识挖掘的部分使用向量数据库的相似性检索。</p><p>&lt;项目以人工智能赋能数据存储为出发点，通过将大语言模型和对象存储功能有机结合，创建了一套兼具数据安全、资料存储、知识挖掘与智能问答的平台。深入挖掘文件知识，提供精准的智能咨询。结合对象存储，打造个性化文件管家，提升文件存取效率和协作能力。私有化部署保障数据安全，简化硬件需求，优化用户体验。&gt;</p><h3 id="知识库进行知识挖掘的过程是什么样的"><a href="#知识库进行知识挖掘的过程是什么样的" class="headerlink" title="知识库进行知识挖掘的过程是什么样的"></a>知识库进行知识挖掘的过程是什么样的</h3><blockquote><p>就是用户提问，然后到你们的题库中去匹配吗，我这样理解对吗</p></blockquote><p>不对，读取用户上传的文件，对特定格式的文件进行预处理，分词，embedding向量化，将得到的向量数据存储到向量数据库中，用户提问，对用户做出的提问进行向量化，在向量数据库中进行搜索，找出自相似的几条向量数据，将向量数据库的输出内容输出给大语言模型进行处理，生成用户能够理解的具有一定逻辑性的回答。</p><ol><li><strong>向量化处理</strong>：首先，原始数据（如文本、图像等）需要通过嵌入模型转换成向量形式。这些向量能够捕捉数据的关键特征，并以数值形式表示，便于机器处理和比较 。</li><li><strong>存储与索引</strong>：生成的向量数据随后被存储在向量数据库中，并建立相应的索引，以优化搜索效率。不同的向量数据库如Chroma、Milvus、Faiss、Weaviate等，提供了不同的索引结构和算法来加速向量搜索过程 。</li><li><strong>相似性搜索</strong>：当用户提出查询时，查询同样被转换成向量形式，并在向量数据库中执行相似性搜索，找到与查询向量最相似的向量。这个过程通常利用余弦相似度、欧氏距离等度量标准来评估向量之间的相似度 。</li><li><strong>信息检索</strong>：搜索结果通常是一组与查询向量最相似的数据向量。这些向量可以代表相关的文档、图像或其他类型的数据。</li><li><strong>LLM处理</strong>：检索到的向量或相关数据随后被用作上下文信息，输入到大型语言模型中。LLM利用这些信息生成自然语言响应，以回答用户的查询。在这个过程中，LLM可以结合检索到的知识与用户的具体需求，生成更加准确和有帮助的回答 。</li><li><strong>结果优化</strong>：为了提高生成内容的质量和相关性，可以对LLM进行微调，使其更好地适应特定的业务场景或领域知识 。</li><li><strong>用户反馈</strong>：最后，生成的内容可以展示给用户，并根据用户的反馈进行迭代优化，以不断提升系统的性能和用户体验。</li></ol><h3 id="大语言模型在项目中起到了什么样的作用"><a href="#大语言模型在项目中起到了什么样的作用" class="headerlink" title="大语言模型在项目中起到了什么样的作用"></a>大语言模型在项目中起到了什么样的作用</h3><p>大模型输入输出都是文字文本，但是模型实际接触和学习数据是向量化文本</p><p>LLM处理：检索到的向量或相关数据随后被用作上下文信息，输入到大型语言模型中。LLM利用这些信息生成自然语言响应，以回答用户的查询。在这个过程中，LLM可以结合检索到的知识与用户的具体需求，生成更加准确和有帮助的回答 。</p><h3 id="用到是哪个公司的大预言模型"><a href="#用到是哪个公司的大预言模型" class="headerlink" title="用到是哪个公司的大预言模型"></a>用到是哪个公司的大预言模型</h3><ul><li>百度：文心一言</li><li>阿里：通义千问</li><li>OpenAI：Chat-GPT</li></ul><p>else</p><ul><li>腾讯：混元助手</li><li>华为：盘古</li><li>科大讯飞：讯飞星火</li><li>清华智谱：“ChatGLM”大模型</li></ul><h3 id="你有什么特别感兴趣的算法吗"><a href="#你有什么特别感兴趣的算法吗" class="headerlink" title="你有什么特别感兴趣的算法吗"></a>你有什么特别感兴趣的算法吗</h3><p>这个被问懵了，本来是想回答我感觉巧妙的算法，比如KMP</p><p>但是具体的解释遗忘了，就给模糊过去了</p><p>“之前学过的算法都是一些常用的，没有什么特别感兴趣的”</p><h3 id="我看你给了一个个人网站的链接，这你有什么用吗"><a href="#我看你给了一个个人网站的链接，这你有什么用吗" class="headerlink" title="我看你给了一个个人网站的链接，这你有什么用吗"></a>我看你给了一个个人网站的链接，这你有什么用吗</h3><p>平时学习的时候记一些个人博客</p><h3 id="你的研究生的计划是什么"><a href="#你的研究生的计划是什么" class="headerlink" title="你的研究生的计划是什么"></a>你的研究生的计划是什么</h3><p>继续在计算机领域深造，之前学习的东西太浅显，还希望继续学习</p><p><code>moreover</code></p><p>•本科期间学习的内容都比较浅显，希望能在读研期间更深入学习计算机领域的相关知识。</p><p>•提高抗压能力和保持积极乐观的心态。</p><p>•端正态度，积极阅读专业相关论著，勤于思考。</p><p>•与导师和组内的其他同学积极交流，开拓科研视野。扎实完成科研和其他课题任务，提高自主创新能力。</p><p>•毕业找一份心仪工作。</p><h3 id="研究生的压力能够承受了吗"><a href="#研究生的压力能够承受了吗" class="headerlink" title="研究生的压力能够承受了吗"></a>研究生的压力能够承受了吗</h3><blockquote><p>强调了毕业的条件要做出一定的成果，询问一天能够在学习的时间，一周中能够工作的时间，之前有高强度地进行开发的经历吗</p></blockquote><h3 id="你有没有需要询问的问题"><a href="#你有没有需要询问的问题" class="headerlink" title="你有没有需要询问的问题"></a>你有没有需要询问的问题</h3><p>去广州会提供宿舍吗</p><blockquote><p>先在西安上学，之后到广研院，都提供宿舍</p></blockquote><p>面试的结果什么时候会出</p><blockquote><p>一两天，邮件通知，这两天我都在面试学生</p></blockquote><hr><h2 id="2024-9-23-西电广研院"><a href="#2024-9-23-西电广研院" class="headerlink" title="2024.9.23 西电广研院"></a>2024.9.23 <code>西电广研院</code></h2><blockquote><p>面试的顺序是按姓名拼音排序的，我排在了本场的倒数第三名去面试。</p><p>西电广研院今年的面试没有问及专业课的问题，考察英语能力也仅是英文的自我介绍，会问一道考察思想政治素质的题目，主要是围绕你所写的项目去展开。</p></blockquote><h3 id="英文自我介绍，一分钟"><a href="#英文自我介绍，一分钟" class="headerlink" title="英文自我介绍，一分钟"></a>英文自我介绍，一分钟</h3><h3 id="谈谈你对文化自信的理解"><a href="#谈谈你对文化自信的理解" class="headerlink" title="谈谈你对文化自信的理解"></a>谈谈你对文化自信的理解</h3><h3 id="介绍一下你的项目"><a href="#介绍一下你的项目" class="headerlink" title="介绍一下你的项目"></a>介绍一下你的项目</h3><h3 id="项目中的大模型发挥了什么作用"><a href="#项目中的大模型发挥了什么作用" class="headerlink" title="项目中的大模型发挥了什么作用"></a>项目中的大模型发挥了什么作用</h3><h3 id="平时学过或者自己复现过一些深度学习算法之类的吗"><a href="#平时学过或者自己复现过一些深度学习算法之类的吗" class="headerlink" title="平时学过或者自己复现过一些深度学习算法之类的吗"></a>平时学过或者自己复现过一些深度学习算法之类的吗</h3><h3 id="项目使用开源的东西进行开发的吗"><a href="#项目使用开源的东西进行开发的吗" class="headerlink" title="项目使用开源的东西进行开发的吗"></a>项目使用开源的东西进行开发的吗</h3><h3 id="我看你打过一些反映编程能力的比赛，你平时都学过哪些算法"><a href="#我看你打过一些反映编程能力的比赛，你平时都学过哪些算法" class="headerlink" title="我看你打过一些反映编程能力的比赛，你平时都学过哪些算法"></a>我看你打过一些反映编程能力的比赛，你平时都学过哪些算法</h3><h3 id="我看你是客户端开发，所以跟大模型对接的那些东西都是另一个同学开发的对吗"><a href="#我看你是客户端开发，所以跟大模型对接的那些东西都是另一个同学开发的对吗" class="headerlink" title="我看你是客户端开发，所以跟大模型对接的那些东西都是另一个同学开发的对吗"></a>我看你是客户端开发，所以跟大模型对接的那些东西都是另一个同学开发的对吗</h3><h3 id="学过或者说看过一些关于深度学习的课程吗"><a href="#学过或者说看过一些关于深度学习的课程吗" class="headerlink" title="学过或者说看过一些关于深度学习的课程吗"></a>学过或者说看过一些关于深度学习的课程吗</h3><h3 id="你们的项目大多数都是调用接口的吗"><a href="#你们的项目大多数都是调用接口的吗" class="headerlink" title="你们的项目大多数都是调用接口的吗"></a>你们的项目大多数都是调用接口的吗</h3><h2 id="邮件文书"><a href="#邮件文书" class="headerlink" title="邮件文书"></a>邮件文书</h2><p>尊敬的xxxx老师：</p><p>您好！</p><p>我叫xxxx，是xxxx大学xxxxx专业的大四在读学生。我今年拿到了本校推免的名额，渴望能够有机会推免攻读您的硕士，想冒昧问您一下，您今年是否还有招生名额，我能否有机会得到您的指导。</p><p>在过去三年的学习生活中，我刻苦努力，力争上游，专业排名为xx/xx。我编程基础扎实，能够独立完成简单信息管理系统从需求分析到系统设计到代码实现等的工作。我曾在xxx和xxx年连续两年获xxxxx大赛xxxxx等奖，曾获xxxxx大赛全国总决赛xxxxx奖等奖项。我于今年作为负责人参加了大学生创新创业训练计划，项目获得国家级拟立项资格。</p><p>我拥有良好的英语水平，英语四级xxx分，英语六级xxx分。我为人热情大方，活泼开朗，乐观积极向上，敢于面对并解决工作学习过程中遇到的挑战。</p><p>附件为我的简历，供您参考。</p><p>冒昧致信，恳请您海涵！非常感谢您能够在百忙之中抽出时间阅信。</p><p>祝您身体健康，工作愉快！</p><p>xxxx</p><p>xxxxxx</p><p>xxxx年x月xx日</p><h2 id="EnglishProficiency"><a href="#EnglishProficiency" class="headerlink" title="EnglishProficiency"></a>EnglishProficiency</h2><h3 id="SelfIntroduction"><a href="#SelfIntroduction" class="headerlink" title="SelfIntroduction"></a>SelfIntroduction</h3><blockquote><p>Please start your introduction</p><p>Please tell me about yourself / introduce yourself</p><p>What would you like us to know about you ?</p></blockquote><blockquote><p>本身没有什么特别的长处，感觉这样也好表达，同时我想让他人了解的东西都有所提及，算是简单介绍了一下，关键要看流利度和停顿我赶脚。</p></blockquote><p>Good morning / afternoon, It’s very nice to meet you professors. It’s an honor to be here today.</p><p>My name is tammer. I’m a senior student majoring in Computer Science and Technology at …… University. I’m currently excelling in my courses, and I’m ranked second in my major. I’ve also received provincial first price award for my performance in Lanqiao Cup Competition. And our team won the provincial second prise in the Chinese Collegiate Computing Competition for two consecutive years. </p><p>In my study, I’m especially interested in Artificial Intellegence, so I formed a team to research developing applications powered by large language models. After several months of coding, we finally developed a local knowledge base question-answering system. Within my team, I was chosen to complete the concept design and client code implementation because I‘m good at front-end development.</p><p>Besides, I’m very observant, adaptable, flexible with people and situations and always ready to learn new things. I firmly believe physical fitness should be an essential part of life like eating and sleeping. So during my spare time I would go to the gym and exercise for an hour, and after that the fatigue of the day would disappear.</p><p>I believe these qualities will make me better fulfill my role as a graduate student in the future.</p><p>That’s all, thank you! </p><p><code>2 to 3 minutes</code></p><p>Good morning / afternoon, It’s very nice to meet<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>you professors. It’s an <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>honor to be here today.</p><p>My name<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> is tammer. I’m <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>a senior student majoring in Computer Science <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>and Technology at …… University. I’m currently excelling<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> in my courses, and <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>I’m ranked second in my major. Additionally, I’ve also received provincial first price <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>award for my performance in Lanqiao Cup Competition. And <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>our team won the provincial second prise in the Chinese Collegiate Computing Competition for two consecutive years. </p><p>In my study, I’m interested<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> in Artificial Intellegence, so I formed <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>a team to research developing applications powered by large language models. After several months <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>of coding, we finally developed<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> a local knowledge base question-answering system. Within my team, I was chosen to complete the concept design and client code implementation because I‘m good <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>at front-end development.</p><p>Besides, I’m very observant, adaptable, flexible with people <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>and situations and <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>always ready to learn new things. I firmly believe physical fitness should be an essential part<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> of life like eating and sleeping. So during my spare time I would go to the gym and exercise for <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>an <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>hour, and <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>after that the fatigue of the day would disappear.</p><p>I believe these qualities will make me better fulfill my role<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> as <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>a graduate student in the future.</p><p>That’s all, thank you! </p><h3 id="OtherQuestion"><a href="#OtherQuestion" class="headerlink" title="OtherQuestion"></a>OtherQuestion</h3><blockquote><p>why do you choose our school ?</p></blockquote><p>because xi’dian is famous in computer, and i want to study further in computer science and technology, so choose it, and i would be glad to enter it.</p><h2 id="行远自迩，登高自卑"><a href="#行远自迩，登高自卑" class="headerlink" title="行远自迩，登高自卑"></a>行远自迩，登高自卑</h2><blockquote><p>行远自迩，登高自卑，行走远路要从近处开始，登高山要从低处开始，比喻做事要脚踏实地，循序渐进。</p></blockquote><h2 id="思想政治素质"><a href="#思想政治素质" class="headerlink" title="思想政治素质"></a>思想政治素质</h2><h3 id="根本政治制度"><a href="#根本政治制度" class="headerlink" title="根本政治制度"></a>根本政治制度</h3><p>人民代表大会制度</p><h3 id="指导思想"><a href="#指导思想" class="headerlink" title="指导思想"></a>指导思想</h3><ul><li>马克思列宁主义</li><li>毛泽东思想</li><li>邓小平理论</li><li>“三个代表”重要思想<ol><li>代表中国先进生产力的发展要求</li><li>代表中国先进文化的前进方向</li><li>代表中国最广大人民的根本利益</li></ol></li><li>科学发展观</li><li>习近平新时代中国特色社会主义思想</li></ul><h3 id="四个自信"><a href="#四个自信" class="headerlink" title="四个自信"></a>四个自信</h3><ul><li>道路自信</li><li>理论自信</li><li>制度自信</li><li>文化自信</li></ul><h3 id="初心使命"><a href="#初心使命" class="headerlink" title="初心使命"></a>初心使命</h3><p>为中国人民谋幸福，为中华民族谋复兴</p><h3 id="新时代"><a href="#新时代" class="headerlink" title="新时代"></a>新时代</h3><p>如今实现了第一个百年奋斗目标（全面建成小康社会），开启了第二个百年奋斗目标新征程（建成富强民主文明和谐美丽的社会主义现代化强国。</p><p>我国正处于并将长期处于社会主义初级阶段</p><h3 id="执政兴国的第一要务"><a href="#执政兴国的第一要务" class="headerlink" title="执政兴国的第一要务"></a>执政兴国的第一要务</h3><p>发展，坚持以人民为中心的发展思想</p><h3 id="基本路线"><a href="#基本路线" class="headerlink" title="基本路线"></a>基本路线</h3><p>领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为一个富强民主文明和谐美丽的社会主义现代化强国而奋斗。</p><h3 id="四项基本原则"><a href="#四项基本原则" class="headerlink" title="四项基本原则"></a>四项基本原则</h3><ul><li>坚持社会主义道路</li><li>坚持人民民主专政</li><li>坚持中国共产党的领导</li><li>坚持马克思列宁主义毛泽东思想</li></ul><h3 id="入党誓词"><a href="#入党誓词" class="headerlink" title="入党誓词"></a>入党誓词</h3><p>我志愿加入中国共产党，拥护党的纲领，遵守党的章程，履行党员义务，执行党的决定，严守党的纪律，保守党的秘密，对党忠诚，积极工作，为共产主义奋斗终身，随时准备为党和人民牺牲一切，永不叛党。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>面试题部分：JavaGuide</li><li>思想政治素质部分：党章</li></ul>]]></content>
    
    
    <summary type="html">2024年9月面试的准备</summary>
    
    
    
    <category term="面试" scheme="https://dra-tammer.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="经验" scheme="https://dra-tammer.github.io/categories/%E9%9D%A2%E8%AF%95/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="推免" scheme="https://dra-tammer.github.io/categories/%E9%9D%A2%E8%AF%95/%E7%BB%8F%E9%AA%8C/%E6%8E%A8%E5%85%8D/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="面试" scheme="https://dra-tammer.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="经验" scheme="https://dra-tammer.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="推免" scheme="https://dra-tammer.github.io/tags/%E6%8E%A8%E5%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>zinx-go</title>
    <link href="https://dra-tammer.github.io/posts/b5221bcc.html"/>
    <id>https://dra-tammer.github.io/posts/b5221bcc.html</id>
    <published>2024-05-07T13:24:04.000Z</published>
    <updated>2024-09-03T13:53:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zinx-go"><a href="#zinx-go" class="headerlink" title="zinx-go"></a>zinx-go</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h3><blockquote><p>套接字是网络编程中的一种通信机制，是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p></blockquote><h4 id="为什么使用套接字"><a href="#为什么使用套接字" class="headerlink" title="为什么使用套接字"></a>为什么使用套接字</h4><blockquote><p>接打电话需要什么？</p><p>电话机</p></blockquote><p>那么套接字就相当于一个电话机，为两边建立TCP提供载体。</p><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><blockquote><p>电话号码是多少</p><p>电话号码是 ***</p></blockquote><p>调用bind函数给套接字分配地址之后，完成准备工作。</p><h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><blockquote><p>架起电话线，使得电话能够打进来</p></blockquote><p>把套接字的状态转换为可连接的状态</p><h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><blockquote><p>电话铃响</p><p>接听</p></blockquote><p>受理套接字请求</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>创建套接字</li><li>分配IP地址和端口号</li><li>状态转换为可接收请求的状态</li><li>受理套接字请求</li></ol><p>TCP客户—服务器程序的执行流程图</p><h3 id="字节和比特"><a href="#字节和比特" class="headerlink" title="字节和比特"></a>字节和比特</h3><blockquote><p>byte 是字节，一个字节8个比特位</p><p>bit 是比特</p></blockquote><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>就是假如有一个都要调用的函数<code>func_pro</code>，很多人都要用，每个人在一个固定的点上加上自己的业务，当然不能用<code>if else</code>，这时候使用者在调用这个函数的时候传入一个封装有自己业务逻辑的函数变量。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func_pro</span><span class="params">(<span class="keyword">func</span> f)</span></span> {</span><br><span class="line">    ...</span><br><span class="line">    f()</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这个函数变量就是回调函数</p></blockquote><h3 id="实例方法与静态方法"><a href="#实例方法与静态方法" class="headerlink" title="实例方法与静态方法"></a>实例方法与静态方法</h3><blockquote><p> 实例方法是实例化之后才能使用</p></blockquote><h3 id="路由是干什么的"><a href="#路由是干什么的" class="headerlink" title="路由是干什么的"></a>路由是干什么的</h3><blockquote><p>提供一个指令，指令对应的一个处理方式，指令和处理方式放在一起叫路由，不同消息不同路由</p></blockquote><h3 id="为什么在Connection中实现接口"><a href="#为什么在Connection中实现接口" class="headerlink" title="为什么在Connection中实现接口"></a>为什么在Connection中实现接口</h3><p>在Go语言中，接口（interface）是一种抽象类型，它定义了一组方法的集合，但并不实现这些方法的具体行为。接口的实现是通过类型为该接口的值来完成的，这些值可以是任何具有相应方法集的具体类型（通常是结构体）。这种设计允许多种不同的类型实现同一个接口，从而提供了一种灵活的方式来实现多态性。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IRouter <span class="keyword">interface</span> {</span><br><span class="line">    PreHandle(request IRequest)</span><br><span class="line">    Handle(request IRequest)</span><br><span class="line">    PostHandle(request IRequest)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Connection <span class="keyword">struct</span> {</span><br><span class="line">    Router ziface.IRouter</span><br><span class="line">    <span class="comment">// ... 其他字段 ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>Router</code> 字段的类型是 <code>ziface.IRouter</code> 接口。这里有几个关键点：</p><ol><li><p><strong>多态性</strong>：通过在 <code>Connection</code> 结构体中使用 <code>IRouter</code> 接口类型，您可以将任何实现了 <code>IRouter</code> 接口的具体类型赋值给 <code>Router</code> 字段。这意味着 <code>Connection</code> 可以与多种不同的路由处理逻辑一起工作，只要这些逻辑实现了 <code>IRouter</code> 接口。</p></li><li><p><strong>解耦</strong>：接口允许 <code>Connection</code> 结构体与具体的路由实现解耦。<code>Connection</code> 不需要知道 <code>Router</code> 字段的具体类型，只需要知道它实现了 <code>IRouter</code> 接口。</p></li><li><p><strong>扩展性</strong>：如果您需要添加新的路由处理逻辑，您只需创建一个新的类型并实现 <code>IRouter</code> 接口中的方法，而无需修改 <code>Connection</code> 结构体或其它使用 <code>IRouter</code> 的代码。</p></li><li><p><strong>实现接口而不是对象</strong>：在Go中，通常推荐实现接口而不是直接实现具体的对象。这是因为接口提供了一种定义契约的方式，任何类型都可以实现这个契约，从而使得代码更加灵活和可扩展。</p></li><li><p><strong>依赖注入</strong>：通过接口，可以实现依赖注入的设计模式，这是软件设计中常用的一种提高代码可测试性和可维护性的方法。</p></li></ol><p>因此，<code>Router</code> 字段被声明为接口类型，而不是一个具体的对象，是为了提供灵活性和可扩展性，同时允许 <code>Connection</code> 结构体与具体的路由实现保持解耦。</p><h2 id="基础的server"><a href="#基础的server" class="headerlink" title="基础的server"></a>基础的server</h2><ul><li><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>启动服务器</p><p>基本的服务器开发：</p><ol><li><p>创建addr </p></li><li><p>创建listenner </p></li><li><p>处理客户端的基本的业务，回显功能</p></li></ol></li><li><p>停止服务器</p></li><li><p>运行服务器</p><p>调用Start()方法，调用之后做阻塞处理，在之间可以做一个今后的一个扩展功能</p></li><li><p>初始化服务器</p></li></ul></li><li><p>属性</p><ul><li>name名称</li><li>监听的IP</li><li>监听的端口</li></ul></li></ul><p>先创建两个模块，一个是抽象层接口，一个是实现层</p><h2 id="简单的链接封装和业务绑定"><a href="#简单的链接封装和业务绑定" class="headerlink" title="简单的链接封装和业务绑定"></a>简单的链接封装和业务绑定</h2><ul><li><p>链接的模块</p><ul><li><p>方法</p><ul><li><p>启动链接start</p></li><li><p>停止链接stop</p></li><li><p>获取当前链接的conn对象（套接字）</p></li><li><p>绑定一个链接ID</p></li><li><p>得到客户端链接的地址和端口</p></li><li><p>发送数据的方法send</p><p>发送数据到客户端</p></li></ul></li><li><p>属性</p><ul><li><p>socket TCP套接字</p></li><li><p>链接的ID</p></li><li><p>当前链接的状态</p><p>是否已经关闭，关闭应该把链接给干掉或者回收掉</p></li><li><p>与当前链接所绑定的处理业务方法</p></li><li><p>等待被告知的channel告知当前链接是退出，这是一个异步过程，channel去捕获这个状态，等待链接被动退出的channel</p></li></ul></li></ul></li></ul><h2 id="基础路由模块"><a href="#基础路由模块" class="headerlink" title="基础路由模块"></a>基础路由模块</h2><p>现在我们就给用户提供一个自定义的conn处理业务的接口吧，很显然，我们不能把业务处理的方法绑死在<code>type HandFunc func(*net.TCPConn, []byte, int) error</code>这种格式中，我们需要定一些<code>interface{}</code>来让用户填写任意格式的连接处理业务方法。</p><p>那么，很显然func是满足不了我们需求的，我们需要再做几个抽象的接口类。</p><h3 id="request请求封装"><a href="#request请求封装" class="headerlink" title="request请求封装"></a>request请求封装</h3><blockquote><p>将连接和数据绑定在一起，看成一个元子的请求包</p><p>router应该是基于这个request包进行处理</p></blockquote><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li>链接IConnection</li><li>请求数据</li></ul><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul><li>得到当前连接</li><li>得到当前数据</li></ul><h3 id="Router模块"><a href="#Router模块" class="headerlink" title="Router模块"></a>Router模块</h3><h4 id="抽象的router"><a href="#抽象的router" class="headerlink" title="抽象的router"></a>抽象的router</h4><h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><ul><li><p>处理业务之前的方法（钩子）</p></li><li><p>处理业务的主方法</p></li><li><p>处理业务之后的方法（钩子）</p></li></ul><h4 id="具体的BaseRouter"><a href="#具体的BaseRouter" class="headerlink" title="具体的BaseRouter"></a>具体的BaseRouter</h4><h5 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h5><ul><li><p>处理业务之前的方法（钩子）</p></li><li><p>处理业务的主方法</p></li><li><p>处理业务之后的方法（钩子）</p></li></ul><h4 id="自定义的router"><a href="#自定义的router" class="headerlink" title="自定义的router"></a>自定义的router</h4><p>继承BaseRouter去重写方法</p><h4 id="为什么还要搞一个BaseRouter"><a href="#为什么还要搞一个BaseRouter" class="headerlink" title="为什么还要搞一个BaseRouter"></a>为什么还要搞一个BaseRouter</h4><p>因为如果每一个自定义的router都继承接口，就要实现接口中的所有方法，但是我们不一定需要hook函数。所以baserouter先空实现接口的方法，然后再让自定义的router去继承baserouter，实现自己想要的函数</p><h3 id="zinx集成router模块"><a href="#zinx集成router模块" class="headerlink" title="zinx集成router模块"></a>zinx集成router模块</h3><ul><li>IServer增添路由添加功能</li><li>Server类增添Router成员</li><li>Connection类绑定一个Router成员</li><li>在Connection调用已经注册的Router处理业务</li></ul><h2 id="Q-S"><a href="#Q-S" class="headerlink" title="Q&amp;S"></a>Q&amp;S</h2><blockquote><p>在这个包去import其他包的东西的时候会爆红，取消勾选</p></blockquote><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable <span class="keyword">go</span> modules integration</span><br></pre></td></tr></tbody></table></figure><hr><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server.<span class="keyword">go</span>:<span class="number">3</span>:<span class="number">8</span>: <span class="keyword">package</span> zinx-<span class="keyword">go</span>/znet is not in GOROOT (D:\Environment\Go\src\zinx-<span class="keyword">go</span>\znet)</span><br></pre></td></tr></tbody></table></figure><p>需要引入本地包的话，需要在go.mod中进行修改，两个项目都在src目录下，如下即可解决问题。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require <span class="string">"zinx-go"</span> v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">replace <span class="string">"zinx-go"</span> =&gt; <span class="string">"../zinx-go"</span></span><br></pre></td></tr></tbody></table></figure><hr>]]></content>
    
    
    <summary type="html">学习zinx的工程中的笔记</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="go" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/go/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="go" scheme="https://dra-tammer.github.io/tags/go/"/>
    
    <category term="项目" scheme="https://dra-tammer.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>《追风筝的人》</title>
    <link href="https://dra-tammer.github.io/posts/ab39eefc.html"/>
    <id>https://dra-tammer.github.io/posts/ab39eefc.html</id>
    <published>2024-04-24T03:02:39.000Z</published>
    <updated>2024-09-03T14:01:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="追风筝的人"><a href="#追风筝的人" class="headerlink" title="追风筝的人"></a>追风筝的人</h1><p><code>start from 2024-04-12</code></p><p><code>end on 2024-04-24</code></p><p><code>卡勒德·胡塞尼</code></p>]]></content>
    
    
    <summary type="html">作者：卡勒德·胡塞尼</summary>
    
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《杀死一只知更鸟》</title>
    <link href="https://dra-tammer.github.io/posts/842c0a9a.html"/>
    <id>https://dra-tammer.github.io/posts/842c0a9a.html</id>
    <published>2024-04-10T02:27:04.000Z</published>
    <updated>2024-09-03T14:06:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="杀死一只知更鸟"><a href="#杀死一只知更鸟" class="headerlink" title="杀死一只知更鸟"></a>杀死一只知更鸟</h1><p><code>start from 2024-04-03</code></p><p><code>end on 2024-04-10</code></p><p><code>哈珀·李</code></p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>我是通过微信读书的榜单知道这本书的，刚开始阅读的时候并没有这么上瘾，在交代斯库特，杰姆，迪尔他们的童年生活，一开始很疑惑这个阿迪克斯是什么人，随着阅读的深入，发现是他们的爸爸。他允许自己的孩子呼喊自己的名字，这点很特殊。幼年的孩子们天真烂漫，富有好奇心，他们想瞥见怪人拉德利的生活，并无恶意地去“打扰”怪人的生活，最后也获得了回应，树洞里的礼物证明了这一点，但是最后树洞被水泥封上了。之后故事围绕汤姆的强奸案展开，从这开始，我逐渐开始上瘾。黑人被最底层的白人造谣强奸，在当时的社会这是要判处死刑，但是阿迪克斯根据证据发现他是清白的。他一直努力在帮助黑人脱罪，但是最后还是杀不死人们一贯的偏见。汤姆也摆脱不了固有的天性，反抗被枪杀。在这个过程上，我和周围人都在不停地成长，周围人的形象也在一步一步地立体了起来。本书以尤厄尔的死亡告终，赫克和阿迪克斯都在用自己的方式去帮助那个怪人，去守护那一片纯真的心灵。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><blockquote><p>阿迪克斯是一位伟大的父亲，也是普通人的榜样</p></blockquote><p>阿迪克斯是一名律师，为他人声张正义，他一直为自己内心的正义工作，即便受到死亡威胁，他也不害怕。能够克服当时固有的种族歧视去帮助一个黑人脱罪。虽然最后没有成功，但是大家都知道他是能够无偏见地去帮助每一个人去声张正义。正义之士的形象跃然纸上。</p><p>同时他也是一名父亲，对孩子们管教有加，在怪人拉德利的事情上，阿迪克斯给与了孩子们最大的探索空间，告诉孩子们危险之处在哪，但是没有过多的阻拦，只做了最基础的警告。能够陪孩子们一起看报，将自己的思想传播给孩子们，给予孩子们平等的说话权。在孩子们犯错的时候给孩子们时间去解释整个事情的流程，而不是妄加指责。他是孩子们的父亲，良师和益友。他教会孩子们为人处世的道理，耐心纠正孩子们的错误，同时又给孩子们最大的个人思考的空间。这种教育的方式值得借鉴，同时也是理想的教育方式。</p><blockquote><p>不要用自己的标准去衡量和要求别人</p></blockquote><p>小说的最后杰姆看不懂看不惯人们的做法，为什么他们明知道事实的真相，但是却选择了撒谎。他认为其他人的做法都是错的。这个对我的思考很大，最近在组队搞比赛。组内的大佬一股子恃才放旷味道，也是火上眉头，差点冲突。但是看完这本书之后一想，每个人有每个人待人处事的方式，这或许就是他这个人的特点，我们不能拿我们认为对的东西去严加要求别人应该怎么干，怎么做事。自己做事问心无愧即可。</p><blockquote><p>优秀的人懂得尊重别人</p></blockquote><p>鲁迅先生曾经说过(应该是)，我原先以为别人尊重我是因为我优秀，后来发现，别人尊重我是因为别人优秀。无论面对的是谁，都要把对方当作人去看待。</p><blockquote><p>有些道理是成长之后才会知道的</p></blockquote><p>有时候不了解父母的某些做法，是不是因为阅历不够，经验不足呢。</p><blockquote><p>低调做人，高调做事</p></blockquote><p>阿迪克斯就是这一类人，自己本身其实非常优秀，但是他并没在孩子们面前鼓吹自己有多么多么牛掰，自己跟其他的父母相比有多么多么地好，而是将自己的价值观一点一点在平时的生活中传递给孩子们。在与孩子们生活的过程中让孩子们觉得自己父亲的本事是理所应当的，是能够深刻体会到的，而不是靠嘴吹牛逼出来的。</p><p>这是大三下学期看的第一本书，清明之后集中给他看完了，看后心中平静了不少，清明左右拔了两颗牙，又碰上计设ddl，难免火气大，感谢自己撑住了三天，感谢文字，无论是课程老师传授还是文字表达，都能让我犯错或者迷茫之时找到方向，有所启发，瞥见他人思想，他人经验总结出来的精华。同时又遇到了一位她，老去的心又年轻了一回hh，但是可惜。</p><p>好，再会！</p>]]></content>
    
    
    <summary type="html">作者：哈珀·李</summary>
    
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://dra-tammer.github.io/posts/f5f9fa9b.html"/>
    <id>https://dra-tammer.github.io/posts/f5f9fa9b.html</id>
    <published>2024-02-15T06:22:52.000Z</published>
    <updated>2024-09-03T14:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="Windows配置Docker环境"><a href="#Windows配置Docker环境" class="headerlink" title="Windows配置Docker环境"></a>Windows配置Docker环境</h2><h3 id="启用Hyper-v"><a href="#启用Hyper-v" class="headerlink" title="启用Hyper-v"></a>启用Hyper-v</h3><ul><li>控制面板</li><li>程序</li><li>启动或关闭windows功能</li><li>Hyper-v</li></ul><h3 id="WSL及Linux分发版安装"><a href="#WSL及Linux分发版安装" class="headerlink" title="WSL及Linux分发版安装"></a>WSL及Linux分发版安装</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wsl --install </span><br><span class="line">wsl --list --online <span class="comment">// 查看可用的Linux发行版列表</span></span><br><span class="line">wsl --install -d <span class="title class_">Ubuntu</span>-<span class="number">22.04</span></span><br></pre></td></tr></tbody></table></figure><h3 id="修改WSL中系统的安装位置"><a href="#修改WSL中系统的安装位置" class="headerlink" title="修改WSL中系统的安装位置"></a>修改WSL中系统的安装位置</h3><ul><li><p>查看所有分发版本<code>wsl -l --all -v</code></p></li><li><p>导出分发版为tar文件到D盘<code>wsl --export Ubuntu-22.04 D:\Environment\ubuntu22.04.tar</code></p></li><li><p>注销当前分发版<code>wsl --unregister Ubuntu-22.04</code></p></li><li><p>重新导入并安装分发版在D盘</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --<span class="keyword">import</span> <span class="title class_">Ubuntu</span>-<span class="number">22.04</span> <span class="attr">D</span>:\<span class="title class_">Environment</span>\<span class="title class_">Ubuntu22</span><span class="number">.04</span> <span class="attr">D</span>:\<span class="title class_">Environment</span>\ubuntu22<span class="number">.04</span>.<span class="property">tar</span> --version <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>设置默认登录用户<code>ubuntu2204 config --default-user root</code></p></li><li><p>删除tar文件<code>del D:\ubuntu22.04.tar</code></p></li></ul><h3 id="DockerDesktop"><a href="#DockerDesktop" class="headerlink" title="DockerDesktop"></a>DockerDesktop</h3><p>官网下载安装<code>DockerDesktop</code>，最大的问题就是默认安装在c盘，十分占用c盘的空间</p><h4 id="更改DockerDesktop的安装目录"><a href="#更改DockerDesktop的安装目录" class="headerlink" title="更改DockerDesktop的安装目录"></a>更改DockerDesktop的安装目录</h4><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd /c mklink /j <span class="string">"C:\Program Files\Docker"</span> <span class="string">"D:\SoftWare\DockerDesktop"</span></span><br></pre></td></tr></tbody></table></figure><p>实测创建连接的方法不可行，能安装上但是<code>Docker Engine</code>无法启动，会报错<code>Docker Desktop - WSL distro terminated abruptly</code>，看来只能装到C盘，先卸载，再删除链接目录<code>rmdir D:\Software\DockerDesktop</code></p><blockquote><p>todo: 镜像安装的文件夹，没法修改，导致下载会都下载到C盘很难受</p></blockquote><p><a href="https://docker.easydoc.net/doc/81170005/cCewZWoN/lTKfePfP">🎉 Docker 简介和安装 - Docker 快速入门 - 易文档 (easydoc.net)</a></p><h2 id="为什么使用docker"><a href="#为什么使用docker" class="headerlink" title="为什么使用docker"></a>为什么使用docker</h2><p>方便测试和生产环境部署，省去很多环境配置的时间</p><h2 id="和虚拟机的区别"><a href="#和虚拟机的区别" class="headerlink" title="和虚拟机的区别"></a>和虚拟机的区别</h2><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>每台虚拟机需要占用大量的资源，启动时间长。因为需要完整的操作系统，cpu占用等。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>docker只是container的一种的实现，是一种容器化的解决方案和平台。</p><p>容器不需要在虚拟化的环境中运行一个操作系统，而是使用宿主机的操作系统，启动速度非常快。需要的资源更少，充分利用物理服务器的资源。</p><h2 id="基本原理和概念"><a href="#基本原理和概念" class="headerlink" title="基本原理和概念"></a>基本原理和概念</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>镜像是一个只读的模板，它可以用来创建容器。</p><h3 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h3><p>容器是docker的运行实例，他提供了一个独立的可移植的环境。可以在这个环境中运行应用程序。镜像和容器的关系就像java中类和实例的关系一样。</p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>存储docker镜像的地方，最流行也是常用的仓库就是dockerhub，公共的docker仓库。</p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>Client-Server架构模式，</p><h2 id="容器化和Dockerfile"><a href="#容器化和Dockerfile" class="headerlink" title="容器化和Dockerfile"></a>容器化和Dockerfile</h2><ol><li>创建一个Dockerfile</li><li>使用Dockerfile构建镜像</li><li>使用镜像创建和运行容器</li></ol><blockquote><p>如果想要在浏览器之外的环境运行javascipt的代码，就要安装node.js，通过<code>node index.js</code>运行index文件的代码</p></blockquote><h2 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h2><h3 id="镜像的构建"><a href="#镜像的构建" class="headerlink" title="镜像的构建"></a>镜像的构建</h3><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build <span class="literal">-t</span> hello<span class="literal">-docker</span> .</span><br></pre></td></tr></tbody></table></figure><h3 id="镜像的运行"><a href="#镜像的运行" class="headerlink" title="镜像的运行"></a>镜像的运行</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-docker</span><br></pre></td></tr></tbody></table></figure><h3 id="查看镜像库"><a href="#查看镜像库" class="headerlink" title="查看镜像库"></a>查看镜像库</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></tbody></table></figure><h2 id="推荐网站"><a href="#推荐网站" class="headerlink" title="推荐网站"></a>推荐网站</h2><p>play-with-docker 尝试docker的各种功能</p><h2 id="docker-desktop"><a href="#docker-desktop" class="headerlink" title="docker-desktop"></a>docker-desktop</h2><p>docker数据是非持久化的，需要持久化就使用Volumes功能。</p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><ul><li>用于定义和运行多容器Docker应用程序的工具</li><li>使用YAML文件来配置应用程序的服务</li><li>一条命令就可以创建并启动所有服务</li></ul>]]></content>
    
    
    <summary type="html">The notes token when learning how to use docker.</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    <category term="部署" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/docker/%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://dra-tammer.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>gpt</title>
    <link href="https://dra-tammer.github.io/posts/ca8ec864.html"/>
    <id>https://dra-tammer.github.io/posts/ca8ec864.html</id>
    <published>2024-02-08T03:06:37.000Z</published>
    <updated>2024-12-02T14:04:20.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>非英伟达显卡+win10+Python3.11</p><p><a href="https://blog.csdn.net/pointer_onlysoul/article/details/121354353">PyTorch 安装（非英伟达显卡+win10+Python3.8）_python3.8安装pytorch-CSDN博客</a></p><h3 id="anaconda"><a href="#anaconda" class="headerlink" title="anaconda"></a>anaconda</h3><p>python的一个发行版本，python的运行环境，就是python的包管理器，简化包管理功能和部署</p><h3 id="NAVIDIA-CUDA"><a href="#NAVIDIA-CUDA" class="headerlink" title="NAVIDIA &amp; CUDA"></a>NAVIDIA &amp; CUDA</h3><blockquote><p>运算平台，让python等程序语言可以同时在cpu和gpu上跑的一个平台。</p></blockquote><p>cuda的安装就是安装cuda toolkit（cuda工具包）加上cuda驱动。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="LLM-Large-Language-Model"><a href="#LLM-Large-Language-Model" class="headerlink" title="LLM(Large Language Model)"></a>LLM(Large Language Model)</h3><p>一种基于深度学习技术的自然语言处理模型，也被称作大语言模型。它可以学习自然语言的语法和语义，从而生成可读的文本。</p><h3 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h3><p>向模型提供输入以引导其生成特定输出的文本或指令。它是与模型进行交互时用户提供的文本段落，用于描述用户想要从模型获取的信息、回答、文本等内容。Prompt 的目的是引导模型产生所需的回应，以便更好地控制生成的输出。</p><h3 id="向量数据库"><a href="#向量数据库" class="headerlink" title="向量数据库"></a>向量数据库</h3><h4 id="GPT-tokens限制"><a href="#GPT-tokens限制" class="headerlink" title="GPT tokens限制"></a>GPT tokens限制</h4><p>GPT 作为 LLM 模型是没有记忆功能的，所谓的记忆功能只是开发者将对话记录存储在内存或者数据库中，当你发送消息给 gpt 模型时，程序会自动将最近的几次对话记录（基于对话的字数限制在 4096 tokens 内）通过 prompt 组合成最终的问题，并发送给 ChatGPT。简而言之，如果你的对话记忆超过了 4096 tokens，那么它就会忘记之前的对话，这就是目前 GPT 在需求比较复杂的任务中无法克服的缺陷。</p><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><blockquote><p>向量数据库的核心思想是将文本转换成向量，然后将向量存储在数据库中，当用户输入问题时，将问题转换成向量，然后在数据库中搜索最相似的向量和上下文，最后将文本返回给用户</p></blockquote><p>当我们有一份文档需要 GPT 处理时，例如这份文档是客服培训资料或者操作手册，我们可以先将这份文档的所有内容转化成向量（这个过程称之为 Vector Embedding<vector embedding="">），然后当用户提出相关问题时，我们将用户的搜索内容转换成向量，然后在数据库中搜索最相似的向量，匹配最相似的几个上下文，最后将上下文返回给 GPT。这样不仅可以大大减少 GPT 的计算量，从而提高响应速度，更重要的是降低成本，并绕过 GPT 的 tokens 限制。</vector></p><h4 id="Vector-Embedding"><a href="#Vector-Embedding" class="headerlink" title="Vector Embedding"></a>Vector Embedding</h4><h5 id="传统的数据库"><a href="#传统的数据库" class="headerlink" title="传统的数据库"></a>传统的数据库</h5><blockquote><p>本质上是基于文本的精确匹配，这种索引和搜索算法对于关键字的搜索功能非常合适，但对于语义搜索功能就非常弱</p></blockquote><p>传统数据库无法识别语义关系，例如搜索小狗没法得到柯基等结果，传统的应用需要人为地打上特征标签进行关联。如何生成和挑选特征这个过程(特征工程<feature engineering="">)将原始数据转化成更好的表达问题本质的特征的过程。自动化的方式来提取这些特征，而这可以通过 Vector Embedding 实现。</feature></p><h4 id="特征和向量"><a href="#特征和向量" class="headerlink" title="特征和向量"></a>特征和向量</h4><blockquote><p>向量数据库的核心在于相似性搜索(Similarity Search)</p></blockquote><p>我们会通过识别不同事物之间不同的特征来识别种类，例如分别不同种类的小狗，就可以通过体型大小、毛发长度、鼻子长短等特征来区分。如下面这张照片按照体型排序，可以看到体型越大的狗越靠近坐标轴右边，这样就能得到一个体型特征的一维坐标和对应的数值，从 0 到 1 的数字中得到每只狗在坐标系中的位置。</p><p>然而单靠一个体型大小的特征并不够，像照片中哈士奇、金毛和拉布拉多的体型就非常接近，我们无法区分。所以我们会继续观察其它的特征，例如毛发的长短。</p><p>这样每只狗对应一个二维坐标点，我们就能轻易的将哈士奇、金毛和拉布拉多区分开来，如果这时仍然无法很好的区分德牧和罗威纳犬。我们就可以继续再从其它的特征区分，比如鼻子的长短，这样就能得到一个三维的坐标系和每只狗在三维坐标系中的位置。</p><p>在这种情况下，只要特征足够多，就能够将所有的狗区分开来，最后就能得到一个高维的坐标系，虽然我们想象不出高维坐标系长什么样，但是在数组中，我们只需要一直向数组中追加数字就可以了。</p><p>实际上，只要维度够多，我们就能够将所有的事物区分开来，世间万物都可以用一个多维坐标系来表示，它们都在一个高维的特征空间中对应着一个坐标点。</p><p>那这和相似性搜索 (Similarity Search) 有什么关系呢？你会发现在上面的二维坐标中，德牧和罗威纳犬的坐标就非常接近，这就意味着它们的特征也非常接近。我们都知道向量是具有大小和方向的数学结构，所以可以将这些特征用向量来表示，这样就能够通过计算向量之间的距离来判断它们的相似度，这就是<strong>相似性搜索</strong></p><h4 id="高效的搜索算法"><a href="#高效的搜索算法" class="headerlink" title="高效的搜索算法"></a>高效的搜索算法</h4><p>聚类算法（内存占用大）</p><p>量化：内存中可以将聚类中心里面每一个向量都用聚类中心的向量来表示，并维护一个所有向量到聚类中心的码本，减少内存占用。</p><p>但是在高维坐标系中，还会遇到维度灾难问题，具体来说，随着维度的增加，数据点之间的距离会呈指数级增长，这也就意味着，在高维坐标系中，需要更多的聚类中心点将数据点分成更小的簇，才能提高分类的质量。否者，向量和自己的聚类中心距离很远，会极大的降低搜索的速度和质量。</p><p>但如果想要维持分类和搜索质量，就需要维护数量庞大的聚类中心。随之而来会带来另一个问题，那就是聚类中心点的数量会随着维度的增加而指数级增长，这样会导致我们存储码本的数量极速增加，从而极大的增加了内存的消耗。例如一个 128 维的向量，需要维护 2^64 个聚类中心才能维持不错的量化结果，但这样的码本存储大小已经超过维护原始向量的内存大小了。</p><p>解决这个问题的方法是将向量分解为多个子向量，然后对每个子向量独立进行量化，比如将 128 维的向量分为 8 个 16 维的向量，然后在 8 个 16 维的子向量上分别进行聚类，因为 16 维的子向量大概只需要 256 个聚类中心就能得到还不错的量化结果，所以就可以将码本的大小从 2^64 降低到 8 * 256 = 2048 个聚类中心，从而降低内存开销。</p><h4 id="向量数据库的选型"><a href="#向量数据库的选型" class="headerlink" title="向量数据库的选型"></a>向量数据库的选型</h4><ol><li><p>分布式</p></li><li><p>访问控制和备份</p></li><li><p>API &amp; SDK</p><blockquote><p>api : 接口调用</p><p>sdk : 软件开发工具包</p></blockquote></li><li><p>选型</p></li></ol><p>chroma, milvus, pinecone, qdrant, typesense, weaviate</p><h3 id="LangChain"><a href="#LangChain" class="headerlink" title="LangChain"></a>LangChain</h3><blockquote><p>简化构建高级语言模型应用程序的过程的框架</p></blockquote><h4 id="what-is-langchain"><a href="#what-is-langchain" class="headerlink" title="what is langchain"></a>what is langchain</h4><p>一个强大的框架，旨在帮助开发人员使用语言模型构建端到端的应用程序。它提供了一套工具、组件和接口，可简化创建由大型语言模型 (LLM) 和聊天模型提供支持的应用程序的过程。LangChain 可以轻松管理与语言模型的交互，将多个组件链接在一起，并集成额外的资源，例如 API 和数据库。</p>]]></content>
    
    
    <summary type="html">了解gpt</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="gpt" scheme="https://dra-tammer.github.io/tags/gpt/"/>
    
  </entry>
  
  <entry>
    <title>算法基础知识</title>
    <link href="https://dra-tammer.github.io/posts/35c4e025.html"/>
    <id>https://dra-tammer.github.io/posts/35c4e025.html</id>
    <published>2024-02-04T08:34:06.000Z</published>
    <updated>2024-09-03T13:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法基础知识"><a href="#算法基础知识" class="headerlink" title="算法基础知识"></a>算法基础知识</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><blockquote><p>本质就是先递进再回归</p></blockquote><ol><li>明确函数需要干什么</li><li>寻找递归结束的条件</li><li>等价关系式，不断缩小参数的范围</li></ol>]]></content>
    
    
    <summary type="html">基础知识回顾</summary>
    
    
    
    <category term="算法" scheme="https://dra-tammer.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="笔记" scheme="https://dra-tammer.github.io/categories/%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法" scheme="https://dra-tammer.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>云服务器的基本配置（宝塔）</title>
    <link href="https://dra-tammer.github.io/posts/48fc7caa.html"/>
    <id>https://dra-tammer.github.io/posts/48fc7caa.html</id>
    <published>2023-11-07T14:19:30.000Z</published>
    <updated>2024-09-03T13:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="云服务器的基本配置（宝塔）"><a href="#云服务器的基本配置（宝塔）" class="headerlink" title="云服务器的基本配置（宝塔）"></a>云服务器的基本配置（宝塔）</h1><blockquote><p>uname -a 查看当前的操作系统的版本信息等</p><p>clear 清屏</p><p>netstat -lntp 当前哪些端口被监听，进程号</p></blockquote><h2 id="阿里云的云服务器ECS"><a href="#阿里云的云服务器ECS" class="headerlink" title="阿里云的云服务器ECS"></a>阿里云的云服务器ECS</h2><p>云服务器 ECS（Elastic Compute Service）是一种弹性可伸缩的计算服务，助您降低 IT 成本，提升运维效率，使您更专注于核心业务创新。<br>云服务器Elastic Compute Service（ECS）是阿里云提供的一种基础云计算服务。使用云服务器ECS就像使用水、电、煤气等资源一样便捷、高效。您无需提前采购硬件设备，而是根据业务需要，随时创建所需数量的云服务器ECS实例。在使用过程中，随着业务的扩展，您可以随时扩容磁盘、增加带宽。如果不再需要云服务器，也能随时释放资源，节省费用。</p><h2 id="宝塔部署"><a href="#宝塔部署" class="headerlink" title="宝塔部署"></a>宝塔部署</h2><p>进入宝塔的官网，按照要求复制命令</p><p><code>[安装宝塔 (bt.cn)](https://www.bt.cn/admin/servers#wcu)</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh ed8484bec</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Firewall reloaded</span><br><span class="line">-----------------</span><br><span class="line">Congratulations!Installed successfully!</span><br><span class="line">-----------------</span><br><span class="line">------------面板账户登录信息------------</span><br><span class="line">外网面板地址：http://47.94.226.225:25591/6b522cf4</span><br><span class="line">内网面板地址：http://172.25.148.217:25591/6b522cf4</span><br><span class="line">username:8fc2e0c1</span><br><span class="line">password:9078a650</span><br><span class="line">------------打开面板请查看------------</span><br><span class="line">【云服务器】请在安全组放行25591端口</span><br><span class="line">因默认启用自签证书https加密访问，浏览器将提示不安全</span><br><span class="line">点击【高级】-【继续访问】或【接收风险并继续】访问</span><br><span class="line">教程：https://www.bt.cn/bbs/thread-117246-1-1.html</span><br><span class="line">-----------------</span><br><span class="line">Time consumed: 2 Minute!</span><br></pre></td></tr></tbody></table></figure><p>启动在25591</p><p>要在阿里云开放入方向的25591端口，出方向就不管，因为从服务器中出来的对于我们来说是安全的</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serverbaota</span><br><span class="line">720118</span><br><span class="line">/safeserver</span><br></pre></td></tr></tbody></table></figure><h2 id="环境的快捷安装"><a href="#环境的快捷安装" class="headerlink" title="环境的快捷安装"></a>环境的快捷安装</h2><p>进入宝塔的云服务器的管理页面，从软件商店里找。（Nginx，MySQL等等）</p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>缓存，给我们的网站做加速</p><h2 id="宝塔部署vue项目"><a href="#宝塔部署vue项目" class="headerlink" title="宝塔部署vue项目"></a>宝塔部署vue项目</h2><p>点击网站，添加站点，输入公网IP:端口创建即可。将vue项目打包，上传dist文件。将根目录修改到dist。</p><ul><li>部署的时候记得打开监听的端口，阿里云和宝塔两个地方都要打开，nginx监听的端口也要记得修改</li><li>目录一直整到dist目录</li></ul><h3 id="修改请求的地址"><a href="#修改请求的地址" class="headerlink" title="修改请求的地址"></a>修改请求的地址</h3><p>发现用localhost请求发送不对</p><p>使用浏览器访问是通的</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 解决方法用了最原始的方法</span><br><span class="line">// baseURL: 'http://localhost:8080', </span><br><span class="line">   改成 baseURL: 'http://47.94.226.225:8080'</span><br></pre></td></tr></tbody></table></figure><p>这可太蠢了，但是访问本机的就是搞不好hhh</p><h2 id="宝塔部署MySQL数据库"><a href="#宝塔部署MySQL数据库" class="headerlink" title="宝塔部署MySQL数据库"></a>宝塔部署MySQL数据库</h2><h3 id="查看MySQL的服务状态"><a href="#查看MySQL的服务状态" class="headerlink" title="查看MySQL的服务状态"></a>查看MySQL的服务状态</h3><blockquote><p>systemctl status mysql</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">● mysqld.service - LSB: start and stop MySQL</span><br><span class="line">     Loaded: loaded (/etc/init.d/mysqld; generated)</span><br><span class="line">     Active: active (running) since Tue 2023-11-07 17:59:34 CST; 3h 37min ago</span><br><span class="line">       Docs: man:systemd-sysv-generator(8)</span><br><span class="line">      Tasks: 26 (limit: 4195)</span><br><span class="line">     Memory: 188.6M</span><br><span class="line">        CPU: 3.118s</span><br><span class="line">     CGroup: /system.slice/mysqld.service</span><br><span class="line">             ├─127753 /bin/sh /www/server/mysql/bin/mysqld_safe --datadir=/www/server/data --pid-file=/www/server/data/iZ2ze12gjhwzsrx3tpmpm1Z.pid</span><br><span class="line">             └─128391 /www/server/mysql/bin/mysqld --basedir=/www/server/mysql --datadir=/www/server/data --plugin-dir=/www/server/mysql/lib/plugin --user=mysql --log-error=iZ2ze12gjhwzsrx3tpmpm1Z.err --open-files-limit=65535 --pid-file=/www/server/data/iZ2ze12gjhwzsrx&gt;</span><br><span class="line"></span><br><span class="line">Nov 07 17:59:34 iZ2ze12gjhwzsrx3tpmpm1Z systemd[1]: Starting LSB: start and stop MySQL...</span><br><span class="line">Nov 07 17:59:34 iZ2ze12gjhwzsrx3tpmpm1Z mysqld[127740]: Starting MySQL *</span><br><span class="line">Nov 07 17:59:34 iZ2ze12gjhwzsrx3tpmpm1Z systemd[1]: Started LSB: start and stop MySQL.</span><br></pre></td></tr></tbody></table></figure><p>如此即为服务运行正常</p><h3 id="MySQL修改表名"><a href="#MySQL修改表名" class="headerlink" title="MySQL修改表名"></a>MySQL修改表名</h3><p>MySQL修改表名很麻烦，本质就是建立新数据库然后备份转存</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用Navicat</span><br><span class="line">先右键老的数据库，转储数据库文件，然后在新库导入数据库文件即可</span><br></pre></td></tr></tbody></table></figure><p><font style="color:red">遇到了上传了sql文件但是服务器上的数据库中无内容，可能是mysql的版本不对应</font></p><p>修改了宝塔中装的MySQL的版本，问题解决。</p><h3 id="命令行访问"><a href="#命令行访问" class="headerlink" title="命令行访问"></a>命令行访问</h3><p>首先记得在宝塔页面修改root的密码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p 登录mysql服务</span><br></pre></td></tr></tbody></table></figure><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>回到宝塔页面，点击添加数据库，数据库名和用户名要一致，不一致要报错。</p><p>将本地数据库中的内容转储，得到一个例如<code>car_sales.sql</code>文件，不要随意修改名称，保证建立的数据库的名称跟<code>.sql</code>之前的内容一致。</p><p>老样子，记得宝塔和阿里云开启3306端口的权限。</p><h2 id="宝塔部署go项目"><a href="#宝塔部署go项目" class="headerlink" title="宝塔部署go项目"></a>宝塔部署go项目</h2><p>首先还是释放端口的访问权限，阿里云和宝塔的权限</p><p>网站那一栏有go项目的新建，新建一个go项目，将本地的go项目的执行文件上传，这种方式暂时没有效果。采用使用命令行运行的方法。</p><h3 id="添加go环境"><a href="#添加go环境" class="headerlink" title="添加go环境"></a>添加go环境</h3><p>安装包下载</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://studygolang.com/dl/golang/go1.19.4.linux-amd64.tar.gz</span><br></pre></td></tr></tbody></table></figure><p>解压gz包</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -d go1.19.4.linux-amd64.tar.gz</span><br></pre></td></tr></tbody></table></figure><p>解压tar包</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf go1.19.4.linux-amd64.tar</span><br></pre></td></tr></tbody></table></figure><p>配置go的环境变量</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line">文件的最后加入</span><br><span class="line">export GOPATH=/root/gopath   你的工作目录（在这里创建.go文件）</span><br><span class="line">export GOROOT=/root/go     go的安装目录</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br><span class="line">:wq</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></tbody></table></figure><p>将本地的gin项目文件夹导入到服务器上src目录下，cd进car_sales，运行go build mian.go，由于没有gin环境，他得先下载，云服务器访问github真的慢昂。这样我们就要在windows中交叉编译出Linux下的可执行文件。</p><h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><p>在windows系统的命令行下输入</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set GO_ENABLED=0</span><br><span class="line">set GOOS=linux</span><br><span class="line">set GOARCH=amd64</span><br><span class="line">go build main.go</span><br></pre></td></tr></tbody></table></figure><p>编译linux系统下的可执行文件<code>main</code>，上传到tmp目录中</p><h3 id="运行执行文件"><a href="#运行执行文件" class="headerlink" title="运行执行文件"></a>运行执行文件</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果要修改权限</span><br><span class="line">chmod +x main</span><br><span class="line">之后运行</span><br><span class="line">./main</span><br></pre></td></tr></tbody></table></figure><p>这样就运行起来了，记得放开阿里云和宝塔的端口</p><h3 id="持久运行执行文件"><a href="#持久运行执行文件" class="headerlink" title="持久运行执行文件"></a>持久运行执行文件</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup ./main &amp; // 后台运行</span><br><span class="line">netstat -lntp // 查看端口的监听情况</span><br></pre></td></tr></tbody></table></figure><p><code>tcp600 :::8080:::*LISTEN54288/./main</code></p><h3 id="停止进程"><a href="#停止进程" class="headerlink" title="停止进程"></a>停止进程</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 54288 // 如果想停掉的话，直接杀掉这个进程即可</span><br></pre></td></tr></tbody></table></figure><h3 id="如何查看打印的日志"><a href="#如何查看打印的日志" class="headerlink" title="如何查看打印的日志"></a>如何查看打印的日志</h3>]]></content>
    
    
    <summary type="html">通过宝塔进行数据库前后端项目的部署</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="部署" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="配置" scheme="https://dra-tammer.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
    <category term="云服务器" scheme="https://dra-tammer.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="部署" scheme="https://dra-tammer.github.io/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>《解忧杂货铺》</title>
    <link href="https://dra-tammer.github.io/posts/79b1aa9b.html"/>
    <id>https://dra-tammer.github.io/posts/79b1aa9b.html</id>
    <published>2023-10-30T01:57:29.000Z</published>
    <updated>2024-09-03T14:02:56.000Z</updated>
    
    
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>《恶意》</title>
    <link href="https://dra-tammer.github.io/posts/8c0c5825.html"/>
    <id>https://dra-tammer.github.io/posts/8c0c5825.html</id>
    <published>2023-10-30T01:52:28.000Z</published>
    <updated>2024-09-03T14:02:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《恶意》"><a href="#《恶意》" class="headerlink" title="《恶意》"></a>《恶意》</h1><p><code>start from 2023-10-21</code></p><p><code>end on 2023-10-26</code></p><p><code>东野圭吾</code></p>]]></content>
    
    
    <summary type="html">作者：东野圭吾</summary>
    
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>《挪威的森林》</title>
    <link href="https://dra-tammer.github.io/posts/f9101cf7.html"/>
    <id>https://dra-tammer.github.io/posts/f9101cf7.html</id>
    <published>2023-10-24T14:34:28.000Z</published>
    <updated>2024-09-03T14:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《挪威的森林》"><a href="#《挪威的森林》" class="headerlink" title="《挪威的森林》"></a>《挪威的森林》</h1><p><code>start from 2023-10-23</code></p><p><code>end on 2023-10-24</code></p><p><code>村上春树</code></p><blockquote><p>谁会喜欢孤独，不过是不喜欢失望</p></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>故事发生在20世纪六七十年代的日本，写的是20岁的年轻人彷徨无助的爱情。二战以后，日本经济快速复苏，那个时候的日本，生活水平和我们现在基本相当，温饱思淫欲，加之当时的日本受美国思潮影响比较大，整个社会充斥着性开放甚至叫性泛滥，人们对性有着很高的包容度，这种环境下，年轻人贞洁观念及其淡薄，对婚前性行为习以为常。</p><p>和上世纪六七十年代的美国相似，当时的日本年轻人思想空虚，追求虚无，嬉皮士流行，很多年轻人产生了精神问题，抑郁症、精神疾患频发，自杀率居高不下。本书中接连不断发生的自杀现象，增加了故事的沉重和伤感。虽然是一本爱情小说，但丝毫没有感受到爱情的甜美，反而被浓重的伤感所包围，就像陷进了连月不开的霏霏的阴雨中，湿冷而阴暗，无处躲藏，只能把自己完全融进去，和阴郁的天气一起发抖、哀伤。</p><p><strong>我们现在青年人渐渐抛弃了旧日里的传统，忽视了人与人之间的原始维系，能够轻易地获取到各种各样的信息，不再需要依靠社交的交流，极大化的信息量与极小化的生活圈的矛盾，社会到处弥漫着浮躁之气。</strong>每个人都像一个火药桶，一点小事就可能转化为极大的悲剧。</p><h2 id="挪威的森林（披头士乐队）"><a href="#挪威的森林（披头士乐队）" class="headerlink" title="挪威的森林（披头士乐队）"></a>挪威的森林（披头士乐队）</h2><p>Knowing she world，感觉不是特别好，就谐音了一下，Norwegian wood</p><h2 id="左翼与右翼"><a href="#左翼与右翼" class="headerlink" title="左翼与右翼"></a>左翼与右翼</h2><p>左翼和右翼政治观点的区别，表现哲学观、历史观上，也表现在对经济的政策上，表现在变革与保守上。严格说来左翼和右翼是民主政体下的两个派别，是两党制的渊源，是自由主义的两个群体，而专制政体下是不存在这两个派别的，所以左翼和右翼是民主政治的概念。</p><p>在哲学观、历史观上，<strong>左翼一般认为历史是人民创造的，信奉“小民史观”，其政治主张是偏向下层人民，草根阶层的。左翼反对贫富悬殊，追求社会公平和“均贫富”，认为贫困是由于“不公正”而造成的，国家、社会应对个人的不幸负责。</strong>左翼梦想一个和谐的、公正的社会，在经济政策上主张加强国家宏观控制，扩大税收，特别是针对富人的税收，扩大公共福利，甚至不惜举办国家公共工程来解决经济危机和失业问题。<strong>左翼总的来说是变革的、进步的，是自由主义和民主政治的原教旨阵地。</strong></p><p>右翼则正好相反，右翼信奉的是“英雄史观”，认为历史是英雄创造的，其政治主张是偏向中产阶级、精英阶层的。右翼特别反对左翼的“均贫富”的观点，认为这实际上是在追求终点的平等，是错误的。<strong>右翼和左翼共同之处是都追求起点的平等，但右翼更强调个人的使命感和责任感，强调国家应给每一个公民以机会，尊重每一个人的个性，强调平等受教育（基础教育）的权力，认为人必须对自已的命运负责，贫困只能源于自已的低素质、懒惰和无能，不能怪其他的因素。</strong>右翼的经济政策是主张自由放任的，主张小政府、大社会，对经济的干预和宏观调控越少越好，通过主张减税、减少公共福利、刺激投资来解决失业问题和社会问题，认为福利越多，人的的依赖性就越强，进取心就越差，就会鼓励懒惰，打击勤奋，因此对一个国家的前途将造成消极的影响。</p><p><strong>右翼强调“法律和秩序”，是保守主义的，也反对变革，右翼的经济观点是正宗的自由主义，但其政治观点是自由主义的侧门。</strong></p><p>在民主政治下，左翼和右翼，不存在谁正确谁错误、谁先进谁反动的问题，左翼和右翼是一个国家、一个民族的左右手，是缺一不可的。<strong>一个国家不可能长期由左翼执政，否则社会太均匀、太福利化将会阻碍经济的发展，同时容易走向民粹主义；一个国家同样不能由右翼长期执政，否则贫富悬殊就会导致社会不公正，分配不公，最终也会阻碍经济的发展。</strong>一个国家的“自由进程”之路不可能是笔直的，自由之路就象公路一样是弯弯曲曲的，民主政治就是一辆汽车，要想在自由之路上顺利前进，就必须要随时调整方向盘，一会儿向右拐弯，一会儿向左拐弯，只有这样，这辆汽车才不会冲出公路而翻车倾覆，才会顺利直达终点。所以，左翼和右翼的轮流执政，轮流调整国家前进之路，是民主政治下两党制的基础。真正成熟的民主国家，一般只有左、右两个主要政党，而政党林立的民主国家，其民主政治仍是不成熟的、幼稚的，还处在民主政治的低级阶段。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>人都渴望同类的理解，谁又能真正地理解自己。</p><p>成长恰恰是人们同孤独抗争，受伤、失落、失去却又要活下去。</p><p>尽管你可能心里难受，但还是要坚强起来，要再成熟一些，成为大人。</p><p>死不是生的对立面，而是作为生的一部分永存。生离也好死别也罢，都不是结束，而是作为一种意义，寄存于生者的生之中。与所爱之人所有的互动，塑造了现在的我。</p><p>洪桑说他看的时候是偏向致郁的感觉（他当时是高中的时候看的），但是大三的我看这部小说的时候却不是这种感觉，更多的时候是一种感同身受，那种在时代的浪潮下不知道何去何从的无力感，迷茫感。我也向往有一位女生在旁作伴，在悲伤的时候互相倾诉，在欢乐的时候享受幸福，不仅是肉体上的伴侣，同时也是精神伴侣。我们大多数人都是普通人，成为精英的就一点点，归根结底就是脚踏实地的，做好自己当下该做好的事情，我相信最后的结果一定不会差。这段时间是真的焦虑，保研边缘人物真是一个很抽象的东西，我也在思考，综测的这些东西我是真的不喜欢吗，还是只是我懒，不相干而已。我的目标是什么？该咋办？</p><p>这本书也是在上课的时候看完的，对我来说是平静，是引起我的思考，思考我的近况，思考未来。</p><p>大学的生活真的很孤独，这种孤独不是身边没有一起游戏的朋友，而是各自要走的路都不一样，成长的路上没有交心的朋友作伴，唯有孤独前行。面对孤独，处理好了就是进步，处理不好就是堕落，但是更多的是原地踏步，有时候感觉平静稳定的生活是真的很好。</p>]]></content>
    
    
    <summary type="html">作者：村上春树</summary>
    
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>《白夜行》</title>
    <link href="https://dra-tammer.github.io/posts/ba52eee0.html"/>
    <id>https://dra-tammer.github.io/posts/ba52eee0.html</id>
    <published>2023-10-21T08:03:43.000Z</published>
    <updated>2024-09-03T14:02:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《白夜行》"><a href="#《白夜行》" class="headerlink" title="《白夜行》"></a>《白夜行》</h1>]]></content>
    
    
    <summary type="html">作者：东野圭吾</summary>
    
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>《嫌疑人X的献身》</title>
    <link href="https://dra-tammer.github.io/posts/43720415.html"/>
    <id>https://dra-tammer.github.io/posts/43720415.html</id>
    <published>2023-10-21T07:12:19.000Z</published>
    <updated>2024-09-03T14:07:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《嫌疑人X的献身》"><a href="#《嫌疑人X的献身》" class="headerlink" title="《嫌疑人X的献身》"></a>《嫌疑人X的献身》</h1><p><code>start from 2023-10-18</code></p><p><code>end on 2023-10-18</code></p><p><code>东野圭吾</code></p><p>周四那天白天上课的时候实在不想听课，听说东野圭吾的《嫌疑人X的献身》也很好看，于是就用微信读书看了看，未曾想，一看就一发不可收拾，着迷于其中，最终花了三个多小时的时间给他一口气看完了，没办法，实在是太好看了。</p><p>其实，之前不知道从哪看的对东野圭吾书的评价，说从开始就知道故事结局，只不过看看过程是否精彩。我本以为这本书也是这样，一开始我们就知道了靖子美里母女二人杀了富㭴（后文简称富），石神帮助他们处理了富的尸体并创造不在场嫌疑，那么看书的过程不就是警察，汤川一步步逼近这个结果吗。越往后看，其实不然，石神貌似有一个更加让人毛骨悚然的计划。</p><p>小说的开篇为什么要提及那一群流浪汉，提到那个新来的流浪汉对环境的不适应以及社会以及流浪汉群体本身对自己的漠视，开始看的时候感觉这些东西对故事的叙述毫无作用。慢慢接近石神真正的计划，突然发现之前提到的这些东西都是伏笔。石神为了尽管计划泄露也能保证母女二人摆脱牢狱之灾，真正犯下了命案，用流浪汉去替代富，让流浪汉去富的家里留下生活的印迹，留下那个新的自行车，车把上面留下流浪汉的指纹，同时DNA的比对都正确，这样警察从一开始就落入了石神的圈套，他们查的其实是石神犯下的凶杀案，富的案子就这样被悄无声息地掩盖下去，实在巧妙，但也实在残忍，实在是狠，为了掩盖一个罪行去犯下另一个罪行。</p><p>那么精密计划到底输在哪里了呢，输在了石神的性格被汤川摸得太透了，石神只会做自己认为正确的事，无论这事儿有多么残酷，需要投入多大的代价，他都会去做。在他万念俱灰，对生活失去希望的，准备一死了之的时候，靖子母女二人犹如白月光闯入石神的生活中，让石神重新燃起了生的希望。为了她们俩，他可以牺牲掉自己的前途，牺牲掉另一个人的生命，他的动力就是对靖子的情感，至于是不是爱，我觉得不然，这只是一个单向的精神的依托。最后汤川跟靖子说清楚自己的推测之后，靖子或许并不倾向于自首，但是美里的割腕让她最后的防线崩塌，心理上还是过不去，想罢美里也很累吧，也被压得喘不过来气吧。或许结局其实对他们是好的，或许是坏的，谁又知道呢。</p><p>关于石神对靖子的情感，我想应该很多男生都会有类似的幻想吧，就是俗称的白月光？我高三的时候，连续一个月上下学的时候都会碰见一位女生，我觉得很有缘，于是就去了解她，每次下课拉着我的好哥们借着逛一逛的名义去他们班远远地看她，知道她有对象之后或许很失落但是还是会去看哈哈哈，最离奇就是高考前一天，我们俩在书店碰到了，并且先后付款，老板错把她的东西给了我。说真的，我当时心理怦怦跳的，激动地乱斗。高考结束之后也是加了她的联系方式，开始的一段时间也是天天聊，之后知道她对象表白之后就不咋聊，越来越寡了哈哈哈，后来也就是朋友圈互相问候一下，节日问候一下。但是每次想到高三的那段黑暗的时间，去三楼转真的是少有的让我开心的事儿。石神理由是否和我一样？</p><p>如果没有美里自残那最后一根稻草，靖子会不会自首，还是跟工藤幸福生活下去？不得而知，但是石神确实为着靖子的幸福，他真的爱她，但是悲哀的是，她不爱她，她对他只是感谢和内疚。为了一个不爱自己的人付出如此多真的值得，石神自己认为值得就行了。</p><p>很棒的一部小说，很精彩，真相慢慢浮出水面的时候真的是按耐不住激动的心，必须得给它读完。</p><p>石神是天才，性格上的缺陷决定了他的结局，所有人都是如此。逻辑思维和感性思维同等重要，男女互补才是正道。</p><p>纯粹的爱情，绝妙的诡计，无懈可击的推理，惊人的伏笔，不易猜透的悬念，理智与情感交织碰撞。谎言里交织着人性的善与恶，真相里闪烁着灵魂的喜与悲，诡计里包含着深深的爱与痛楚，包含着难以言表的心情。</p>]]></content>
    
    
    <summary type="html">作者：东野圭吾</summary>
    
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
</feed>
