<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Toothless</title>
  
  <subtitle>world for tammer</subtitle>
  <link href="https://dra-tammer.github.io/atom.xml" rel="self"/>
  
  <link href="https://dra-tammer.github.io/"/>
  <updated>2025-08-12T10:59:15.000Z</updated>
  <id>https://dra-tammer.github.io/</id>
  
  <author>
    <name>tammer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>本地音乐播放器 / NCM2MP3</title>
    <link href="https://dra-tammer.github.io/posts/3a0ec10f.html"/>
    <id>https://dra-tammer.github.io/posts/3a0ec10f.html</id>
    <published>2025-08-12T10:59:15.000Z</published>
    <updated>2025-08-12T10:59:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>之前刷到过自建音乐库，本地音乐播放器的文章，早就想搞一搞，但是当时从应用下载的音乐标签软件无法从椒盐音乐中调出，看了看网友推荐的其他软件也没成功调出，遂放弃。最近想把英语口语的听力搞到手机里同意管理，所以接着研究，发现从其他渠道搞的音乐标签软件就能被椒盐音乐成功调出。</p><h2 id="Software"><a href="#Software" class="headerlink" title="Software"></a>Software</h2><h3 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h3><p><a href="https://music.163.com/">https://music.163.com/</a></p><p>充当音乐源，下载到本地的音乐格式是NCM，通过部署NCM2MP3将NCM格式转换为MP3格式。</p><h3 id="NCM2MP3"><a href="#NCM2MP3" class="headerlink" title="NCM2MP3"></a>NCM2MP3</h3><p><a href="https://github.com/charlotte-xiao/NCM2MP3">https://github.com/charlotte-xiao/NCM2MP3</a></p><p>开源项目，需要自己部署。环境：Java8，maven等</p><p>网易云ncm音乐格式转换为mp3音乐格式工具，支持多线程批量转换</p><h3 id="VK-Music-Bot"><a href="#VK-Music-Bot" class="headerlink" title="VK Music Bot"></a>VK Music Bot</h3><p><a href="https://t.me/vkmusic_bot">https://t.me/vkmusic_bot</a></p><p>电报音乐下载机器人，这个也可以充当音乐源，那既然找到了NCM to mp3的开源项目，这个就可以搁置备用了。</p><h3 id="localsend"><a href="#localsend" class="headerlink" title="localsend"></a>localsend</h3><p><a href="https://localsend.org/">https://localsend.org/</a></p><p>跨平台局域网文件互传</p><h3 id="椒盐音乐"><a href="#椒盐音乐" class="headerlink" title="椒盐音乐"></a>椒盐音乐</h3><p><a href="https://moriafly.com/program/spw.html">https://moriafly.com/program/spw.html</a></p><p>本地音乐播放器</p><h3 id="音乐标签"><a href="#音乐标签" class="headerlink" title="音乐标签"></a>音乐标签</h3><p>[下载链接去找酷安老哥]</p><p><a href="https://wwt.lanzout.com/i2cIo1u9oawh">https://wwt.lanzout.com/i2cIo1u9oawh</a></p><p>将音乐标题、演唱者姓名、封面图、歌词、专辑名等信息添加至音乐文件中的软件</p><h3 id="NCM2MP3-1"><a href="#NCM2MP3-1" class="headerlink" title="NCM2MP3"></a>NCM2MP3</h3><p><a href="https://github.com/charlotte-xiao/NCM2MP3">https://github.com/charlotte-xiao/NCM2MP3</a></p><p>开源项目，需要自己部署。环境：Java8，maven等</p><p>网易云ncm音乐格式转换为mp3音乐格式工具，支持多线程批量转换</p><h3 id="MT管理器"><a href="#MT管理器" class="headerlink" title="MT管理器"></a>MT管理器</h3><p><a href="https://mt2.cn/">https://mt2.cn/</a></p><p>Android 平台文件管理 &amp; 逆向修改神器。独创的双窗口操作模式，两个目录同时显示，结合前进/后退/同步等功能，熟悉之后相比传统操作方式更加高效。</p><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><h3 id="获取mp3格式的音乐"><a href="#获取mp3格式的音乐" class="headerlink" title="获取mp3格式的音乐"></a>获取mp3格式的音乐</h3><p>电脑版网易云音乐下载音乐到本地，去下载目录里找，发现格式是NCM。</p><p>部署NCM2MP3，批量将NCM格式的音乐文件转换为MP3格式，同时保留音乐文件的元数据。</p><p>或者直接使用电报的机器人进行音乐的下载。</p><h3 id="同步音乐文件给手机"><a href="#同步音乐文件给手机" class="headerlink" title="同步音乐文件给手机"></a>同步音乐文件给手机</h3><p>通过localsend，将音乐文件发送给手机。打开MT管理器，在手机Document目录中单独新建一个文件夹<code>self_build music</code>，将手机的接收目录改为这个文件夹。</p><h3 id="导入椒盐音乐"><a href="#导入椒盐音乐" class="headerlink" title="导入椒盐音乐"></a>导入椒盐音乐</h3><p>打开椒盐音乐，左侧目录，扫描音乐，关闭使用Android媒体库，添加自定义文件夹，将刚才创建的<code>self_build music</code>文件夹添加进去，开始扫描。发现下载的歌曲已经全部导入到椒盐音乐中，但是没有歌词。</p><h3 id="导入歌词"><a href="#导入歌词" class="headerlink" title="导入歌词"></a>导入歌词</h3><p>每首音乐的右键菜单，使用音乐标签应用编辑，点击词就能自动搜索歌词，点击搜索就能自动搜索歌曲信息。修改完音乐的数据之后保存即可。</p><h2 id="Else"><a href="#Else" class="headerlink" title="Else"></a>Else</h2>]]></content>
    
    
    <summary type="html">由部署本地音乐播放器到了解NCM2MP3中有意思的知识</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="笔记" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="玩机" scheme="https://dra-tammer.github.io/categories/%E7%8E%A9%E6%9C%BA/"/>
    
    <category term="软件" scheme="https://dra-tammer.github.io/categories/%E7%8E%A9%E6%9C%BA/%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="笔记" scheme="https://dra-tammer.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="经验" scheme="https://dra-tammer.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="配置" scheme="https://dra-tammer.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
    <category term="部署" scheme="https://dra-tammer.github.io/tags/%E9%83%A8%E7%BD%B2/"/>
    
    <category term="项目" scheme="https://dra-tammer.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="算法" scheme="https://dra-tammer.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="玩机" scheme="https://dra-tammer.github.io/tags/%E7%8E%A9%E6%9C%BA/"/>
    
    <category term="音乐" scheme="https://dra-tammer.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
    <category term="本地化" scheme="https://dra-tammer.github.io/tags/%E6%9C%AC%E5%9C%B0%E5%8C%96/"/>
    
    <category term="开源项目" scheme="https://dra-tammer.github.io/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="java" scheme="https://dra-tammer.github.io/tags/java/"/>
    
    <category term="折腾" scheme="https://dra-tammer.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>浪浪山小妖怪</title>
    <link href="https://dra-tammer.github.io/posts/354ccc7e.html"/>
    <id>https://dra-tammer.github.io/posts/354ccc7e.html</id>
    <published>2025-08-07T12:39:52.000Z</published>
    <updated>2025-08-10T04:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>2025-08-07</code></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>猪妖和蛤蟆妖在大王洞犯事（把大王的铜鼎内部的经文都给擦了），招来杀身之祸。于是为了活命，离开大王洞自己单干，猪妖提出假装唐僧师徒四人去西天取经，在路上能骗点东西。于是召集人马，fake西行队伍整容如下：</p><p>大师兄：腼腆的猩猩，头脑简单，四肢发达</p><p>二师兄：猪妖</p><p>沙师弟：黄鼠狼</p><p>师父：蛤蟆</p><p>途径了一个村庄，也误打误撞给村民做了好事（解决鼠精）。被村民称赞，村民给了很多了吃的。继续西行。中间猪妖回了一趟自己的家，看望了自己的家人，只跟在床上奄奄一息的爸爸说了此行的真实情况，爸爸给了每个人一个人大招的口令。说是一辈子只能用一次，要在最后一次用。</p><p>之后就到了小雷音寺，遇到了假扮如来的一众人。黄眉想要靠吃掉附近村子的童男童女来提升法力以此来捉拿唐僧（九九八十一难中的一难）。狐假虎威的假师徒四人打不过黄眉的手下，被收服让当演员扮演四大天王。蛤蟆留下了，猪妖、黄鼠狼、猩猩趁机逃走。但是想救地牢里的孩子们，于是几个人叠罗汉装作黄眉的样子把孩子们给释放了。释放的时候碰到了黄眉的手下，蛤蟆认出了黄眉是假扮的，灵机一动，说“大王想干啥就干啥”化解危机。最后东窗事发，四人确保孩子们安全之后与黄眉solo。很吃力，最后黄眉开大，四人也开大，齐心协力战胜了黄眉。四人现出原形。最后齐天大圣认出了他们，“救命毫毛你们一人一根”，电影结束。</p><h2 id="意想不到的点"><a href="#意想不到的点" class="headerlink" title="意想不到的点"></a>意想不到的点</h2><p>最后一战我以为他们合体之后会战败，然后大圣出手打败黄眉。结果是他们四人合力战胜了黄眉。</p><p>这一结果我看有人说太常规，后来我想想，这个结果是服务电影的内核的。电影想要表达的点是普通人经过努力也是能完成伟大的事业。如果最后大圣救场，可能就与电影想表达的内核不服，这就变成了普通人经过再多的努力也是无法完成伟大的事业，需要一个神去拯救。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="美术"><a href="#美术" class="headerlink" title="美术"></a>美术</h3><p>上海电影制片厂独特的美术形式，让我仿佛回到了童年看他们的西游记的感觉。美术推进的情绪表达很夸张，观众容易共情。</p><h3 id="笑点-泪点"><a href="#笑点-泪点" class="headerlink" title="笑点 &amp; 泪点"></a>笑点 &amp; 泪点</h3><p>笑点泪点均有。笑点居多，有时候一些无厘头的笑点能让全场笑翻，还有许多阴阳的笑点也是非常好玩。</p><h3 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h3><p>故事逻辑也是通俗易懂。四人不是完全意义上的好人，也不是坏人。而是一个更加现实的普通人，蛤蟆在生命收到威胁的时候会选择背叛保命，黄鼠狼在入队之前是个骗子，装作土地骗吃骗喝。猩猩头脑简单，四肢发达。猪妖是人不行但是臭点子不少（浪浪山点子王），理想高尚。但是在大是大非面前又非常的有立场。最后每个人都豁出自己的生命去保护孩子们。</p><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>看到了真实的普通人，每个人都有缺点，但是也有闪光点。普通人也可以有自己的理想，也可以为自己的理想去努力，去奋斗。道阻且长，行则将至。</p><p>隐射当下社会普通人的状态通俗易懂，这应该不算是隐喻了吧。但是现实情况应该会更残酷。</p><p>有一点，村民最后给四人立了一个祠祭拜。告诉我们做普通人也能做伟大的事儿。就算是假的取经团队，但是他们最后救下了全村的孩子，就是功德无量，老百姓也是论迹，只要你做了善事，给老百姓做出了巨大的贡献，普通人也配享太庙。</p><h2 id="主观感受"><a href="#主观感受" class="headerlink" title="主观感受"></a>主观感受</h2><p>值得一看的电影，笑点居多。整体故事比较平淡，转折少，可能是西游记的故事改，毕竟西游记的故事我们已经很熟悉了。开头的故事吸引力不强，越往后越沉浸。一开始甚至有无聊的感觉，打了好几次哈欠。但是最终结局跟我想象的不一样倒是让我挺有收获。故事没有罗小黑精彩和吸引人，打戏也没有罗小黑好。</p><p>推荐指数：⭐⭐⭐☆☆</p>]]></content>
    
    
    <summary type="html">暑期档浪浪山小妖怪观后感</summary>
    
    
    
    <category term="电影" scheme="https://dra-tammer.github.io/categories/%E7%94%B5%E5%BD%B1/"/>
    
    <category term="观后感" scheme="https://dra-tammer.github.io/categories/%E7%94%B5%E5%BD%B1/%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    
    <category term="动漫" scheme="https://dra-tammer.github.io/categories/%E5%8A%A8%E6%BC%AB/"/>
    
    <category term="国漫" scheme="https://dra-tammer.github.io/categories/%E5%8A%A8%E6%BC%AB/%E5%9B%BD%E6%BC%AB/"/>
    
    
    <category term="电影" scheme="https://dra-tammer.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
    <category term="观后感" scheme="https://dra-tammer.github.io/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    
    <category term="动漫" scheme="https://dra-tammer.github.io/tags/%E5%8A%A8%E6%BC%AB/"/>
    
    <category term="国漫" scheme="https://dra-tammer.github.io/tags/%E5%9B%BD%E6%BC%AB/"/>
    
  </entry>
  
  <entry>
    <title>循环提问</title>
    <link href="https://dra-tammer.github.io/posts/56d7e222.html"/>
    <id>https://dra-tammer.github.io/posts/56d7e222.html</id>
    <published>2025-08-03T12:50:56.000Z</published>
    <updated>2025-08-03T12:50:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>2025.08.01~2025.08.03</code></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>L</code>推荐看的书</p><h2 id="行文结构"><a href="#行文结构" class="headerlink" title="行文结构"></a>行文结构</h2><p>上来先进行一点理论铺垫，之后是案例报告。案例的部分：<code>访谈阶段</code>，摸清患者的来就诊的背景—&gt;<code>暂停</code>，治疗师摆脱了行动和交际的压力的束缚的时候，才有可能从外部的视角去看一看所发生的一切，去看一看自己的活动以及会谈中的交际模式。当事人在暂停之后会更加的聚精会神。—&gt;<code>结尾评论</code>，治疗师表达自己的观点、给出不同的解释和评价、布置家庭作业，等等。</p><p>文章的结构安排也是如此：</p><ul><li>访谈</li><li>暂停</li><li>结尾干预</li><li>指导帮助—工具</li></ul><h2 id="印象深的表述"><a href="#印象深的表述" class="headerlink" title="印象深的表述"></a>印象深的表述</h2><blockquote><p>谁如果把自己所遭受的痛苦归罪于另外一个人，那么他的行为就只能一如既往，他会宣扬自己的世界观，力求让另一个人有负罪感。</p></blockquote><blockquote><p>只有让自己的世界观变得不再那么确定，让自己变得有些混乱迷茫的时候，改变才有可能发生。</p></blockquote><blockquote><p>疾病作为一位虚拟的家庭生活的参与者，已经被纳入了联盟，在权力斗争中既可以被人利用，针对它也形成了防御的阵线。</p></blockquote><blockquote><p>聪明的一个标志就是，走最轻松的路。</p></blockquote><blockquote><p>如果一个人总是强调的自己的疾病，那么从短期来看，他就会避免掉恼火麻烦；从长期来看，他就会给自己剥夺掉很多成年人的生活机会。</p></blockquote><blockquote><p>哭对其他人产生的作用就是邀请他们前来安慰。暴怒的人，也是在邀请别人来对他进行控制。</p></blockquote><blockquote><p>每个人在成长的过程中，都必须要划分他自己与周围人之间的界限，这样他才能够把自己看作一个有行动能力的、能够自己负责的生存个体。</p></blockquote><blockquote><p>在缺少信息的时候，信任永远都被证明是一种有效的、经济的方法。如果知道了，那就不需要信任了。</p></blockquote><blockquote><p>把一对情侣吸引到一起的那些因素，日后也会重新导致他们分道扬镳。每一个伴侣都会强化—无论是有意识还是无意识—自己在对方眼里看来非常有魅力的行为模式。如果两个人都这么做，便会令事态扩大，每个人都会培养自己的长处。行为的量变会导致行为的质变，从充满魅力到让人无法忍受。</p></blockquote><blockquote><p>安全、保险和可预见性的愿望与追求冒险的刺激、新鲜和没有情侣关系时的自由的愿望之间形成了一种完美的妥协。</p></blockquote><h3 id="干预方法"><a href="#干预方法" class="headerlink" title="干预方法"></a>干预方法</h3><ol><li>以积极的评价开场</li><li>改释</li><li>观察的作业</li><li>行为的作业</li><li>针对问题模式的治疗处方</li><li>假装的治疗处方：“卡尔又犯精神病了”与“卡尔是在做家庭作业，他正感觉自己特别的健康”，大家会对卡尔的同一个行为表示怀疑</li><li>进入不改变的那一面：改变不要进展的太快，但是会发出信号（改变将会发生）</li><li>分裂</li><li>仪式</li><li>讲故事：故事可以用来描述错综复杂的互动模式和关系模式以及它们的变化。故事提供了描写和改释的模式，能够让人与故事中的人物进行各种各样的身份认同。</li><li>引入幽默：笑是非常有帮助的，因为它能让人与所笑的内容在情感上保持距离。谁能够嘲笑一下自己和自己的命运，那么他就会少遭受一点痛苦。（这是自嘲的作用？）</li><li>小组反映</li><li>三分之一定律</li></ol><h3 id="理论和实践之间的关系"><a href="#理论和实践之间的关系" class="headerlink" title="理论和实践之间的关系"></a>理论和实践之间的关系</h3><p>理论和实践互相依存不可分割：理论只有在严格的实践检验中，才能证明自己的使用价值；而如果缺少了对经验进行理论上的概括总结，那么实践也迟早陷入停滞发展的泥潭。</p><h2 id="看完一遍这本书的第一印象"><a href="#看完一遍这本书的第一印象" class="headerlink" title="看完一遍这本书的第一印象"></a>看完一遍这本书的第一印象</h2><p><code>平时日里一些司空见惯的事儿，或者说对某些事儿的刻板表述，可以换一种表述方法，从另一个截然不同的角度去思考问题，会造成和之前差别很大的效果。</code></p><h3 id="更像是专业人士的工具书"><a href="#更像是专业人士的工具书" class="headerlink" title="更像是专业人士的工具书"></a>更像是专业人士的工具书</h3><p>看完的第一感觉就是这本书是写给专业人士的教科书，书里有理论，有具体实施的方法，还是案例引导。</p><p>这是一本给那些对系统式治疗感兴趣的人的工具书。具有一定的专业性。</p><p>这本书看一遍肯定是不够的，毕竟是一个工具书，可以在具体操作中翻看参考。</p><h3 id="需要多次阅读"><a href="#需要多次阅读" class="headerlink" title="需要多次阅读"></a>需要多次阅读</h3><p>书中虽然有惟妙惟肖的案例，但是涉及理论的时候，有些表述对于新接触这个领域的新手来说还是非常晦涩难懂，可能是之前从来没见过如此的表述，这就导致有些表述我会反过来看好几遍。</p><p>比如对引入幽默的阐述：</p><p>“笑是非常有帮助的，因为它能让人与所笑的内容在情感上保持距离。”</p><p>这句话是真难理解吧，后面给了一个例子才使得我理解这句话存在可能性：</p><p>“谁能够嘲笑一下自己和自己的命运，那么他就会少遭受一点痛苦。”</p><h3 id="看的时候经常开倒车"><a href="#看的时候经常开倒车" class="headerlink" title="看的时候经常开倒车"></a>看的时候经常开倒车</h3><p>案例中有些患者表达自己的想法不够舒畅，治疗师也在想法设法的编出问题来引出患者说出自己想要的信息，这就导致有些问题有些回答的跳跃幅度非常大，有时候与上文都是毫不相干。</p><p>还有患者嘟囔出的话语，没有多少信息量，感到费解，但是又不能忽视，所以我经常开倒车回头看之前的那些话促使治疗师得出后面的结论的。</p><p>部分理论的陈述晦涩难懂，属于中文都是认识，拼在一起形成一句话就不认识。当然我觉得有些翻译的比较生硬，导致我这种悟性不高的就很难get到作者理论的精髓，就算会进行案例说明，也是稍有了解。</p><p>患者经常含糊地说，拐弯抹角地讲，我们也是在跟着绕圈子。这倒是很符合现实中交谈的情景，但是读起来就很难受了。</p><p>看的是2013版本的，我感觉有些表述有问题，太难理解，可能是我悟性不到位。</p><h3 id="验证构想"><a href="#验证构想" class="headerlink" title="验证构想"></a>验证构想</h3><p>部分章节的理论之前有一点点的想法，但是苦于没有文化，只有这个感觉，总结不出来文字。部分章节的有些的话语就正好解决了这个问题，这个感受可以这样总结出来。</p><p><code>这本书在不同阶段看应该感悟不同，我觉得看这本书无法对自己的具体的问题进行治疗，有必要引入一个第三者，当局者迷。</code></p><p><code>很多事情的处理方法最终可以归咎于平衡。</code></p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p><code>20250803</code></p><h3 id="心理方面的问题无法完全治愈"><a href="#心理方面的问题无法完全治愈" class="headerlink" title="心理方面的问题无法完全治愈"></a>心理方面的问题无法完全治愈</h3><p>个人认为心理疾病是无法完全治愈的，这本书的几个案例的结果其实从功利的角度上讲都没有完全治愈，患者因心理疾病在生活和与人交往中存在的问题还存在。我认为心理疾病会和自己的生活共存，所谓痊愈是个体适应了心理疾病的存在，让他成为生活的一部分，所谓积极面对心理疾病。同时在生活中，在心理疾病发作对生活或者是人际关系造成影响的时候积极寻求解决的方法。即心理上面的问题会和个体共存，无法消灭，个体需要学习的就是如何面对这个新的“家人”。</p><p>之前我就是这么认为的，加以这本书案例的作证，更加强化了这一观点。</p><p><code>治疗的本质目的</code>：对存在问题的模式进行扰动</p><h3 id="个体放在系统里"><a href="#个体放在系统里" class="headerlink" title="个体放在系统里"></a>个体放在系统里</h3><p>我非常认可这本书提出的一个观点，当事人总是被看作是系统中的一分子—包括社会系统、家庭系统、医患系统—因此，他们问题的根源和解决方法，要从系统的互动中寻找。在当今社会，我认为人与人之间的连结至关重要，在连结之中我们能窥探到别人的生活方式，别人对自己的看法，融入这个发展迅速的社会。我们需要认清自己在系统中所处的位置以及在系统的互动中所扮演的角色，并以此为出发点，呵护系统中的关系并维持系统的顺畅运转，对于提升我们的生活质量来说，确实是一个不错的、行之有效的方法。</p><p>从系统式治疗的角度看，所有人都是独立的，这就是说，是不受外界 操纵和监控的。</p><h3 id="感情的新鲜感"><a href="#感情的新鲜感" class="headerlink" title="感情的新鲜感"></a>感情的新鲜感</h3><p>试着与对方交换角色，感情中的重建构建差异感，延续新鲜感</p><h3 id="引入外部视角"><a href="#引入外部视角" class="headerlink" title="引入外部视角"></a>引入外部视角</h3><p>向一个人询问其他两人之间的或者多人之间的关系。从丙的角度看，甲和乙之间的互动和交际是怎么样的？谁什么时候做什么？</p><p>一个新大陆，之前从来没有想过面对面了解一个人的时候去引入外部视角，外部视角会给我们更全面的审视。</p><h3 id="改变的具体化"><a href="#改变的具体化" class="headerlink" title="改变的具体化"></a>改变的具体化</h3><p>一个人的发生改变需要去落实到具体的躯体行动，不能宽泛地说是改善了什么，提高了什么。<br>应该是改变发生了之后，具体到一个行动会和之前有什么不同，一旦看到这个具体的行动发生了，就可以判断改变发生了。</p><p>把目标在行为的层面上描述出来，不使用模糊不清的词汇（改善，幸运，成熟）</p><h3 id="提问也会对患者提供新的角度"><a href="#提问也会对患者提供新的角度" class="headerlink" title="提问也会对患者提供新的角度"></a>提问也会对患者提供新的角度</h3><p>每一个问题，都带有对心灵造成强烈影响的内涵，都会传递出特定的预想。提问的干预内涵正在于此</p><h3 id="改释"><a href="#改释" class="headerlink" title="改释"></a>改释</h3><p>当下的事实是家庭内部存在矛盾因为某些问题，使用改释的方法，让这些问题成为能够解决一些问题的积极的方法，就是反话正说，把有问题的动作给他颂扬起来，从而观察当事人的看法，这一点是我从来没有想过的，很神奇。</p><h3 id="精神生活的不满"><a href="#精神生活的不满" class="headerlink" title="精神生活的不满"></a>精神生活的不满</h3><p>当下社会，由于生存资料的富足，人们不再担心自己的生存问题，物质生活更加丰富，却常常滋生出对精神生活的不满，阅读这种著作可以提高对心理障碍的理解，学习他们遇到问题时候的思维方式。更重要是的，去学习理解他人、理解自己、理解人生。</p><p>很多人缺少精神上的谈话伴侣或者引导者、导师。</p><h3 id="对一些行为的再认知"><a href="#对一些行为的再认知" class="headerlink" title="对一些行为的再认知"></a>对一些行为的再认知</h3><p>如果一个人总是强调的自己的疾病，那么从短期来看，他就会避免掉恼火麻烦；从长期来看，他就会给自己剥夺掉很多成年人的生活机会。</p><p>哭对其他人产生的作用就是邀请他们前来安慰。暴怒的人，也是在邀请别人来对他进行控制。</p><p>之前从来没有从这个角度思考过，这种表述很有意思。</p>]]></content>
    
    
    <summary type="html">作者：弗里茨•B.西蒙 / 克里斯特尔•莱西-西蒙</summary>
    
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    <category term="心理学" scheme="https://dra-tammer.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
    <category term="工具书" scheme="https://dra-tammer.github.io/tags/%E5%B7%A5%E5%85%B7%E4%B9%A6/"/>
    
    <category term="系统式治疗" scheme="https://dra-tammer.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%BC%8F%E6%B2%BB%E7%96%97/"/>
    
  </entry>
  
  <entry>
    <title>皖南游玩</title>
    <link href="https://dra-tammer.github.io/posts/bceed4f8.html"/>
    <id>https://dra-tammer.github.io/posts/bceed4f8.html</id>
    <published>2025-07-26T13:43:30.000Z</published>
    <updated>2025-07-26T13:43:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>搁安徽生活了这么多年，我一直以为淮南就在安徽的南边。其实淮南是淮河以南，在安徽省的北部。哈哈哈从我们淮南到南京只有300多公里，去皖南一带得400多公里。</p><p>徽派建筑主要分布于安徽<strong>皖南地区</strong>​（如黟县、歙县）、江西婺源及浙江部分区域，是明清时期徽商文化的重要载体。其风格融合了实用性与儒家美学，讲究“粉墙黛瓦、依山傍水”，体现“天人合一”的理念。</p><h3 id="黟县和歙县区别："><a href="#黟县和歙县区别：" class="headerlink" title="黟县和歙县区别："></a>黟县和歙县区别：</h3><p>1、<strong>读音不同</strong>，黟县读音为：yī xiàn，歙县读音为：shè xiàn；<br>2、<strong>地理位置不同</strong>，虽然黟县和歙县同属于黄山市管辖，但是与黄山市相比，黟县位于西北方向，歙县位于东北方向；<br>3、<strong>历史遗址不同</strong>，黟县是“徽商”和“徽文化”的发祥地之一；景区以西递、宏村、塔川村为代表，歙县，秦朝置县，宋朝设立徽州府，境内徽州古城是我国保存完好的四大古城之一，景点以徽州古城、徽商大宅院、新安江山水画廊，雄村景区、棠樾牌坊群等景点为主。</p><p>都是徽州文化的根源之一</p><p>1997年被列入《世界遗产名录》，与同为第二批国家历史文化名城的<strong>四川阆中、山西平遥、安徽歙县</strong>并称为“保存最为完好的四大古城”。</p><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>淮南到宏村，车程大概4个半小时，快到宏村有一段因为隧道正在施工，我们绕行，走的那段山路非常刺激，坡度很大，道很窄，但是跟之后的皖南的川藏线进出六道湾那两截的上路倒是不能比。</p><h3 id="宏村"><a href="#宏村" class="headerlink" title="宏村"></a>宏村</h3><p>宏村景色从南湖展开，刚进去沿着湖边都是写生的学生，大多数都在练习水彩。正纳闷为什么这地方会成为写生基地，随手拍了一张照片，还真有水彩画的感觉吧。 徽派建筑特色，青砖白瓦马头墙。</p><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/hongcun.jpg"></p><p>民宿就在宏村的边上，走路到宏村也就是10分钟左右的时间，周边就是居民区，吃饭什么的非常方便。过来写生的学生的住处在我们的周边，晚上倒是很热闹。村落相对来说比较老，自然。</p><p>宏村的检票处非常简陋，可以是几个人拦着路进行检票。下午过去的时候，我背着包，他们估计把我认成了写生的学生，没检我的票。出来的时候我就把订的票给取消了。晚上去的时候检票了，我又重新买了一张。宏村购票的时候我不知道应届毕业生也享受学生优惠，他们的优惠条例上都没有写，果然还得多问一嘴，后面的景点门票省掉不少。</p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="西递"><a href="#西递" class="headerlink" title="西递"></a>西递</h3><p>西递游客少，村落大，建筑多</p><p>西递的建筑和规划要比宏村好一点，西递水少。相较于西递，宏村的规划有点乱乱的。 今天约了一个导游，给我们介绍西递的历史，各个景点成名的由来。令我印象深刻的是，村里的每一户大家装修都有着自己的想法和独特的风格，而且还会契合自己的社会地位，大堂的两边都有对联，对主人公的为人处世的思想进行抒发。</p><p>一开始我会有疑问，那时候交通那么不发达，高就之后还要回村子修建住处。原来是落叶归根的思想，根在家乡，人无论漂泊多远，最终都希望回到故乡、回归本源。晚年都会回归家乡，归乡是对家族责任的履行。</p><p>一边听讲解一边逛景点感觉不一样，没有讲解逛景点是想着找点位，构图。有讲解能进一步感受古建筑的魅力，感受每户人家装修设计的巧思，了解每户人家的家训这样设立的缘由，文化底蕴，感慨中国文化的博大精深。 宏村更自然，西递开发的更好，人文气息更强烈一点，但是都没有乌镇那么商业化。 也是有很多写生的学生，问了一下，这边是写生基地和研学基地。 中午在旁边吃的徽式炒面，好吃的。 脚底下踩着青石（黟石，黄山古称黟山），遇水变黑。</p><p>西递的村落后面有一大片的农田，生态环境很好。还可以爬到山上的亭子一览西递的村落分布。</p><h3 id="新安江山水画廊"><a href="#新安江山水画廊" class="headerlink" title="新安江山水画廊"></a>新安江山水画廊</h3><p>下午前往</p><p>到的时候还有一个小时开船，有奶奶向我们售卖李子，买了一点，非常难吃，非常酸。后来得知他们的李子也是进的，根本不是自己家的。</p><p>跟我们一船的人少，船舱大概上客1/4到1/3吧。</p><p>新安江+游船，工作人员带去三个景点，九姓渔风表演，博物馆（第一轿和第一床）和大香樟树，冰雪大世界（自费10元租棉袄和鞋套）绝大多数时间都在船上度过。 沿江风景不错，下雨之后山水之间真像水墨画。 山里阴晴不定，到景点一之前艳阳高照，表演快结束了开始下大雨，景点二逛完恢复晴天。</p><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/xinanjiangshanshuihualang.jpg"></p><p>个人认为游玩的性价比不是很大，船票加上门票成人就得160，绝大部分时间就是在船上欣赏江景。人少天气凉快还好，人多加上天热体验会大打折扣。游船带着去景点我觉得也一般，像是硬凑出来的。景点二倒是不错，有第一床和第一轿，还有一颗千年大榕树。九姓渔风表演和体验冰库感知不强。冰雪大世界只租了棉袄和鞋套，我去我穿的是短裤，小腿冻得邦邦硬。搁里面呆不到十分钟就受不了出来了，着实太冷了。我就说游船怎么就停留不到半个小时，因为里面长时间根本呆不住人。</p><h3 id="徽州古镇"><a href="#徽州古镇" class="headerlink" title="徽州古镇"></a>徽州古镇</h3><p>晚上前往徽州古镇</p><p>住宿：歙县，离徽州古镇1.3公里</p><p>工作人员说是走路到徽州古城大概15分钟，但是实际上走了好长时间，半小时左右。</p><p>徽州古镇晚上逛了一圈，觉得没什么的好玩，遂决定下一天一早就前往皖南川藏线。逛街的时候发现了一个形状非常圆润的木梳子，果断拿下，还价给还晕乎了，果然还是实力不够。</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><h3 id="皖南川藏线"><a href="#皖南川藏线" class="headerlink" title="皖南川藏线"></a>皖南川藏线</h3><blockquote><p>小红书找的攻略图</p></blockquote><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/wannanchuanzangxianfromredbook.png"></p><p>从宁国青龙乡东入口进入，在云深不知处咖啡店前车辆可以冲水（不影响他人情况下）水很凉，玩水很舒服。 夏天红杉林没啥看的，没有停车。 中间有一段love路围栏是粉红色的，很有意思。 沿着川藏线一直走，山路十八弯，不断地上山，下山。中间一截山路非常险峻，而且还窄。途中还会遇到野猴子要东西，很多游客会停下来喂食，很容易导致堵车（因为山路本身很窄，而且高低落差大）。 月亮湾就漂流的地方，没去。 下午五点半到的鱼鳞坝，也能冲水，范围比云深不知处下面的玩水的地方大很多。非常适合玩水。 在车不是很多的情况下，自驾游非常爽，非常考验车技和对距离的把握。沿途风景也相当哇塞。</p><p>早上的人少，时间越往后，人和车越来越多。</p><p>晚上住在合肥市区。</p><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p>住在了合肥万象城附近，我觉得合肥万象城的档次要比我们这的商圈吾悦广场要高很多。</p><p>安徽省博物院新馆</p><p>正好赶上国宝回归特展，看到了部分圆明园遗失的兽首铜像</p><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/%E5%85%BD%E9%A6%96%E9%93%9C%E5%83%8F.jpg"></p><p>做工非常精致，栩栩如生。虎头“王”延伸到后脑勺了有一条装饰线。猪头的后脑勺瘪下去一块儿。内部是中空的，本来就是作为水龙头的。</p>]]></content>
    
    
    <summary type="html">皖南一带自驾游</summary>
    
    
    
    <category term="旅游" scheme="https://dra-tammer.github.io/categories/%E6%97%85%E6%B8%B8/"/>
    
    <category term="游记" scheme="https://dra-tammer.github.io/categories/%E6%97%85%E6%B8%B8/%E6%B8%B8%E8%AE%B0/"/>
    
    
    <category term="旅游" scheme="https://dra-tammer.github.io/tags/%E6%97%85%E6%B8%B8/"/>
    
    <category term="游记" scheme="https://dra-tammer.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>玩机小软件</title>
    <link href="https://dra-tammer.github.io/posts/25ea7411.html"/>
    <id>https://dra-tammer.github.io/posts/25ea7411.html</id>
    <published>2025-07-24T13:49:29.000Z</published>
    <updated>2025-07-24T13:49:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="localsend"><a href="#localsend" class="headerlink" title="localsend"></a>localsend</h2><p><a href="https://localsend.org/">https://localsend.org/</a></p><p>跨平台局域网文件互传</p><h2 id="Snipaste"><a href="#Snipaste" class="headerlink" title="Snipaste"></a>Snipaste</h2><p><a href="https://zh.snipaste.com/">https://zh.snipaste.com/</a></p><p>无敌好用的剪切板</p><h2 id="Listary"><a href="#Listary" class="headerlink" title="Listary"></a>Listary</h2><p><a href="https://www.listary.com/">https://www.listary.com/</a></p><p>简洁的文件搜索工具，能够快速打开文件或者启动应用</p><h2 id="Everything"><a href="#Everything" class="headerlink" title="Everything"></a>Everything</h2><p><a href="https://www.voidtools.com/zh-cn/downloads/">https://www.voidtools.com/zh-cn/downloads/</a></p><p>深度文件搜索工具，快速文件搜索引擎</p><h2 id="Geek"><a href="#Geek" class="headerlink" title="Geek"></a>Geek</h2><p><a href="https://geekuninstaller.com/">https://geekuninstaller.com/</a></p><p>应用卸载工具</p><h2 id="ContextMenuManager"><a href="#ContextMenuManager" class="headerlink" title="ContextMenuManager"></a>ContextMenuManager</h2><p><a href="https://github.com/BluePointLilac/ContextMenuManager">https://github.com/BluePointLilac/ContextMenuManager</a></p><p>纯粹的Windows右键菜单管理程序，可以启用或者禁用、修改或者添加各种场景的右键菜单项目</p><h2 id="图吧工具箱"><a href="#图吧工具箱" class="headerlink" title="图吧工具箱"></a>图吧工具箱</h2><p><a href="https://www.tbtool.cn/">https://www.tbtool.cn/</a></p><p>图吧工具箱，是开源、免费、绿色、纯净的硬件检测工具合集，专为所有计算机硬件极客、DIY爱好者、各路大神及小白制作。集成大量常见硬件检测、评分工具，一键下载、方便使用。</p><h2 id="向日葵远程控制"><a href="#向日葵远程控制" class="headerlink" title="向日葵远程控制"></a>向日葵远程控制</h2><p><a href="https://sunlogin.oray.com/">https://sunlogin.oray.com/</a></p><p>手机远程控制电脑的软件</p><p>远程控制手机，远程桌面连接，远程开机，远程管理等</p><h2 id="Bitwarden"><a href="#Bitwarden" class="headerlink" title="Bitwarden"></a>Bitwarden</h2><p><a href="https://bitwarden.com/">https://bitwarden.com/</a></p><p>密码管理器，一个主密码管理其他所有的密码</p><h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p><a href="https://picgo.github.io/PicGo-Doc/zh/">https://picgo.github.io/PicGo-Doc/zh/</a></p><p>图片上传，管理软件，能连接各大厂商的对象存储服务</p><p>解决博客图片的问题</p><p>一个用于快速上传图片并获取图片 URL 链接的工具</p><h2 id="AstroBox"><a href="#AstroBox" class="headerlink" title="AstroBox"></a>AstroBox</h2><p><a href="https://astrobox.online/">https://astrobox.online/</a></p><p>为小米Vela（基于开源实时操作系统NuttX打造的物联网嵌入式软件平台）穿戴设备打造的多功能工具箱</p><h2 id="轻云"><a href="#轻云" class="headerlink" title="轻云"></a>轻云</h2><p><a href="https://qingyun.world/">https://qingyun.world/</a></p><p>科学上网</p><h2 id="Obisidian"><a href="#Obisidian" class="headerlink" title="Obisidian"></a>Obisidian</h2><p><a href="https://obsidian.md/">https://obsidian.md/</a></p><p>Markdown编辑器，亮点是能够快速地连接两篇文章。还可以查看关系图谱，查看文章的入链和出链。</p><h2 id="椒盐音乐"><a href="#椒盐音乐" class="headerlink" title="椒盐音乐"></a>椒盐音乐</h2><p><a href="https://moriafly.com/program/spw.html">https://moriafly.com/program/spw.html</a></p><p>本地音乐播放器</p><h2 id="音乐标签"><a href="#音乐标签" class="headerlink" title="音乐标签"></a>音乐标签</h2><p>[下载链接去找酷安老哥]</p><p><a href="https://wwt.lanzout.com/i2cIo1u9oawh">https://wwt.lanzout.com/i2cIo1u9oawh</a></p><p>将音乐标题、演唱者姓名、封面图、歌词、专辑名等信息添加至音乐文件中的软件</p><h2 id="NCM2MP3"><a href="#NCM2MP3" class="headerlink" title="NCM2MP3"></a>NCM2MP3</h2><p><a href="https://github.com/charlotte-xiao/NCM2MP3">https://github.com/charlotte-xiao/NCM2MP3</a></p><p>开源项目，需要自己部署。环境：Java8，maven等</p><p>网易云ncm音乐格式转换为mp3音乐格式工具，支持多线程批量转换</p><h2 id="MT管理器"><a href="#MT管理器" class="headerlink" title="MT管理器"></a>MT管理器</h2><p><a href="https://mt2.cn/">https://mt2.cn/</a></p><p>Android 平台文件管理 &amp; 逆向修改神器。独创的双窗口操作模式，两个目录同时显示，结合前进/后退/同步等功能，熟悉之后相比传统操作方式更加高效。</p>]]></content>
    
    
    <summary type="html">有意思的自用的玩机小软件，或者一些好玩的开源项目，能够优化平时使用电子设备的体验。</summary>
    
    
    
    <category term="玩机" scheme="https://dra-tammer.github.io/categories/%E7%8E%A9%E6%9C%BA/"/>
    
    <category term="软件" scheme="https://dra-tammer.github.io/categories/%E7%8E%A9%E6%9C%BA/%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="经验" scheme="https://dra-tammer.github.io/categories/%E7%8E%A9%E6%9C%BA/%E8%BD%AF%E4%BB%B6/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="经验" scheme="https://dra-tammer.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="玩机" scheme="https://dra-tammer.github.io/tags/%E7%8E%A9%E6%9C%BA/"/>
    
    <category term="软件" scheme="https://dra-tammer.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>罗小黑战记2</title>
    <link href="https://dra-tammer.github.io/posts/d4ab1ec4.html"/>
    <id>https://dra-tammer.github.io/posts/d4ab1ec4.html</id>
    <published>2025-07-24T04:11:33.000Z</published>
    <updated>2025-07-24T04:11:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>2025-07-19</code></p><p>跟Y出去看电影，本来想看《你行！你上！》，但是看风评两极分化，同时之前没有看过姜文的电影。故此改签。这个决定是正确的。</p><h2 id="剧情概述"><a href="#剧情概述" class="headerlink" title="剧情概述"></a>剧情概述</h2><p>电影开场介绍了小黑和师傅的日常生活，之后介绍保存能够精灵造成伤害的若木的会馆被袭击，馆长被干死，嫌疑人指向无限。无限被软禁在总部，无限的关门弟子鹿野和锁门弟子罗小黑去寻找真相。中间就是寻找真相的过程。中间穿插了师姐被无限救赎的过程。最后真相水落石出，发现幕后主使是妖精这边的长老之一。在钢铁厂进行战斗，拿下长老。无限那边单人进攻保存若木的人类基地，枪，炮，炸弹，核弹，天基炮，激光，不能伤无限丝毫。无限只是防御，最后进入指挥室。长老把若木又在其他地方保存了一份。来寻求人类和妖精之间微妙的平衡。</p><h2 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h2><p>文戏通俗易懂，打戏相当精彩。我觉得要比柯南精彩很多。人物对话诙谐，很有生活感。人物外形设计相当有记忆点，罗小黑可爱，鹿野和无限高冷但是有爱。一开始看的时候幻视X战警哈哈哈哈。那里的变种人就是这里的妖精。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>通过这个电影，发现了一个新的IP罗小黑。于是就追了追TV，电影，漫画。TV每集就5，6分钟，一共40集。完全不够看，叙事倒是不拖沓，画风很可爱，内容也很吸引人。当时追魔法禁书目录和炮姐的时候感觉有点拖沓。TV的故事是在大电影2之后发生的事儿，大电影1叙述罗小黑和师傅无限相遇的过程。漫画《兰溪镇》补全了古老时期的人物和设定，也就是大电影1之前的设定。</p><h2 id="大电影1"><a href="#大电影1" class="headerlink" title="大电影1"></a>大电影1</h2><p>大电影1也是打戏非常出众，人物设计也非常可爱。讲的也是人类和妖精之间的矛盾，人类的发展占据了妖精的生存场地。妖精在人类中生活得隐藏自己的身份。风息有获得其他人能力的能力，被吸收的人能力会失去，但是肉身不会死，会很虚弱。想要罗小黑的空间系的领域能力构建超大领域，在领域中领域的主人就是神，从而控制人类。本来是忽悠罗小黑让其和自己一道，最后被小黑发现了他对自己好是为了自己的能力之后拒绝合作，风息就控制了小黑，吸收他的能力，小黑处于濒死状态，如果关闭风息打开的领域，小黑就会死。一开始无限在风息中硬刚，之后小黑苏醒通过嘿咻（这个嘿咻超标，定位器，监视器，换位器的作用）进入自己的领域，伙同携手阻止的故事。最后风息化成了森林。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>非常好看的一部电影，放松心情可以去看。没有太深的思考。倒是有国际形势的映射。有意思的是，欧美的电影反派基地的母语很多是苏联。内地电影反派的语言就是英语。这个设计很好很有意思。</p><p>像这种更新速度非常慢的IP，我觉得看完之后就直接给他忘记，之后等他自己找上门来就行了，要不然牵挂太多。</p><p>推荐指数：⭐⭐⭐⭐☆</p>]]></content>
    
    
    <summary type="html">暑期档罗小黑战记观后感</summary>
    
    
    
    <category term="电影" scheme="https://dra-tammer.github.io/categories/%E7%94%B5%E5%BD%B1/"/>
    
    <category term="观后感" scheme="https://dra-tammer.github.io/categories/%E7%94%B5%E5%BD%B1/%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    
    <category term="动漫" scheme="https://dra-tammer.github.io/categories/%E5%8A%A8%E6%BC%AB/"/>
    
    <category term="国漫" scheme="https://dra-tammer.github.io/categories/%E5%8A%A8%E6%BC%AB/%E5%9B%BD%E6%BC%AB/"/>
    
    
    <category term="电影" scheme="https://dra-tammer.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
    <category term="观后感" scheme="https://dra-tammer.github.io/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    
    <category term="动漫" scheme="https://dra-tammer.github.io/tags/%E5%8A%A8%E6%BC%AB/"/>
    
    <category term="国漫" scheme="https://dra-tammer.github.io/tags/%E5%9B%BD%E6%BC%AB/"/>
    
  </entry>
  
  <entry>
    <title>新-驯龙高手</title>
    <link href="https://dra-tammer.github.io/posts/7594ad05.html"/>
    <id>https://dra-tammer.github.io/posts/7594ad05.html</id>
    <published>2025-06-22T04:11:48.000Z</published>
    <updated>2025-06-22T04:11:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>2025-06-20</code></p><p>想找L出去看电影，突然发现驯龙高手出真人改编了，遂去看。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>就是动画版的驯龙高手的真人化改编，叙事流程几乎一摸一样，名场面的运镜也是一模一样，存在部分的删减和增加。就是特效更加好看了，更加真实了一些。</p><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>重温了小时候喜欢的动画，因为流程几乎一模一样，所以剧情方面没有新鲜感。特效很棒，选角很好，很有代入感。</p><p>推荐指数：⭐⭐⭐⭐☆</p>]]></content>
    
    
    <summary type="html">六月档新-驯龙高手观后感</summary>
    
    
    
    <category term="电影" scheme="https://dra-tammer.github.io/categories/%E7%94%B5%E5%BD%B1/"/>
    
    <category term="观后感" scheme="https://dra-tammer.github.io/categories/%E7%94%B5%E5%BD%B1/%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    
    
    <category term="电影" scheme="https://dra-tammer.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
    <category term="观后感" scheme="https://dra-tammer.github.io/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>四川成都之行</title>
    <link href="https://dra-tammer.github.io/posts/ec1b7777.html"/>
    <id>https://dra-tammer.github.io/posts/ec1b7777.html</id>
    <published>2025-04-04T03:28:04.000Z</published>
    <updated>2025-04-04T03:28:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从青铜神树，千年堤堰到现代都市"><a href="#从青铜神树，千年堤堰到现代都市" class="headerlink" title="从青铜神树，千年堤堰到现代都市"></a>从青铜神树，千年堤堰到现代都市</h2><p><code>2025-04-05 ~ 2025-04-10</code></p><p><code>with Ran</code></p><p>玺悦·冠御高空酒店（文殊院店）</p><p>三星堆</p><p>菲思南桥酒店（都江堰景区离堆公园站店）</p><p>熊猫谷，都江堰，青城山</p><p>美城爱舍投影主题公寓（锦华万达中港广场店）</p><p>武侯祠，金沙博物馆</p><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="三星堆"><a href="#三星堆" class="headerlink" title="三星堆"></a>三星堆</h4><p>从初现到一醒、再醒，已有近半年。</p><p>突出的大眼对应了《华阳国志》关于：“有蜀侯蚕丛，其目纵，史称王“的记载。蚕丛就是李白《蜀道难》“蚕丛及鱼凫，开国何茫然“所歌咏的初代楚王。突出的纵目也是古蜀对眼睛的崇拜，眼睛寻找光明，光明来自太阳。方向盘其实或许是太阳轮，反映的是太阳崇拜。过去的人认为古蜀是隔绝在中原之外的，但是三星堆的出现，确认古蜀不是一座孤岛。无不感叹古蜀人天马行空的想象力。</p><h4 id="都江堰"><a href="#都江堰" class="headerlink" title="都江堰"></a>都江堰</h4><p>想要引岷江的水灌溉成都平原，历史上岷江是一个悬空河，丰水期会发生洪灾。天才李冰父子。</p><p>开个口子引向成都，这就是都江堰的宝瓶口。宝瓶口控制是不够的，要建一个鱼嘴，将岷江一分为二，形成内江和外江。外江要宽一些，河底加高，最终形成内江深且窄，外江浅且宽的布局。四六分水。宝瓶口控制还不够，在宝瓶口再开一个河道，河床高一些，这是飞沙堰。二八分沙。内江弯曲，在宝瓶口这里，水流会因为离堆产生回流，离心力的作用会甩向飞沙堰。深淘沙，低作堰。</p><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/dujiangyan.png"></p><h4 id="青城山"><a href="#青城山" class="headerlink" title="青城山"></a>青城山</h4><p>中国道教的发源地之一，属道教名山之一。传说道教天师张道陵晚年显道于青城山，并在此羽化，此后，青城山成为天师道的祖山。在四川名山中与剑门之险、峨眉之秀、夔门之雄齐名，有“青城天下幽”之美誉。</p><h4 id="武侯祠"><a href="#武侯祠" class="headerlink" title="武侯祠"></a>武侯祠</h4><p>成都武侯祠，是中国唯一的君臣合祀祠庙，是祠堂与陵园合一的格局。由武侯祠、汉昭烈庙及惠陵组成，人们习惯将三者统称为武侯祠。</p><h2 id="游前攻略"><a href="#游前攻略" class="headerlink" title="游前攻略"></a>游前攻略</h2><p><code>摘自 小红书</code></p><p>“天府广场周围 天府广场有个二次元中心，喜欢动漫的可以好好逛逛。<br>武侯祠、人民公园（钟水饺好吃！公园相亲角，里面有好多搞笑的人投稿）四川博物馆和附近的青羊宫（我和对象比较喜欢逛馆，所以对这些文化的东西有兴趣）三星堆（在周边市区，得坐车去）熊猫基地我觉得都江堰的熊猫谷比成都市的好看，成都市熊猫基地可以看网红熊猫，都江堰的可以近距离接触国宝（当然不能摸哈哈，离十米左右），人也不是很多，都江堰景区我觉得纯走。太古里、春熙路、东郊记忆可以去转，但是太潮了哈哈get不到有啥好玩的地方。<br>好吃的地方：抚琴夜市、犀浦夜市随便去吃就行，不要去宽窄巷子、锦里吃，都很贵，进去走走逛逛就好。”</p><p><code>By Ran</code></p><p>成都<br>4.5 晚上直接到酒店(住春熙路附近)<br>4.6<br>上午 春熙路→直通车到三星堆<br>下午 三星堆→直通车回春熙路<br>晚上 春熙路周边逛逛<br>4.7<br>上午 酒店退房→地铁2号线到犀浦站→高铁到都<br>江堰站→打车到熊猫谷,有行李寄存<br>中午离开熊猫谷→打车到酒店(住离堆公园附近)<br>放行李吃饭<br>下午 步行到都江堰<br>晚上 随便逛逛或休息<br>4.8<br>上午 酒店退房→打车到青城山,有行李寄存<br>下午 离开青城山→打车到青城山站→高铁到市区<br>酒店放行李<br>晚上 随便逛逛或休息<br>4.9<br>上午 地铁到金沙遗址博物馆<br>下午 地铁到武侯祠→川大望江校区<br>晚上 随便逛逛或休息<br>4.10<br>吃完中饭离开<br>大体上安排,去的那天不算:<br>第一天去三星堆(因为距离很远)<br>第二天去熊猫谷都江堰<br>第三天青城山<br>第四天和第五天上午(住在市里,交通方便)可以<br>去金沙博物馆,武侯祠,川大等等,第五天下午<br>徹退<br>酒店安排:春熙路住2晚,都江堰住1晚,最后市<br>区随便住2晚<br>太古里内部的大慈寺<br>太古里一旁的东糠市街，叶婆婆钵钵鸡。钵钵鸡上菜后，肉菜泡两分钟，素菜泡五分钟<br>玉林路吃饭，玉林串串香<br>人民公园<br>成都博物馆，魁星楼街，西安路<br>宽窄巷子<br>金沙博物馆</p><h2 id="实际游玩顺序"><a href="#实际游玩顺序" class="headerlink" title="实际游玩顺序"></a>实际游玩顺序</h2><p>5号晚上到成都天府广场</p><h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>上午春熙路坐直通车到三星堆博物馆，下午直通车回春熙路，之后去杜甫草堂，宽窄巷子。</p><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><p>地铁2号线到犀浦站→高铁到都江堰站</p><p>打车都江堰</p><h3 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h3><p>上午去青城山</p><p>下午回市内，打车到青城山站→高铁到市区</p><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p>上午打车到熊猫基地，中午打车回酒店休息，下午打车到武侯祠</p><h3 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h3><p>上午川大，下午返程</p><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>由于落地就搞了一个麦当劳套餐，狂喝冰可乐，最终搞得肠胃炎，第一天晚上挂的急诊，养了两天病，很多地方没去。久久不能释怀。</p><p>成都及其周边能够游玩的东西很多，很推荐过来玩。</p><h2 id="有意思的发现"><a href="#有意思的发现" class="headerlink" title="有意思的发现"></a>有意思的发现</h2><p>来回高铁票263纪念蜀汉政权263年灭亡<br>智能动车辅助乘务员换边的把手上有盲文，标注排数和左右座位对应的字母。<br>成都地铁站台地方小，虽然有的是一个中转大站。<br>四川科技馆前面毛主席挥手雕像<br>成都地铁启动加速度大。<br>成都离堆往返的火车像是地铁改hhh。<br>电梯大多数都有盲文。<br>最后一天住的酒店跟杭州的有一次差不多，给了赔偿价目。<br>打车去熊猫基地的路上经过了二仙桥站</p><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/sunhuaipeichang"></p><p>成都口味重。<br>不少茶楼。<br>出租车司机脾气都挺大。<br>这边混沌，面买的时候按两算，像是现在吃的混沌一两八块，二两十块，三两12</p><p>推荐指数：⭐⭐⭐⭐⭐</p>]]></content>
    
    
    <summary type="html">四川成都，广汉，都江堰</summary>
    
    
    
    <category term="旅游" scheme="https://dra-tammer.github.io/categories/%E6%97%85%E6%B8%B8/"/>
    
    <category term="游记" scheme="https://dra-tammer.github.io/categories/%E6%97%85%E6%B8%B8/%E6%B8%B8%E8%AE%B0/"/>
    
    
    <category term="旅游" scheme="https://dra-tammer.github.io/tags/%E6%97%85%E6%B8%B8/"/>
    
    <category term="游记" scheme="https://dra-tammer.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>历史的温度5</title>
    <link href="https://dra-tammer.github.io/posts/bcb57ef9.html"/>
    <id>https://dra-tammer.github.io/posts/bcb57ef9.html</id>
    <published>2025-02-19T08:05:55.000Z</published>
    <updated>2025-02-19T08:05:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>start from 2025-01-19</code></p><p><code>end on 2025-02-19</code></p><p><code>馒头大师</code></p><blockquote><p>读懂过去，活好当下，坦面未来</p></blockquote><p>高中毕业之后就再也没想着看过，一眨眼就出到7了，遂买来看一下，还是高中时的感觉，还是能沉迷到历史故事里面。就好比时隔四年同学再见面一样，仿佛前一天还在一起上晚自习。可惜，时光荏苒，一切得向前看。</p>]]></content>
    
    
    <summary type="html">作者：馒头大师</summary>
    
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>reinforcement_learning</title>
    <link href="https://dra-tammer.github.io/posts/f7d57928.html"/>
    <id>https://dra-tammer.github.io/posts/f7d57928.html</id>
    <published>2025-01-27T09:28:38.000Z</published>
    <updated>2025-01-27T09:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h1><blockquote><p>强化学习，是agent在与环境的互动当中为了达成一个目标而进行的学习过程</p></blockquote><blockquote><p>玩家与环境的互动当中，为了达成一个目标而进行的学习过程</p></blockquote><p>强化学习学习的东西实际上就是一个好的价值函数，一个好的价值函数决定一个好的策略。</p><h2 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h2><h3 id="agent"><a href="#agent" class="headerlink" title="agent"></a>agent</h3><p>与环境进行互动的主体（玩家）</p><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>游戏本身</p><h3 id="goal"><a href="#goal" class="headerlink" title="goal"></a>goal</h3><p>强化学习的目的是最大化总的奖励</p><h2 id="主要元素"><a href="#主要元素" class="headerlink" title="主要元素"></a>主要元素</h2><h3 id="state-状态"><a href="#state-状态" class="headerlink" title="state 状态"></a>state 状态</h3><h3 id="action-行动"><a href="#action-行动" class="headerlink" title="action 行动"></a>action 行动</h3><p>在某个状态需要进行的行动</p><h3 id="reward-奖励"><a href="#reward-奖励" class="headerlink" title="reward 奖励"></a>reward 奖励</h3><p>agent在一个状态之下采取了特定的行动之后所得到的即时的反馈</p><h2 id="核心元素"><a href="#核心元素" class="headerlink" title="核心元素"></a>核心元素</h2><h3 id="policy-策略"><a href="#policy-策略" class="headerlink" title="policy 策略"></a>policy 策略</h3><p>在某一个状态下应该采取什么样的行动，在数学上策略就是一个函数，它的自变量，也就是输入是一个状态，因变量是一个行动</p><h3 id="value-价值"><a href="#value-价值" class="headerlink" title="value 价值"></a>value 价值</h3><p>价值也是一个函数，策略函数取决于价值函数。预期将来会得到的所有奖励之和。处于当前的状态之下，玩家在将来能够得到的所有奖励的一个期望值。</p><h4 id="state-value-状态价值函数"><a href="#state-value-状态价值函数" class="headerlink" title="state value 状态价值函数"></a>state value 状态价值函数</h4><p>输入是一个状态，输出是一个实数，也就是这个状态的价值。通过状态价值函数玩家应该选择进入价值尽可能大的状态，这是通过特定的行动来实现的，这就是状态价值函数决定了玩家的策略。</p><h4 id="state-action-value-状态行动价值函数"><a href="#state-action-value-状态行动价值函数" class="headerlink" title="state-action value 状态行动价值函数"></a>state-action value 状态行动价值函数</h4><p>在特定状态下，采取某种行动所具有的价值。在特定的状态下，根据状态行动价值函数，玩家应该选择价值最大的那一个行动，这就是状态行动价值函数决定了玩家的策略。</p><h2 id="强化学习的三层结构"><a href="#强化学习的三层结构" class="headerlink" title="强化学习的三层结构"></a>强化学习的三层结构</h2><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/reinforcement_leanring.png"></p><h2 id="强化学习的两个特点"><a href="#强化学习的两个特点" class="headerlink" title="强化学习的两个特点"></a>强化学习的两个特点</h2><h3 id="Trial-and-Error-试错"><a href="#Trial-and-Error-试错" class="headerlink" title="Trial and Error 试错"></a>Trial and Error 试错</h3><p>强化学习是一个试错学习，也就是在不断的尝试中去学习</p><h3 id="Delayed-Reward-延迟奖励"><a href="#Delayed-Reward-延迟奖励" class="headerlink" title="Delayed Reward 延迟奖励"></a>Delayed Reward 延迟奖励</h3><p>行动没有对应即时的奖励，但是每一步棋对于最后的胜利都是有贡献的</p><h2 id="Exploration-vs-Exploitation"><a href="#Exploration-vs-Exploitation" class="headerlink" title="Exploration vs. Exploitation"></a>Exploration vs. Exploitation</h2><blockquote><p>强化学习的核心问题，两者之间的权衡</p></blockquote><h3 id="Exploitation-利用"><a href="#Exploitation-利用" class="headerlink" title="Exploitation 利用"></a>Exploitation 利用</h3><p>利用的是强化学习所学习到的价值函数 </p><h3 id="Exploration-探索"><a href="#Exploration-探索" class="headerlink" title="Exploration 探索"></a>Exploration 探索</h3><p>我们学习到的价值函数不一定是最优的价值函数，有一些看起来价值不是很高的行动，有可能真实的价值是最高的，我们不仅仅要利用已经学习到的价值函数，还应该去尝试不同的行动，从而优化价值函数。</p><h2 id="K-armed-Bandit-多臂老虎机"><a href="#K-armed-Bandit-多臂老虎机" class="headerlink" title="K-armed Bandit 多臂老虎机"></a>K-armed Bandit 多臂老虎机</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bandit 结构体表示一个 K-armed Bandit</span></span><br><span class="line"><span class="keyword">type</span> Bandit <span class="keyword">struct</span> {</span><br><span class="line">    k     <span class="type">int</span></span><br><span class="line">    means []<span class="type">float64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewBandit 创建一个新的 K-armed Bandit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBandit</span><span class="params">(k <span class="type">int</span>)</span></span> *Bandit {</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    means := <span class="built_in">make</span>([]<span class="type">float64</span>, k)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> means {</span><br><span class="line">       means[i] = rand.NormFloat64() <span class="comment">// 每个臂的奖励服从正态分布</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> &amp;Bandit{</span><br><span class="line">       k:     k,</span><br><span class="line">       means: means,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pull 模拟拉动一个臂并返回奖励</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bandit)</span></span> Pull(arm <span class="type">int</span>) <span class="type">float64</span> {</span><br><span class="line">    <span class="keyword">if</span> arm &lt; <span class="number">0</span> || arm &gt;= b.k {</span><br><span class="line">       <span class="built_in">panic</span>(<span class="string">"invalid arm"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> b.means[arm] + rand.NormFloat64() <span class="comment">// 奖励 = 均值 + 噪声</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// EpsilonGreedy 实现 epsilon-greedy 策略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EpsilonGreedy</span><span class="params">(bandit *Bandit, numPlays <span class="type">int</span>, epsilon <span class="type">float64</span>)</span></span> <span class="type">float64</span> {</span><br><span class="line">    Q := <span class="built_in">make</span>([]<span class="type">float64</span>, bandit.k) <span class="comment">// 每个臂的估计值</span></span><br><span class="line">    N := <span class="built_in">make</span>([]<span class="type">int</span>, bandit.k)     <span class="comment">// 每个臂被拉动的次数</span></span><br><span class="line">    totalReward := <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numPlays; i++ {</span><br><span class="line">       <span class="keyword">var</span> arm <span class="type">int</span></span><br><span class="line">       <span class="keyword">if</span> rand.Float64() &lt; epsilon {</span><br><span class="line">          arm = rand.Intn(bandit.k) <span class="comment">// 随机选择一个臂</span></span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">          arm = argMax(Q) <span class="comment">// 选择当前估计值最大的臂</span></span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       reward := bandit.Pull(arm)</span><br><span class="line">       N[arm]++</span><br><span class="line">       Q[arm] += (reward - Q[arm]) / <span class="type">float64</span>(N[arm]) <span class="comment">// 更新估计值</span></span><br><span class="line">       totalReward += reward</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totalReward</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// argMax 返回数组中最大值的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">argMax</span><span class="params">(slice []<span class="type">float64</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">    maxIndex := <span class="number">0</span></span><br><span class="line">    maxValue := slice[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> slice {</span><br><span class="line">       <span class="keyword">if</span> v &gt; maxValue {</span><br><span class="line">          maxIndex = i</span><br><span class="line">          maxValue = v</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxIndex</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    k := <span class="number">10</span></span><br><span class="line">    numPlays := <span class="number">1000</span></span><br><span class="line">    epsilon := <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">    bandit := NewBandit(k)</span><br><span class="line">    totalReward := EpsilonGreedy(bandit, numPlays, epsilon)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"Total reward after %d plays: %.2f\n"</span>, numPlays, totalReward)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="tic-tac-toe-井字棋"><a href="#tic-tac-toe-井字棋" class="headerlink" title="tic tac toe 井字棋"></a>tic tac toe 井字棋</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 棋盘大小</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    rows = <span class="number">3</span></span><br><span class="line">    cols = <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家符号</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Empty = <span class="string">" "</span></span><br><span class="line">    X     = <span class="string">"X"</span></span><br><span class="line">    O     = <span class="string">"O"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 棋盘类型</span></span><br><span class="line"><span class="keyword">type</span> Board [rows][cols]<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化棋盘</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBoard</span><span class="params">()</span></span> Board {</span><br><span class="line">    <span class="keyword">return</span> Board{</span><br><span class="line">       {Empty, Empty, Empty},</span><br><span class="line">       {Empty, Empty, Empty},</span><br><span class="line">       {Empty, Empty, Empty},</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印棋盘</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Board)</span></span> Print() {</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">       <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">          fmt.Printf(<span class="string">" %s "</span>, b[i][j])</span><br><span class="line">          <span class="keyword">if</span> j &lt; cols<span class="number">-1</span> {</span><br><span class="line">             fmt.Printf(<span class="string">"|"</span>)</span><br><span class="line">          }</span><br><span class="line">       }</span><br><span class="line">       fmt.Println()</span><br><span class="line">       <span class="keyword">if</span> i &lt; rows<span class="number">-1</span> {</span><br><span class="line">          fmt.Println(<span class="string">"-----------"</span>)</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    fmt.Println()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否有玩家获胜</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Board)</span></span> CheckWin(player <span class="type">string</span>) <span class="type">bool</span> {</span><br><span class="line">    <span class="comment">// 检查行</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">       <span class="keyword">if</span> b[i][<span class="number">0</span>] == player &amp;&amp; b[i][<span class="number">1</span>] == player &amp;&amp; b[i][<span class="number">2</span>] == player {</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 检查列</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">       <span class="keyword">if</span> b[<span class="number">0</span>][j] == player &amp;&amp; b[<span class="number">1</span>][j] == player &amp;&amp; b[<span class="number">2</span>][j] == player {</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 检查对角线</span></span><br><span class="line">    <span class="keyword">if</span> b[<span class="number">0</span>][<span class="number">0</span>] == player &amp;&amp; b[<span class="number">1</span>][<span class="number">1</span>] == player &amp;&amp; b[<span class="number">2</span>][<span class="number">2</span>] == player {</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> b[<span class="number">0</span>][<span class="number">2</span>] == player &amp;&amp; b[<span class="number">1</span>][<span class="number">1</span>] == player &amp;&amp; b[<span class="number">2</span>][<span class="number">0</span>] == player {</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查棋盘是否已满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Board)</span></span> IsFull() <span class="type">bool</span> {</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">       <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">          <span class="keyword">if</span> b[i][j] == Empty {</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">          }</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取棋盘状态（用于 Q-learning）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Board)</span></span> GetState() <span class="type">string</span> {</span><br><span class="line">    state := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">       <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">          state += b[i][j]</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Q-learning 智能体</span></span><br><span class="line"><span class="keyword">type</span> QAgent <span class="keyword">struct</span> {</span><br><span class="line">    QTable      <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">float64</span> <span class="comment">// Q 表：状态 -&gt; 动作值</span></span><br><span class="line">    Alpha       <span class="type">float64</span>              <span class="comment">// 学习率</span></span><br><span class="line">    Gamma       <span class="type">float64</span>              <span class="comment">// 折扣因子</span></span><br><span class="line">    Epsilon     <span class="type">float64</span>              <span class="comment">// 探索率</span></span><br><span class="line">    Actions     [][<span class="number">2</span>]<span class="type">int</span>             <span class="comment">// 所有可能的动作</span></span><br><span class="line">    CurrentMove [<span class="number">2</span>]<span class="type">int</span>               <span class="comment">// 当前动作</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Q-learning 智能体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQAgent</span><span class="params">(alpha, gamma, epsilon <span class="type">float64</span>)</span></span> *QAgent {</span><br><span class="line">    <span class="comment">// 初始化所有可能的动作</span></span><br><span class="line">    actions := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">       <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">          actions = <span class="built_in">append</span>(actions, [<span class="number">2</span>]<span class="type">int</span>{i, j})</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> &amp;QAgent{</span><br><span class="line">       QTable:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">float64</span>),</span><br><span class="line">       Alpha:   alpha,</span><br><span class="line">       Gamma:   gamma,</span><br><span class="line">       Epsilon: epsilon,</span><br><span class="line">       Actions: actions,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择动作（epsilon-greedy 策略）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(qa *QAgent)</span></span> ChooseAction(state <span class="type">string</span>, board Board) [<span class="number">2</span>]<span class="type">int</span> {</span><br><span class="line">    <span class="comment">// 初始化 Q 表（如果状态不存在）</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := qa.QTable[state]; !ok {</span><br><span class="line">       qa.QTable[state] = <span class="built_in">make</span>([]<span class="type">float64</span>, <span class="built_in">len</span>(qa.Actions))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 探索：随机选择动作</span></span><br><span class="line">    <span class="keyword">if</span> rand.Float64() &lt; qa.Epsilon {</span><br><span class="line">       emptyCells := [][<span class="number">2</span>]<span class="type">int</span>{}</span><br><span class="line">       <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">          <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">             <span class="keyword">if</span> board[i][j] == Empty {</span><br><span class="line">                emptyCells = <span class="built_in">append</span>(emptyCells, [<span class="number">2</span>]<span class="type">int</span>{i, j})</span><br><span class="line">             }</span><br><span class="line">          }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(emptyCells) &gt; <span class="number">0</span> {</span><br><span class="line">          <span class="keyword">return</span> emptyCells[rand.Intn(<span class="built_in">len</span>(emptyCells))]</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用：选择 Q 值最大的动作</span></span><br><span class="line">    maxQ := qa.QTable[state][<span class="number">0</span>]</span><br><span class="line">    bestAction := qa.Actions[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i, q := <span class="keyword">range</span> qa.QTable[state] {</span><br><span class="line">       <span class="keyword">if</span> q &gt; maxQ &amp;&amp; board[qa.Actions[i][<span class="number">0</span>]][qa.Actions[i][<span class="number">1</span>]] == Empty {</span><br><span class="line">          maxQ = q</span><br><span class="line">          bestAction = qa.Actions[i]</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> bestAction</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 Q 表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(qa *QAgent)</span></span> UpdateQTable(state <span class="type">string</span>, actionIndex <span class="type">int</span>, reward <span class="type">float64</span>, nextState <span class="type">string</span>) {</span><br><span class="line">    <span class="comment">// 初始化 Q 表（如果状态不存在）</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := qa.QTable[nextState]; !ok {</span><br><span class="line">       qa.QTable[nextState] = <span class="built_in">make</span>([]<span class="type">float64</span>, <span class="built_in">len</span>(qa.Actions))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Q-learning 更新公式</span></span><br><span class="line">    maxNextQ := qa.QTable[nextState][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, q := <span class="keyword">range</span> qa.QTable[nextState] {</span><br><span class="line">       <span class="keyword">if</span> q &gt; maxNextQ {</span><br><span class="line">          maxNextQ = q</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    qa.QTable[state][actionIndex] += qa.Alpha * (reward + qa.Gamma*maxNextQ - qa.QTable[state][actionIndex])</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Q-learning 智能体</span></span><br><span class="line">    agent := NewQAgent(<span class="number">0.1</span>, <span class="number">0.9</span>, <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 训练次数</span></span><br><span class="line">    numEpisodes := <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计训练过程</span></span><br><span class="line">    winRates := []<span class="type">float64</span>{}</span><br><span class="line">    drawRates := []<span class="type">float64</span>{}</span><br><span class="line">    loseRates := []<span class="type">float64</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 训练过程</span></span><br><span class="line">    <span class="keyword">for</span> episode := <span class="number">0</span>; episode &lt; numEpisodes; episode++ {</span><br><span class="line">       board := NewBoard()</span><br><span class="line">       currentPlayer := X</span><br><span class="line">       <span class="keyword">var</span> lastState <span class="type">string</span></span><br><span class="line">       <span class="keyword">var</span> lastActionIndex <span class="type">int</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> {</span><br><span class="line">          state := board.GetState()</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Q-learning 智能体（X）的回合</span></span><br><span class="line">          <span class="keyword">if</span> currentPlayer == X {</span><br><span class="line">             action := agent.ChooseAction(state, board)</span><br><span class="line">             board[action[<span class="number">0</span>]][action[<span class="number">1</span>]] = X</span><br><span class="line">             lastState = state</span><br><span class="line">             lastActionIndex = <span class="number">-1</span></span><br><span class="line">             <span class="keyword">for</span> i, a := <span class="keyword">range</span> agent.Actions {</span><br><span class="line">                <span class="keyword">if</span> a == action {</span><br><span class="line">                   lastActionIndex = i</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">                }</span><br><span class="line">             }</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">             <span class="comment">// 随机机器人（O）的回合</span></span><br><span class="line">             emptyCells := [][<span class="number">2</span>]<span class="type">int</span>{}</span><br><span class="line">             <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">                <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">                   <span class="keyword">if</span> board[i][j] == Empty {</span><br><span class="line">                      emptyCells = <span class="built_in">append</span>(emptyCells, [<span class="number">2</span>]<span class="type">int</span>{i, j})</span><br><span class="line">                   }</span><br><span class="line">                }</span><br><span class="line">             }</span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">len</span>(emptyCells) &gt; <span class="number">0</span> {</span><br><span class="line">                action := emptyCells[rand.Intn(<span class="built_in">len</span>(emptyCells))]</span><br><span class="line">                board[action[<span class="number">0</span>]][action[<span class="number">1</span>]] = O</span><br><span class="line">             }</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 检查游戏是否结束</span></span><br><span class="line">          <span class="keyword">if</span> board.CheckWin(X) {</span><br><span class="line">             agent.UpdateQTable(lastState, lastActionIndex, <span class="number">1</span>, board.GetState())</span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> board.CheckWin(O) {</span><br><span class="line">             agent.UpdateQTable(lastState, lastActionIndex, <span class="number">-1</span>, board.GetState())</span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> board.IsFull() {</span><br><span class="line">             agent.UpdateQTable(lastState, lastActionIndex, <span class="number">0</span>, board.GetState())</span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 切换玩家</span></span><br><span class="line">          <span class="keyword">if</span> currentPlayer == X {</span><br><span class="line">             currentPlayer = O</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">             currentPlayer = X</span><br><span class="line">          }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 每 100 次训练统计一次结果</span></span><br><span class="line">       <span class="keyword">if</span> episode%<span class="number">100</span> == <span class="number">0</span> {</span><br><span class="line">          wins, draws, losses := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">          <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">             board := NewBoard()</span><br><span class="line">             currentPlayer := X</span><br><span class="line">             <span class="keyword">for</span> {</span><br><span class="line">                state := board.GetState()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> currentPlayer == X {</span><br><span class="line">                   action := agent.ChooseAction(state, board)</span><br><span class="line">                   board[action[<span class="number">0</span>]][action[<span class="number">1</span>]] = X</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                   emptyCells := [][<span class="number">2</span>]<span class="type">int</span>{}</span><br><span class="line">                   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">                      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">                         <span class="keyword">if</span> board[i][j] == Empty {</span><br><span class="line">                            emptyCells = <span class="built_in">append</span>(emptyCells, [<span class="number">2</span>]<span class="type">int</span>{i, j})</span><br><span class="line">                         }</span><br><span class="line">                      }</span><br><span class="line">                   }</span><br><span class="line">                   <span class="keyword">if</span> <span class="built_in">len</span>(emptyCells) &gt; <span class="number">0</span> {</span><br><span class="line">                      action := emptyCells[rand.Intn(<span class="built_in">len</span>(emptyCells))]</span><br><span class="line">                      board[action[<span class="number">0</span>]][action[<span class="number">1</span>]] = O</span><br><span class="line">                   }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> board.CheckWin(X) {</span><br><span class="line">                   wins++</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> board.CheckWin(O) {</span><br><span class="line">                   losses++</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> board.IsFull() {</span><br><span class="line">                   draws++</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> currentPlayer == X {</span><br><span class="line">                   currentPlayer = O</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                   currentPlayer = X</span><br><span class="line">                }</span><br><span class="line">             }</span><br><span class="line">          }</span><br><span class="line">          winRate := <span class="type">float64</span>(wins) / <span class="number">100</span></span><br><span class="line">          drawRate := <span class="type">float64</span>(draws) / <span class="number">100</span></span><br><span class="line">          loseRate := <span class="type">float64</span>(losses) / <span class="number">100</span></span><br><span class="line">          winRates = <span class="built_in">append</span>(winRates, winRate)</span><br><span class="line">          drawRates = <span class="built_in">append</span>(drawRates, drawRate)</span><br><span class="line">          loseRates = <span class="built_in">append</span>(loseRates, loseRate)</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出训练结果</span></span><br><span class="line">    fmt.Println(<span class="string">"训练完成！"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"胜率变化："</span>, winRates)</span><br><span class="line">    fmt.Println(<span class="string">"平局率变化："</span>, drawRates)</span><br><span class="line">    fmt.Println(<span class="string">"失败率变化："</span>, loseRates)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试训练结果</span></span><br><span class="line">    fmt.Println(<span class="string">"开始测试..."</span>)</span><br><span class="line">    board := NewBoard()</span><br><span class="line">    currentPlayer := X</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">       board.Print()</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> currentPlayer == X {</span><br><span class="line">          <span class="comment">// Q-learning 智能体（X）的回合</span></span><br><span class="line">          action := agent.ChooseAction(board.GetState(), board)</span><br><span class="line">          board[action[<span class="number">0</span>]][action[<span class="number">1</span>]] = X</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">          <span class="comment">// 随机机器人（O）的回合</span></span><br><span class="line">          emptyCells := [][<span class="number">2</span>]<span class="type">int</span>{}</span><br><span class="line">          <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ {</span><br><span class="line">             <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ {</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == Empty {</span><br><span class="line">                   emptyCells = <span class="built_in">append</span>(emptyCells, [<span class="number">2</span>]<span class="type">int</span>{i, j})</span><br><span class="line">                }</span><br><span class="line">             }</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> <span class="built_in">len</span>(emptyCells) &gt; <span class="number">0</span> {</span><br><span class="line">             action := emptyCells[rand.Intn(<span class="built_in">len</span>(emptyCells))]</span><br><span class="line">             board[action[<span class="number">0</span>]][action[<span class="number">1</span>]] = O</span><br><span class="line">          }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检查游戏是否结束</span></span><br><span class="line">       <span class="keyword">if</span> board.CheckWin(X) {</span><br><span class="line">          board.Print()</span><br><span class="line">          fmt.Println(<span class="string">"Q-learning 智能体（X）获胜！"</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">if</span> board.CheckWin(O) {</span><br><span class="line">          board.Print()</span><br><span class="line">          fmt.Println(<span class="string">"随机机器人（O）获胜！"</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">if</span> board.IsFull() {</span><br><span class="line">          board.Print()</span><br><span class="line">          fmt.Println(<span class="string">"平局！"</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 切换玩家</span></span><br><span class="line">       <span class="keyword">if</span> currentPlayer == X {</span><br><span class="line">          currentPlayer = O</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">          currentPlayer = X</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">强化学习速度浅入门</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="学习" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="笔记" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="强化学习" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="强化学习" scheme="https://dra-tammer.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>动手学深度学习</title>
    <link href="https://dra-tammer.github.io/posts/b34b3e68.html"/>
    <id>https://dra-tammer.github.io/posts/b34b3e68.html</id>
    <published>2024-11-29T09:57:23.000Z</published>
    <updated>2024-11-29T09:57:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>N维数组是机器学习和神经网络的主要数据结构</p><blockquote><p>3-d：RGB图片（宽 * 高 * 通道 ）</p></blockquote><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ol><li>形状</li><li>每个形状的数据类型</li><li>每个元素的值</li></ol><blockquote><p>对于深度学习的话，64位浮点数计算的比较慢，我们一般使用32位浮点数</p></blockquote><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>线性回归可以看成一个单层的神经网络</p><h2 id="小批量随机梯度下降"><a href="#小批量随机梯度下降" class="headerlink" title="小批量随机梯度下降"></a>小批量随机梯度下降</h2><p>SGD</p><blockquote><p>深度学习默认的求解算法</p></blockquote><p>在整个训练集上算梯度太贵</p><p>随机采样b个样本来近似损失</p><p>两个重要的超参数是批量大小和学习率</p><h2 id="回归-分类"><a href="#回归-分类" class="headerlink" title="回归 &amp; 分类"></a>回归 &amp; 分类</h2><ul><li><p>回归估计一个连续值</p><p>单连续数值输出，自然区间，跟真实值的区别作为损失</p></li><li><p>分类预测一个离散类别</p><p>通常是多个输出，输出i是预测为第i类的置信度</p></li></ul><p>MNIST：手写数字识别</p><p>ImageNet：自然物体分类</p><h2 id="从回归到多类分类-均方损失"><a href="#从回归到多类分类-均方损失" class="headerlink" title="从回归到多类分类-均方损失"></a>从回归到多类分类-均方损失</h2><ul><li>对类别进行一位有效编码</li><li>最大值作为预测</li><li>需要更置信的识别正确类（大余量）</li><li>输出匹配概率</li><li>概率y和yba的区别作为损失</li></ul><blockquote><p>指数的好处是不管是什么值都能给他整成非负</p></blockquote><h2 id="Softmax回归"><a href="#Softmax回归" class="headerlink" title="Softmax回归"></a>Softmax回归</h2><ul><li>多类分类模型</li><li>使用Softmax操作了得到每个类的预测置信度</li><li>使用交叉熵来衡量预测和标号的区别</li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h3 id="平方损失（L2-Loss）"><a href="#平方损失（L2-Loss）" class="headerlink" title="平方损失（L2 Loss）"></a>平方损失（L2 Loss）</h3><p>l(y, ypie) = 1 / 2(y - ypie)^2</p><h3 id="绝对值损失函数（L1-Loss）"><a href="#绝对值损失函数（L1-Loss）" class="headerlink" title="绝对值损失函数（L1 Loss）"></a>绝对值损失函数（L1 Loss）</h3><p>预测值和真实值比较远的时候，梯度也是一个常数，更新的幅度不变，稳定性好一点</p><h3 id="鲁棒损失函数（Huber’s-Robust-Loss）"><a href="#鲁棒损失函数（Huber’s-Robust-Loss）" class="headerlink" title="鲁棒损失函数（Huber’s Robust Loss）"></a>鲁棒损失函数（Huber’s Robust Loss）</h3><h3 id="交叉熵损失函数（CrossEntropyLoss）"><a href="#交叉熵损失函数（CrossEntropyLoss）" class="headerlink" title="交叉熵损失函数（CrossEntropyLoss）"></a>交叉熵损失函数（CrossEntropyLoss）</h3><h2 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h2><p><code>fashion-mnist</code></p><p>测试数据集来预测模型的好坏</p><p>训练集的话是要随机的，但是测试集的话就无所谓了</p><p>一个常见的性能瓶颈，GPU训练的比数据读取的要快</p><h2 id="iter"><a href="#iter" class="headerlink" title="iter()"></a>iter()</h2><p>生成迭代器，逐个地遍历一个可迭代对象</p><h2 id="感知机（MLP）"><a href="#感知机（MLP）" class="headerlink" title="感知机（MLP）"></a>感知机（MLP）</h2><p>做一个二分类的问题</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>不能拟合XOR函数，只能产生线性分割面</p><p>XOR（x =  1, y = 1 ; x = -1, y = -1 =&gt; -1）（x =  1, y = -1 ; x = -1, y = 1 =&gt; 1）</p><p>解决方法：多层感知机</p><h2 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h2><h3 id="单隐藏层-单分类"><a href="#单隐藏层-单分类" class="headerlink" title="单隐藏层-单分类"></a>单隐藏层-单分类</h3><p>隐藏层的大小是一个超参数，因为输入输出不是我们能改的</p><p>多层感知机需要有一个非线性激活函数，否则就还是线性模型，也就是单层感知机</p><p>引入激活函数的本质是引入非线性性 </p><h3 id="sigmoid激活函数"><a href="#sigmoid激活函数" class="headerlink" title="sigmoid激活函数"></a>sigmoid激活函数</h3><h3 id="Tanh激活函数"><a href="#Tanh激活函数" class="headerlink" title="Tanh激活函数"></a>Tanh激活函数</h3><h3 id="ReLU激活函数"><a href="#ReLU激活函数" class="headerlink" title="ReLU激活函数"></a>ReLU激活函数</h3><blockquote><p>指数运算是一个很贵的东西</p></blockquote><h3 id="多类分类"><a href="#多类分类" class="headerlink" title="多类分类"></a>多类分类</h3><p>softmax回归加上一个隐藏层就会变成多层感知机</p><p>softmax把所有的输入拉到一个0和1之间的区域，而且y1加到yk等于1</p><h3 id="多隐藏层"><a href="#多隐藏层" class="headerlink" title="多隐藏层"></a>多隐藏层</h3><ul><li>隐藏层数</li><li>每层隐藏层的大小</li></ul><blockquote><p>输出层是不需要激活函数的，因为激活函数是为了避免隐藏层的塌陷</p></blockquote><p>机器学习可以看作一个压缩的过程，如果维度太高的话，要逐渐压缩</p><p>可以先扩张再压缩 </p><blockquote><p>多层感知机使用隐藏层和激活函数来得到非线性模型</p><p>常用的激活函数由sigmoid，tanh，relu</p><p>使用softmax来处理多类分类</p><p>超参数为隐藏层数，和各个隐藏层的大小</p></blockquote><blockquote><p>一个箭头算成一个层</p></blockquote><h2 id="深度神经网络为什么要增加隐藏层的层数，而不是神经元的个数"><a href="#深度神经网络为什么要增加隐藏层的层数，而不是神经元的个数" class="headerlink" title="深度神经网络为什么要增加隐藏层的层数，而不是神经元的个数"></a>深度神经网络为什么要增加隐藏层的层数，而不是神经元的个数</h2><p>因为层数更深，拟合的效果更好，所以叫深度神经网络，如果就一层特别宽的一层，一口吃个大胖子，非常容易过拟合</p><h2 id="训练误差和泛化误差"><a href="#训练误差和泛化误差" class="headerlink" title="训练误差和泛化误差"></a>训练误差和泛化误差</h2><p>关注的是泛化误差</p><p>训练数据集：训练模型参数</p><p>验证数据集：一个用来评估模型好坏的数据集，选择模型的超参数</p><p>非大数据集上通常使用k-折交叉验证</p><ul><li>例如拿出50%的训练数据</li><li>不要跟训练数据混在一起（常犯错误）</li></ul><p>测试数据集：只用一次的数据集，不能用来调整超参数</p><ul><li>未来的考试</li><li>我出价的房子的实际成交价</li><li>用在kaggle私有排行榜中的数据集</li></ul><h2 id="K-折交叉验证（k-fold）"><a href="#K-折交叉验证（k-fold）" class="headerlink" title="K-折交叉验证（k-fold）"></a>K-折交叉验证（k-fold）</h2><ul><li><p>在没有足够多数据时使用</p></li><li><p>算法：</p><ul><li><p>将训练数据分割成k块</p></li><li><p>for i -&gt; k</p><p>使用第i块作为验证数据集，其余的作为训练数据集</p></li></ul></li><li><p>报告k个数据集误差的平均</p></li><li><p>常用：k = 5或者10</p></li></ul><h2 id="模型容量"><a href="#模型容量" class="headerlink" title="模型容量"></a>模型容量</h2><ul><li>拟合各种函数的能力</li><li>低容量的模型难以拟合训练数据</li><li>高容量的模型可以记住所有的训练数据</li></ul><blockquote><p>过拟合不是一件坏的事儿，首先模型容量要足够大，之后通过各种手段控制模型容量，最后得到泛化误差的下降</p></blockquote><blockquote><p>神经网络是一个很灵活的语言，可编程性很好，但是不好理解</p></blockquote><h2 id="权重衰退"><a href="#权重衰退" class="headerlink" title="权重衰退"></a>权重衰退</h2><p>防止过拟合</p><h2 id="丢弃法"><a href="#丢弃法" class="headerlink" title="丢弃法"></a>丢弃法</h2><p>dropout三个值，0.1，0.5，0.9</p><p>更好的解决过拟合的问题</p><p>在层之间加入噪音，随机加上噪音，等价于Tikhnov</p><p>无偏差加入噪音，但是不影响期望</p><p>通常将丢弃法作用在隐藏全连接层的输出</p><p>正则项只在训练中使用，他们影响模型参数的更新（确定w，b），更新参数的时候，使得模型复杂度降低，在推理过程中，丢弃发直接返回输入</p><p>h = dropout(h)<br>这样也能保证确定性的输出</p><ul><li>丢弃发将一些输出项随机置0来控制模型复杂度</li><li>常作用在多层感知机的隐藏层输出上</li><li>丢弃概率是控制模型复杂度的超参数</li></ul><blockquote><p>dropout作用在全连接层的，BN作用在卷积层</p></blockquote><blockquote><p>cnn可以认为是一个特别的MLP</p></blockquote><h2 id="数值稳定性的常见两个问题"><a href="#数值稳定性的常见两个问题" class="headerlink" title="数值稳定性的常见两个问题"></a>数值稳定性的常见两个问题</h2><p>梯度爆炸和梯度消失，因为做了太多了矩阵乘法，梯度值浮点值</p><h3 id="梯度爆炸"><a href="#梯度爆炸" class="headerlink" title="梯度爆炸"></a>梯度爆炸</h3><p>值超出值域，对于16位浮点数尤为严重</p><p>对学习率敏感</p><p>如果学习率太大，大参数值，更大的梯度</p><p>如果学习率太小，训练无进展</p><p>可能需要在训练过程中不断调整学习率</p><blockquote><p>学习率相当于步长，而梯度则是收敛方向</p><p>权重是学习率乘以梯度</p></blockquote><h3 id="梯度消失"><a href="#梯度消失" class="headerlink" title="梯度消失"></a>梯度消失</h3><p>梯度值变成0，对16位浮点数尤为严重</p><p>训练没有进展，不管如何选择学习率</p><p>对于底部曾尤为严重，仅仅顶部层训练的较好，无法让神经网络更深</p><h2 id="让训练更加稳定"><a href="#让训练更加稳定" class="headerlink" title="让训练更加稳定"></a>让训练更加稳定</h2><p>目标：让梯度值在合理的范围里</p><p>将乘法变成加法（resnet）</p><p>归一化：梯度归一化，梯度裁剪</p><h3 id="合理的权重初始和激活函数"><a href="#合理的权重初始和激活函数" class="headerlink" title="合理的权重初始和激活函数"></a>合理的权重初始和激活函数</h3><h4 id="让每层的方差是一个常数"><a href="#让每层的方差是一个常数" class="headerlink" title="让每层的方差是一个常数"></a>让每层的方差是一个常数</h4><ul><li>将每层的输出和梯度都看作随机变量</li><li>让他们的均值和方差都保持一致</li></ul><h4 id="权重初始化"><a href="#权重初始化" class="headerlink" title="权重初始化"></a>权重初始化</h4><ul><li>在合理值区间里随机初始参数</li><li>训练开始的时候更容易有数值不稳定<ul><li>远离最优解的地方损失函数表面可能很复杂</li><li>最优解附近表面会比较平</li></ul></li><li>使用（n，0.01）来初始可能对小网络没问题，但不能保证深度神经网络</li></ul><blockquote><p>合理的权重初始和激活函数的选取可以提升数值稳定性</p></blockquote><h2 id="前向传播和反向传播"><a href="#前向传播和反向传播" class="headerlink" title="前向传播和反向传播"></a>前向传播和反向传播</h2><h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h3><p>简单理解就是将上一层的输出作为下一层的输入，并计算下一层的输出，一直到运算到输出层为止</p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p><strong>反向传播仅指用于计算梯度的方法。</strong>而另一种算法，例如随机梯度下降法，才是使用该梯度来进行学习。<strong>原则上反向传播可以计算任何函数的到导数</strong></p><p>的确就是复合函数的链式法则</p><p>利用链式法则，BP算法则机智地避开了这种冗余，它对于每一个路径只访问一次就能求顶点对所有下层节点的偏导值</p><p>反向(自上往下)来寻找路径的</p><blockquote><p>宇宙的终极答案：42 ——–《银河系漫游指南》</p></blockquote><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><h3 id="两个原则"><a href="#两个原则" class="headerlink" title="两个原则"></a>两个原则</h3><ul><li>平移不变性</li><li>局部性</li></ul><p> 对全连接层使用平移不变性和局部性得到卷积层</p><h3 id="二维交叉相关"><a href="#二维交叉相关" class="headerlink" title="二维交叉相关"></a>二维交叉相关</h3><p>虽说是卷积层但是计算的时候是交叉相关</p><h3 id="一维和三维交叉相关"><a href="#一维和三维交叉相关" class="headerlink" title="一维和三维交叉相关"></a>一维和三维交叉相关</h3><p>一维：文本，语言，时序序列</p><p>三维：视频，医学图像，气象地图</p><blockquote><p>卷积层将输入和核矩阵进行交叉相关，加上偏移后得到输出</p><p>核矩阵和偏移是可学习的参数</p><p>核矩阵的大小是超参数：控制局部性</p><p>不管输入在哪个位置，核是不变的</p></blockquote><p>卷积层可以认为一个特殊的全连接层，解决了权重随着输入的变大变得特别大</p><h3 id="输入维度"><a href="#输入维度" class="headerlink" title="输入维度"></a>输入维度</h3><p>输入维度都是4-D</p><p>（通道数，批量大小数，长，宽）</p><h3 id="感受野"><a href="#感受野" class="headerlink" title="感受野"></a>感受野</h3><p>卷积层深一点，核小一点，效果更好，一般3<em>3或者5</em>5</p><h3 id="填充和步幅"><a href="#填充和步幅" class="headerlink" title="填充和步幅"></a>填充和步幅</h3><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><p>在输入周围添加额外的行/列</p><h4 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h4><p>填充减小的输出大小和层数线性相关</p><p>步幅是指行/列的滑动步长</p><p>高度3，宽度2的步幅</p><p>步幅一般是2</p><p>填充和步幅都是卷积层的超参数</p><p>填充在输入周围添加额外的行/列，来控制输出形状的减少量，步幅是每次滑动核窗口时的步长，可以成倍减少输出形状，减少计算量。</p><blockquote><p>机器学习可以看作一个压缩的算法，永远会丢失信息的，计算机理解的信息压缩到人能理解的范围</p></blockquote><h3 id="多输入输出通道"><a href="#多输入输出通道" class="headerlink" title="多输入输出通道"></a>多输入输出通道</h3><h3 id="多输入通道"><a href="#多输入通道" class="headerlink" title="多输入通道"></a>多输入通道</h3><p>每个通道都有一个卷积核，结果是所有通道卷积结果的和</p><h3 id="多个输出通道"><a href="#多个输出通道" class="headerlink" title="多个输出通道"></a>多个输出通道</h3><p>每个输出通道可以识别特定的模式</p><p>输入通道核识别并组合输入中的模式</p><blockquote><p>输出的通道数时卷积层的超参数</p><p>每个输入通道有独立的二维卷积核，所有通道结果相加得到一个输出通道结果</p><p>每个输出通道有独立的三维卷积核</p></blockquote><p>通道之间是不共享参数，每个通道学习一个特定的模式</p><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><h3 id="背景-作用"><a href="#背景-作用" class="headerlink" title="背景&amp;作用"></a>背景&amp;作用</h3><blockquote><p>卷积层对位置信息太敏感</p></blockquote><p>需要一定程度的平移不变性，照明，物体位置，比例，外观等等因图像而异</p><h4 id="二维最大池化"><a href="#二维最大池化" class="headerlink" title="二维最大池化"></a>二维最大池化</h4><p>返回滑动窗口中的最大值</p><p>池化层和卷积层类似，都具有填充和步幅</p><p>没有可以学习的参数，没有kernel，k</p><p>最每个输入通道应用池化层以获得相应的输出通道，不会作融合</p><p>输出通道数=输入通道数</p><h4 id="平均池化层"><a href="#平均池化层" class="headerlink" title="平均池化层"></a>平均池化层</h4><p>最大池化层：每个窗口中间最强的模式信号</p><p>平均池化层：将最大池化层中的“最大”操作替换为“平均”</p><blockquote><p>缓解卷积层对位置的敏感性</p><p>同样有窗口大小，填充，步幅作为超参数，对每个通道作用直接输出</p></blockquote><p>池化层用的越来越少</p><h2 id="正向传播和反向传播"><a href="#正向传播和反向传播" class="headerlink" title="正向传播和反向传播"></a>正向传播和反向传播</h2><ul><li><strong>前向传播（Forward Propagation）</strong>前向传播就是从input，经过一层层的layer，不断计算每一层的z和a，最后得到输出y^ 的过程，计算出了y^，就可以根据它和真实值y的差别来计算损失（loss）。</li><li><strong>反向传播（Backward Propagation）</strong>反向传播就是根据损失函数L(y^,y)来反方向地计算每一层的z、a、w、b的偏导数（梯度），从而更新参数。</li><li>每经过一次前向传播和反向传播之后，参数就更新一次，然后用新的参数再次循环上面的过程。这就是神经网络训练的整个过程。</li></ul><blockquote><p>高宽减半的时候通道数可以翻倍，同样一个像素的表示的信息要增加，所以要增加通道数，   </p></blockquote><h3 id="卷积层可学习的参数的个数"><a href="#卷积层可学习的参数的个数" class="headerlink" title="卷积层可学习的参数的个数"></a>卷积层可学习的参数的个数</h3><p>输入通道数 * 输出通道数 * kernel（卷积核）的大小&lt;3 * 3&gt;</p><h2 id="Alexnet"><a href="#Alexnet" class="headerlink" title="Alexnet"></a>Alexnet</h2><p>更深更大的Lenet</p><p>主要改进：</p><ul><li>丢弃法</li><li>ReLU</li><li>MaxPooling</li></ul><h3 id="计算机视觉方法论的改变："><a href="#计算机视觉方法论的改变：" class="headerlink" title="计算机视觉方法论的改变："></a>计算机视觉方法论的改变：</h3><p>从人工特征提取到端到端的学习，从原始的信息到最后的分类，神经网络一路走过去</p><h2 id="NiN"><a href="#NiN" class="headerlink" title="NiN"></a>NiN</h2><blockquote><p>完全不用全连接层</p></blockquote><h3 id="NiN块"><a href="#NiN块" class="headerlink" title="NiN块"></a>NiN块</h3><p>一个卷积层后跟两个全连接层</p><ul><li>步幅1，无填充，输出形状跟卷积层输出一样，1 * 1的卷积层起到全连接层的作用</li></ul><p>无全连接层，交替使用NiN块和步幅为2的最大池化层（宽高减半）逐步减少高宽和增大通道数</p><p>最后使用全局平均池化层得到输出，其输入通道数类别数</p><blockquote><p>NiN块使用卷积层加两个1 * 1卷积层</p><p>后者对每个像素增加了非线性性</p><p>NiN使用全局平局池化层来替代VGG和AlexNet中的全连接层</p><p>不容易过拟合，更少的参数个数</p></blockquote><h3 id="全局池化层"><a href="#全局池化层" class="headerlink" title="全局池化层"></a>全局池化层</h3><p>能够把模型复杂度降低，提升模型的泛化性，让精度变得更好。</p><p>让收敛变慢</p><h2 id="GoogLeNet"><a href="#GoogLeNet" class="headerlink" title="GoogLeNet"></a>GoogLeNet</h2><p>5段，9个<code>inception</code>块</p><p><code>inception</code>不改变高宽，只改变通道数</p><p>MaxPool可以降低高宽</p><h2 id="批量归一化"><a href="#批量归一化" class="headerlink" title="批量归一化"></a>批量归一化</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>损失出现在最后，后面的层训练较快</li><li>数据在最底部<ul><li>底部的层训练较慢</li><li>底部曾一变化，所有都得跟着变</li><li>最后的那些曾需要重新学习多次</li><li>导致收敛变慢</li></ul></li></ul><h3 id="批量归一化层"><a href="#批量归一化层" class="headerlink" title="批量归一化层"></a>批量归一化层</h3><ul><li>可学习得参数为y和b</li><li>作用在<ul><li>全连接层和卷积层得输出上，激活函数前</li><li>全连接层和卷积层输入上</li></ul></li><li>对全连接层，作用在特征维</li><li>对卷积层，作用在通道维</li></ul><p>批量归一化固定小批量中得均值和方差，然后学习出适合得偏移和缩放</p><p>可以加速收敛速度，但一般不改变模型精度</p><h2 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h2><p>ResNet沿用了VGG完整的3×33×3卷积层设计。 残差块里首先有2个有相同输出通道数的3×33×3卷积层。 每个卷积层后接一个批量规范化层和ReLU激活函数。 然后我们通过跨层数据通路，跳过这2个卷积运算，将输入直接加在最后的ReLU激活函数前。 这样的设计要求2个卷积层的输出与输入形状一样，从而使它们可以相加。 如果想改变通道数，就需要引入一个额外的1×11×1卷积层来将输入变换成需要的形状后再做相加运算。</p><p><code>residual</code>残留的；剩余的</p><ul><li>残差块使得很深得网络更加容易训练</li><li>甚至可以训练一千层的网络</li><li>残差网络对随后的深层神经网络设计产生了深远影响，无论是卷积类网络还是全连接网络</li></ul><h3 id="残差块结构："><a href="#残差块结构：" class="headerlink" title="残差块结构："></a>残差块结构：</h3><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/resnet_block.png" alt="resnet_block"></p><p>​         </p><h2 id="单机多卡并行"><a href="#单机多卡并行" class="headerlink" title="单机多卡并行"></a>单机多卡并行</h2><ul><li>一台机器可以安装多个GPU</li><li>在训练和预测的时候，我们将一个小批量计算切分到多个GPU上来达到加速目的</li><li>常用的切分方案有<ul><li>数据并行</li><li>模型并行</li><li>通道并行（数据+模型并行）</li></ul></li></ul><h3 id="数据并行"><a href="#数据并行" class="headerlink" title="数据并行"></a>数据并行</h3><p>将小批量分成n块，每个GPU拿到完整参数计算一块数据的梯度</p><p>通常性能更好</p><h3 id="模型并行"><a href="#模型并行" class="headerlink" title="模型并行"></a>模型并行</h3><p>将模型分成n块，每个GPU拿到一块模型计算它的前向和后向结果，通常用于模型大到放不下</p><p>当一个模型能用单卡计算时，通常使用数据并行拓展到多卡上，模型并行则用在超大模型上</p><h2 id="数据增广"><a href="#数据增广" class="headerlink" title="数据增广"></a>数据增广</h2><p>数据增广通过变形数据来获取多样性从而使得模型泛化性能更好，常见图片增广包括反转，切割，变色</p><p>理论上，原始数据的多样性足够好，就用不着做增广</p><p>增广没有改变分布，可能是增大了方差&gt;</p><h2 id="微调（fine-tuning）"><a href="#微调（fine-tuning）" class="headerlink" title="微调（fine-tuning）"></a>微调（fine-tuning）</h2><blockquote><p>迁移学习的常规技巧</p></blockquote><h3 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h3><ul><li>一个神经网络一般可以分成两块<ul><li>特征抽取将原始像素变成容易线性分割的特征</li><li>线性分类器来做分类</li></ul></li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>微调包括以下四个步骤</p><ol><li>在源数据集（例如ImageNet数据集）上预训练神经网络模型，即<em>源模型</em>。</li><li>创建一个新的神经网络模型，即<em>目标模型</em>。这将复制源模型上的所有模型设计及其参数（输出层除外）。我们假定这些模型参数包含从源数据集中学到的知识，这些知识也将适用于目标数据集。我们还假设源模型的输出层与源数据集的标签密切相关；因此不在目标模型中使用该层。</li><li>向目标模型添加输出层，其输出数是目标数据集中的类别数。然后随机初始化该层的模型参数。</li><li>在目标数据集（如椅子数据集）上训练目标模型。输出层将从头开始进行训练，而所有其他层的参数将根据源模型的参数进行微调。</li></ol><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><ul><li>是一个目标数据集上的正常训练任务</li><li>使用更强的正则化<ul><li>使用更小的学习率</li><li>使用更少的数据迭代</li></ul></li><li>源数据集远复杂于目标数据，通常微调效果更好</li></ul><h3 id="重用分类器权重"><a href="#重用分类器权重" class="headerlink" title="重用分类器权重"></a>重用分类器权重</h3><ul><li>源数据集可能也有目标数据中的部分标号</li><li>可以使用预训练好模型分类器中对应标号对应的向量来做初始化</li></ul><h3 id="固定一些层"><a href="#固定一些层" class="headerlink" title="固定一些层"></a>固定一些层</h3><ul><li><p>神经网络通常学习有层次的特征表示</p><ul><li>低层次的特征更加通用</li><li>高层次的特征则更跟数据集相关</li></ul></li><li><p>可以固定底部的一些层的参数，不参与更新</p><blockquote><p>模型复杂度变低</p></blockquote></li><li><p>更强的正则</p></li></ul><blockquote><p>微调通过使用在大数据上得到的预训练好的模型来初始化模型权重来完成提升精度</p><p>预训练模型质量很重要</p><p>微调通常速度更快，精度更高</p></blockquote><h2 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h2><blockquote><p>物体检测识别图片里的多个物体的类别和位置</p><p>位置通常用边缘框表示</p></blockquote><h3 id="边缘框"><a href="#边缘框" class="headerlink" title="边缘框"></a>边缘框</h3><p>一个边缘框可以通过4个数字定义</p><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/edge_dot.png"></p><blockquote><p>标注的成本很高</p></blockquote><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ul><li>每行表示一个物体<ul><li>图片文件名，物体类别，边缘框</li></ul></li><li>COCO（cocodataset.org）<ul><li>80物体，330k图片，1.5M物体</li></ul></li></ul><h2 id="锚框"><a href="#锚框" class="headerlink" title="锚框"></a>锚框</h2><p>一类目标检测算法是基于锚框</p><ul><li>提出多个被称为锚框的区域（边缘框）</li><li>预测每个锚框里是否含有关注的物体</li><li>如果是，预测从这个锚框到真实边缘框的偏移</li></ul><h3 id="IoU"><a href="#IoU" class="headerlink" title="IoU"></a>IoU</h3><blockquote><p>交并比</p></blockquote><h3 id="赋予锚框标号"><a href="#赋予锚框标号" class="headerlink" title="赋予锚框标号"></a>赋予锚框标号</h3><ul><li>每个锚框是一个训练样本</li><li>将每个锚框， 要么标注成背景，要么关联上一个真实边缘框</li><li>我们可能会生成大量的锚框，这个导致大量的负类样本</li></ul><h3 id="使用非极大值抑制（NMS）输出"><a href="#使用非极大值抑制（NMS）输出" class="headerlink" title="使用非极大值抑制（NMS）输出"></a>使用非极大值抑制（NMS）输出</h3><ul><li>每个锚框预测一个边缘框</li><li>NMS可以合并相似的预测<ul><li>选中非背景类的最大预测值</li><li>去掉所有其他和它IoU值大于西塔的预测</li><li>重复上述过程直到所有预测要么被选中，要么被丢掉</li></ul></li></ul><blockquote><p>预测值：对于那个类的softmax置信值</p></blockquote><p>在预测时，使用NMS来去掉冗余的预测</p><h2 id="编码器-解码器"><a href="#编码器-解码器" class="headerlink" title="编码器&amp;解码器"></a>编码器&amp;解码器</h2><h3 id="重新考察CNN"><a href="#重新考察CNN" class="headerlink" title="重新考察CNN"></a>重新考察CNN</h3><ul><li>编码器：将输入编程成中间表达形式（特征）</li><li>解码器：将中间表示解码成输出</li></ul><h3 id="重新考察RNN"><a href="#重新考察RNN" class="headerlink" title="重新考察RNN"></a>重新考察RNN</h3><ul><li>编码器：将文本表示成向量</li><li>解码器：：向量表示成输出</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>一个模型被分为两块</p><p>编码器处理输出</p><p>解码器生成输出</p><p>其中Decoder也可以拿到输入</p><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/encoderDecoder.png"></p><h2 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h2><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><h3 id="d2l图片不显示"><a href="#d2l图片不显示" class="headerlink" title="d2l图片不显示"></a>d2l图片不显示</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示图像的代码末尾加上</span></span><br><span class="line">d2l.plt.show();</span><br></pre></td></tr></tbody></table></figure><h3 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网络参量进行反馈时，梯度是累计计算而不是被替换，但在处理每一个batch时并不需要与其他batch的梯度混合起来计算，因此对每个batch调用一遍zero_grad将参数梯度置0</span></span><br><span class="line">optimizer.zero_grad()</span><br><span class="line"><span class="comment"># 将输入数据，标签加载到内存</span></span><br><span class="line">X, y = X.to(device), y.to(device)</span><br><span class="line"><span class="comment"># 前向传播计算预测值</span></span><br><span class="line">y_hat = net(X)</span><br><span class="line"><span class="comment"># 计算当前损失</span></span><br><span class="line">l = loss(y_hat, y)</span><br><span class="line"><span class="comment"># 反向传播计算精度</span></span><br><span class="line">l.backward()</span><br><span class="line"><span class="comment"># 更新所有参数</span></span><br><span class="line">optimizer.step()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">d2l（李沐）课程精简笔记</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="pytorch" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/pytorch/"/>
    
    <category term="python" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/pytorch/python/"/>
    
    <category term="学习" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/pytorch/python/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="笔记" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/pytorch/python/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="pytorch" scheme="https://dra-tammer.github.io/tags/pytorch/"/>
    
    <category term="python" scheme="https://dra-tammer.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pytorch_lea</title>
    <link href="https://dra-tammer.github.io/posts/97340e65.html"/>
    <id>https://dra-tammer.github.io/posts/97340e65.html</id>
    <published>2024-10-17T08:19:14.000Z</published>
    <updated>2024-10-17T08:19:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pytoch"><a href="#pytoch" class="headerlink" title="pytoch"></a>pytoch</h1><h2 id="当下未成功解决的问题"><a href="#当下未成功解决的问题" class="headerlink" title="当下未成功解决的问题"></a>当下未成功解决的问题</h2><h3 id="ssh-clone"><a href="#ssh-clone" class="headerlink" title="ssh clone"></a>ssh clone</h3><blockquote><p>太看脸了，有时候会成功，有时候会失败，跟配置代理关联不大，仅成功过两次</p></blockquote><p>git clone无法使用ssh，但是https正常clone，代码push也是正常提交，ssh连接也建立成功</p><h3 id="tensorboard"><a href="#tensorboard" class="headerlink" title="tensorboard"></a>tensorboard</h3><p>下载tensorboard之后会一直报错，说是找不到相应的库，按照需要的依赖一个一个安装之后还是报错，程序能够运行，能够生成logs文件，但是tensorboard显示图像出现问题</p><h2 id="有序地管理环境"><a href="#有序地管理环境" class="headerlink" title="有序地管理环境"></a>有序地管理环境</h2><blockquote><p>conda可以创建一个盒子，里面的环境配置独立</p></blockquote><p>创建环境</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pytorch python=<span class="number">3.8</span></span><br></pre></td></tr></tbody></table></figure><p>n是name的意思，后面输入环境的名称</p><p>激活环境</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate pytorch</span><br></pre></td></tr></tbody></table></figure><p>查看工具包</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="built_in">list</span> | conda <span class="built_in">list</span></span><br></pre></td></tr></tbody></table></figure><p>删除环境及其依赖</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env remove -n <span class="string">"envname"</span></span><br></pre></td></tr></tbody></table></figure><p>清理环境，释放磁盘空间</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda clean --all</span><br></pre></td></tr></tbody></table></figure><p>conda clean –all操作不会直接影响已经创建的虚拟环境。该命令主要用于清理conda缓存目录中的下载的包文件、索引文件和不必要的缓存文件，以释放磁盘空间。</p><p>已经创建的虚拟环境包含在磁盘上的特定目录中，而conda clean –all操作不会直接删除这些虚拟环境目录或其中的包。这意味着你的虚拟环境和其中已安装的包将保持不变。</p><p>然而，清理操作可能会影响你的使用体验。如果你清理了缓存文件和索引文件，那么在以后的包安装和更新过程中，conda可能会重新下载这些文件，可能会稍微增加一些下载时间。</p><p>总之，conda clean –all操作主要针对conda缓存目录中的文件，不会直接影响已经创建的虚拟环境和其中的包。如果你只关注已经创建的虚拟环境，可以放心使用该命令来释放磁盘空间。</p><h2 id="pip换源"><a href="#pip换源" class="headerlink" title="pip换源"></a>pip换源</h2><p>Windows：</p><p>文件管理器文件路径地址栏敲：<code>%APPDATA%</code> 回车，快速进入 <code>C:\Users\电脑用户\AppData\Roaming</code> 文件夹中 2、新建 pip 文件夹并在文件夹中新建 <code>pip.ini</code> 配置文件 3、我们需要在<code>pip.ini</code> 配置文件内容，我们可以选择使用记事本打开，输入以下内容，并按下ctrl+s保存，在这里我们使用的是豆瓣源为例子。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">use-mirrors =true</span><br><span class="line">trusted-host = https://pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></tbody></table></figure><p>查看 镜像地址：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 config list   </span><br><span class="line">global.index-url='https://pypi.tuna.tsinghua.edu.cn/simple'</span><br><span class="line">install.trusted-host='https://pypi.tuna.tsinghua.edu.cn'</span><br></pre></td></tr></tbody></table></figure><h2 id="conda换源"><a href="#conda换源" class="headerlink" title="conda换源"></a>conda换源</h2><p>Windows系统：</p><p>TUNA 提供了 Anaconda 仓库与第三方源的镜像，各系统都可以通过修改用户目录下的 <code>.condarc</code> 文件。Windows 用户无法直接创建名为 <code>.condarc</code> 的文件，可先执行<code>conda config --set show_channel_urls yes</code>生成该文件之后再修改。</p><p>完成这一步后，我们需要修改<code>C:\Users\User_name\.condarc</code>这个文件，打开后将文件里原始内容删除，将下面的内容复制进去并保存。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br></pre></td></tr></tbody></table></figure><p>这一步完成后，我们需要打开<code>Anaconda Prompt</code> 运行 <code>conda clean -i</code> 清除索引缓存，保证用的是镜像站提供的索引。</p><h2 id="环境内安装pytoch"><a href="#环境内安装pytoch" class="headerlink" title="环境内安装pytoch"></a>环境内安装pytoch</h2><blockquote><p><strong>NOTE:</strong> Latest PyTorch requires Python 3.8 or later.</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio pytorch-cuda=<span class="number">12.4</span> -c pytorch -c nvidia</span><br></pre></td></tr></tbody></table></figure><h2 id="查看显卡支持的cuda版本"><a href="#查看显卡支持的cuda版本" class="headerlink" title="查看显卡支持的cuda版本"></a>查看显卡支持的cuda版本</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></tbody></table></figure><h2 id="jupyter"><a href="#jupyter" class="headerlink" title="jupyter"></a>jupyter</h2><p>安装的时候安装在了base环境下</p><p>在pytorch环境中安装jupyter</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install jupyter notebook</span><br></pre></td></tr></tbody></table></figure><p>命令行下启动jupyter</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></tbody></table></figure><p>打开D盘下的工作目录，先切换，再打开jupyter</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pytorch) C:\Users\tammer&gt;D:</span><br></pre></td></tr></tbody></table></figure><h2 id="三种编写代码的环境"><a href="#三种编写代码的环境" class="headerlink" title="三种编写代码的环境"></a>三种编写代码的环境</h2><h3 id="py文件"><a href="#py文件" class="headerlink" title="py文件"></a>py文件</h3><p>代码是以块为一个整体的话，py中代码出现问题就要从头开始执行</p><blockquote><p>通用，传播方便，适用于大型项目</p><p>需要从头运行</p></blockquote><h3 id="jupyter-1"><a href="#jupyter-1" class="headerlink" title="jupyter"></a>jupyter</h3><p>人为地分块，也就是以任意块进行运行的</p><blockquote><p>利于代码阅读及修改</p><p>环境需要配置</p></blockquote><h3 id="python-console"><a href="#python-console" class="headerlink" title="python console"></a>python console</h3><p>以每一行为块或者任意块执行的，一行出现问题，解决之后继续执行</p><blockquote><p>显示每个变量属性</p><p>不利于代码阅读及修改</p></blockquote><h2 id="两大法宝函数"><a href="#两大法宝函数" class="headerlink" title="两大法宝函数"></a>两大法宝函数</h2><h3 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h3><p>工具箱以及工具箱中的分隔区有什么东西</p><p>也就是看方法里面有什么可以调用的函数，或者理解说查看这个对象里面的内容，查看这个分隔区中还有没有其他的分隔区</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.cuda.is_available()</span><br><span class="line">Out[<span class="number">4</span>]: <span class="literal">True</span></span><br><span class="line"><span class="built_in">dir</span>(torch)</span><br><span class="line">Out[<span class="number">5</span>]: </span><br><span class="line">[<span class="string">'AVG'</span>,</span><br><span class="line"> <span class="string">'AggregationType'</span>,</span><br><span class="line"> <span class="string">'AliasDb'</span>,</span><br><span class="line"> <span class="string">'Any'</span>,......]</span><br><span class="line"><span class="built_in">dir</span>(torch.cuda.is_available)</span><br><span class="line">Out[<span class="number">6</span>]: </span><br><span class="line">[<span class="string">'__annotations__'</span>,</span><br><span class="line">......</span><br><span class="line"> <span class="string">'__subclasshook__'</span>]</span><br><span class="line"> <span class="comment"># 下划线就是不可修改的说明这个is_available不再是一个分隔区，而是一个函数，即可使用help查看使用方法</span></span><br></pre></td></tr></tbody></table></figure><h3 id="help"><a href="#help" class="headerlink" title="help()"></a>help()</h3><p>知道每个工具是如何使用的，工具的使用方法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span>(torch.cuda.is_available)</span><br><span class="line">Help on function is_available <span class="keyword">in</span> module torch.cuda:</span><br><span class="line">is_available() -&gt; <span class="built_in">bool</span></span><br><span class="line">    Return a <span class="built_in">bool</span> indicating <span class="keyword">if</span> CUDA <span class="keyword">is</span> currently available.</span><br><span class="line"><span class="comment"># 官方解释的函数用法</span></span><br><span class="line">或者</span><br><span class="line">Dataset??</span><br></pre></td></tr></tbody></table></figure><h2 id="pytorch加载数据"><a href="#pytorch加载数据" class="headerlink" title="pytorch加载数据"></a>pytorch加载数据</h2><p>PyTorch数据读入是通过Dataset+DataLoader的方式完成的，Dataset定义好数据的格式和数据变换形式，DataLoader用iterative的方式不断读入批次数据。</p><h3 id="Dateset"><a href="#Dateset" class="headerlink" title="Dateset"></a>Dateset</h3><p>提供一种方式去获取数据及其label，还能进行编号</p><ul><li>如何获取每一个数据及其label</li><li>告诉我们总共有多少个数据</li></ul><p>可以定义自己的Dataset类来实现灵活的数据读取，定义的类需要继承PyTorch自身的Dataset类。主要包含三个函数：</p><ul><li><code>__init__</code>: 用于向类中传入外部参数，同时定义样本集</li><li><code>__getitem__</code>: 用于逐个读取样本集合中的元素，可以进行一定的变换，并将返回训练/验证所需的数据</li><li><code>__len__</code>: 用于返回数据集的样本数</li></ul><h3 id="Dateloader"><a href="#Dateloader" class="headerlink" title="Dateloader"></a>Dateloader</h3><p>对数据进行打包，为后面的网络提供不同的数据形式</p><p>构建好Dataset后，就可以使用DataLoader来按批次读入数据了，实现代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_data, batch_size=batch_size, num_workers=<span class="number">4</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line">val_loader = torch.utils.data.DataLoader(val_data, batch_size=batch_size, num_workers=<span class="number">4</span>, shuffle=<span class="literal">False</span>)</span><br></pre></td></tr></tbody></table></figure><p>其中:</p><ul><li>batch_size：样本是按“批”读入的，batch_size就是每次读入的样本数</li><li>num_workers：有多少个进程用于读取数据，Windows下该参数设置为0，Linux下常见的为4或者8，根据自己的电脑配置来设置</li><li>shuffle：是否将读入的数据打乱，一般在训练集中设置为True，验证集中设置为False</li><li>drop_last：对于样本最后一部分没有达到批次数的样本，使其不再参与训练</li></ul><p>这里可以看一下我们的加载的数据。PyTorch中的DataLoader的读取可以使用next和iter来完成</p><h2 id="torchvision"><a href="#torchvision" class="headerlink" title="torchvision"></a>torchvision</h2><p>target有时候就是label的编号</p><blockquote><p>The <a href="https://pytorch.org/vision/stable/index.html#module-torchvision"><code>torchvision</code></a> package consists of popular datasets, model architectures, and common image transformations for computer vision.</p></blockquote><h2 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a>opencv</h2><p>OpenCV可以用于处理数字图像和视频数据，其功能包括图像和视频的读取、写入、显示、变换、滤波、特征提取、目标检测、人脸识别、物体跟踪、相机标定、三维重建、机器学习等。</p><p>当今，计算机视觉在各种应用领域中都扮演着重要的角色，如自动驾驶、智能家居、医学影像、机器人视觉等，而OpenCV则作为计算机视觉领域的重要工具之一，为这些应用领域提供了丰富的功能和算法支持。</p><p>OpenCV最初由Intel开发，现在已经成为了一个开源项目，其源代码可以免费获取和使用。OpenCV提供了许多计算机视觉中常用的算法和工具，例如：</p><ul><li><p>读取和保存图像和视频数据</p></li><li><p>图像和视频的显示、缩放、剪切和旋转等操作</p></li><li><p>直方图均衡化、图像滤波和形态学操作等图像处理技术</p></li><li><p>特征提取和描述符匹配算法，如SIFT和SURF等</p></li><li><p>目标检测和跟踪算法，如Haar Cascade和MeanShift等</p></li><li><p>人脸检测和识别算法，如LBPH和FisherFace等</p></li><li><p>相机标定和三维重建算法，如SfM和PnP等</p></li><li><p>机器学习算法，如SVM、KNN和随机森林等</p></li></ul><p>除了以上的功能，OpenCV还有一个重要的特点就是跨平台性，可以在Windows、Linux、macOS等操作系统上运行，并且支持多种编程语言，如C++、Python和Java等。</p><p>总之，OpenCV作为一个强大的计算机视觉库，在实现计算机视觉应用的过程中，可以节省开发者大量的时间和精力，提高开发效率和准确性，因此受到了广大开发者的欢迎和使用。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></tbody></table></figure><h2 id="windows中的转译"><a href="#windows中的转译" class="headerlink" title="windows中的转译"></a>windows中的转译</h2><blockquote><p>hymenoptera_data/train/ants/0013035.jpg</p></blockquote><blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_path = "hymenoptera_data\\trainants\\0013035.jpg"</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="tensorboard的使用-未成功"><a href="#tensorboard的使用-未成功" class="headerlink" title="tensorboard的使用(未成功)"></a>tensorboard的使用(未成功)</h2><p>它提供机器学习实验所需的可视化功能和工具</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br></pre></td></tr></tbody></table></figure><p>查看log</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=logs --port=<span class="number">6007</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade tensorboard</span><br><span class="line"><span class="comment"># 有时候版本不兼容，卸载掉重新安装即可</span></span><br><span class="line">pip uninstall protobuf</span><br><span class="line">pip install protobufz</span><br></pre></td></tr></tbody></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote><p>‘SSLError(SSLZeroReturnError(6, ‘TLS/SSL connection has been closed (EOF)</p></blockquote><p>关闭代理</p><p>更换成了阿里源</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line">index-url=https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></tbody></table></figure><h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><p>NumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</p><p>NumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含：</p><ul><li>一个强大的N维数组对象 ndarray</li><li>广播功能函数</li><li>整合 C/C++/Fortran 代码的工具</li><li>线性代数、傅里叶变换、随机数生成等功能</li></ul><h2 id="tensor"><a href="#tensor" class="headerlink" title="tensor"></a>tensor</h2><blockquote><p>张量</p></blockquote><p>从本章开始，我们将开始介绍PyTorch基础知识，本章我们将介绍张量，以帮助大家建立起对数据的描述，随后我们再介绍张量的运算，最后再讲PyTorch中所有神经网络的核心包 <code>autograd </code>，也就是自动微分，了解完这些内容我们就可以较好地理解PyTorch代码了。在深度学习中，我们通常将数据以张量的形式进行表示，比如我们用三维张量表示一个RGB图像，四维张量表示视频。</p><p>一个图像可以用三个字段表示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(width, height, channel) = 3D</span><br></pre></td></tr></tbody></table></figure><p>但是，在机器学习工作中，我们经常要处理不止一张图片或一篇文档——我们要处理一个集合。我们可能有10,000张郁金香的图片，这意味着，我们将用到4D张量：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(batch_size, width, height, channel) = 4D</span><br></pre></td></tr></tbody></table></figure><p><code>Tensor</code> 提供GPU计算和自动求梯度等更多功能，这些使 <code>Tensor</code> 这一数据类型更加适合深度学习。</p><h2 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h2><blockquote><p>现在的主流方式是<strong>数据并行</strong>的方式(Data parallelism)</p></blockquote><p>第三种方式有点不一样，它的逻辑是，我不再拆分模型，我训练的时候模型都是一整个模型。但是我将输入的数据拆分。所谓的拆分数据就是，同一个模型在不同GPU中训练一部分数据，然后再分别计算一部分数据之后，只需要将输出的数据做一个汇总，然后再反传。</p><h2 id="使用CUDA加速训练"><a href="#使用CUDA加速训练" class="headerlink" title="使用CUDA加速训练"></a>使用CUDA加速训练</h2><p>单卡训练</p><p>在PyTorch框架下，CUDA的使用变得非常简单，我们只需要显式的将数据和模型通过<code>.cuda()</code>方法转移到GPU上就可加速我们的训练。如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">model = Net()</span><br><span class="line">model.cuda() # 模型显示转移到CUDA上</span><br><span class="line"></span><br><span class="line">for image,label in dataloader:</span><br><span class="line">    # 图像和标签显示转移到CUDA上</span><br><span class="line">    image = image.cuda() </span><br><span class="line">    label = label.cuda()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">学习pytorch</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="pytorch" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/pytorch/"/>
    
    <category term="python" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/pytorch/python/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="pytorch" scheme="https://dra-tammer.github.io/tags/pytorch/"/>
    
    <category term="python" scheme="https://dra-tammer.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>machine-learning</title>
    <link href="https://dra-tammer.github.io/posts/da37838d.html"/>
    <id>https://dra-tammer.github.io/posts/da37838d.html</id>
    <published>2024-10-17T08:16:30.000Z</published>
    <updated>2024-10-17T08:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><blockquote><p>计算机无需明确编程即可学习的研究领域</p></blockquote><h2 id="人工智能的术语"><a href="#人工智能的术语" class="headerlink" title="人工智能的术语"></a>人工智能的术语</h2><ul><li>训练集(training set)：用于训练模型的数据集</li><li>输入变量/输入特征(input)：x</li><li>目标变量/输出变量：y</li><li>预测的目标变量：y-hat</li><li>训练数据的总数：m</li><li>单个训练示例：(x, y)</li><li>第几个训练数据：(x<sup>(i)</sup>, y<sup>(i)</sup>)</li></ul><h2 id="监督学习-supervised-learning"><a href="#监督学习-supervised-learning" class="headerlink" title="监督学习(supervised learning)"></a>监督学习(supervised learning)</h2><blockquote><p>当下创造经济价值最多的机器学习形式是监督学习</p></blockquote><p>在监督学习中，数据同时带有输入x和输入标签y</p><p>学习预测输入、输出或者X到Y的映射</p><h3 id="回归算法-regression"><a href="#回归算法-regression" class="headerlink" title="回归算法(regression)"></a>回归算法(regression)</h3><p>学习预测数字，无限多的可能数</p><h3 id="分类算法-classification"><a href="#分类算法-classification" class="headerlink" title="分类算法(classification)"></a>分类算法(classification)</h3><p>输出的可能性是有限的，一组有限的输出类别，通过拟合算法找到一条分界线</p><h2 id="无监督学习-unsupervised-learning"><a href="#无监督学习-unsupervised-learning" class="headerlink" title="无监督学习(unsupervised learning)"></a>无监督学习(unsupervised learning)</h2><blockquote><p>最广泛使用的机器学习形式是无监督学习</p></blockquote><p>不试图监督算法为了给每个输入提供一些正确的答案，相反，我们要求我们的空间自己弄清楚什么是有趣的，或者这个数据中可能有什么模式或者结构。人们没有提前为算法给出示例的正确答案。</p><p>在无监督学习中，数据仅带有输入x而没有输出标签y，而且算法必须发现数据中的某种结构或者某种模式或者某些有趣的东西</p><h3 id="聚类算法-clustering"><a href="#聚类算法-clustering" class="headerlink" title="聚类算法(clustering)"></a>聚类算法(clustering)</h3><p>就是一种无监督学习，将相似的数据点分组</p><h3 id="异常检测-anomaly-detection"><a href="#异常检测-anomaly-detection" class="headerlink" title="异常检测(anomaly detection)"></a>异常检测(anomaly detection)</h3><p>检测异常事件</p><h3 id="降维-dimensionality-reduction"><a href="#降维-dimensionality-reduction" class="headerlink" title="降维(dimensionality reduction)"></a>降维(dimensionality reduction)</h3><p>将一个大的数据集，压缩到一个小得多的数据集，而丢失尽可能少的信息</p><h2 id="jupyter-notebook"><a href="#jupyter-notebook" class="headerlink" title="jupyter notebook"></a>jupyter notebook</h2><p>实验环境</p><h2 id="线性回归模型-linear-regression"><a href="#线性回归模型-linear-regression" class="headerlink" title="线性回归模型(linear regression)"></a>线性回归模型(linear regression)</h2><p>将一条直线拟合到数据中，预测数字的监督学习，只有一个输入特征或者说变量</p><p>具有一个输入变量的线性模型，另一个名称：单变量线性回归</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><code>feature --&gt; model --&gt; prediction</code></p><p><code>x --&gt; f --&gt; y-hat (estimated y)</code></p><h3 id="f-model"><a href="#f-model" class="headerlink" title="f/model"></a>f/model</h3><p>f<sub>w, b</sub> = wx + b</p><p><code>f(x) = wx + b</code></p><h2 id="代价函数-cost-function"><a href="#代价函数-cost-function" class="headerlink" title="代价函数(cost function)"></a>代价函数(cost function)</h2><blockquote><p>衡量拟合程度</p></blockquote><p>w, b是模型的参数，在机器学习w, b是咱可以调整的变量，以改进模型，或者称为系数或者权重</p><p>为了构建一个不会随着训练集大小变大而自动变大的成本函数，我们将计算平均平方误差而不是总平方误差，按照惯例，人们使用的成本函数实际上是除以2乘以m，额外除以2只是为了让我们后面的一些计算看起来更整洁，但是无论是否包含此除以2，成本函数仍然有效。</p><p>线性回归问题最常用的代价函数就是<code>平方误差成本函数</code>，训练的目的是使成本函数尽可能小，找到j最小的时候的w, b的值</p><p>$$<br>J(w,b)=\frac{1}{2m}\sum_{i = 1}^m(f_{w,b}x^{(i)}-y^{(i)})^2<br>$$</p><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>梯度下降算法是一种可以用于求任何代价函数的最小值的算法，不仅仅是线性回归的代价函数，在w，b—上最小化代价函数</p><p>从对参数的猜测开始，不断变化w，b的值去降低代价函数的值，直到我们得到最小值或者接近最小值，有时候代价函数的最小值可能存在不止一个，神经网络的代价函数的图就是上下起伏的，有多个谷底</p><p>在山峰上的时候如果想要去到谷底，环顾一周，看哪能最速下坡，一步一步重复，就到谷底。</p><p>可以通过选择开始的w，b值，<code>设置不同的起点，会进入一个完全不同的山谷，进入局部最小值</code>。</p><h3 id="实现梯度下降算法"><a href="#实现梯度下降算法" class="headerlink" title="实现梯度下降算法"></a>实现梯度下降算法</h3><p>$$<br>w=w-\alpha\frac{\partial}{\partial w}J(w,b)<br>\<br>b=b-\alpha\frac{\partial}{\partial b}J(w,b)<br>$$</p><p>在程序中<code>=</code>是赋值的意思，而不是数学符号中的真值断言，如果像完成真值断言的功能使用<code>==</code>，断言两个值是否相等</p><h4 id="Alpha"><a href="#Alpha" class="headerlink" title="Alpha"></a>Alpha</h4><p>学习率</p><p>0~1之间的一个小的正数，控制下坡的步幅，控制更新时的步长</p><h4 id="j的导数项"><a href="#j的导数项" class="headerlink" title="j的导数项"></a>j的导数项</h4><p>朝哪个方向迈出脚步</p><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>设定一个开始值，不断执行这个更新步骤，直到算法收敛，也就是说走到谷底，或者说十分接近谷底，不再随着采取的每一个额外步骤而发生很大变化</p><h3 id="正确同时更新"><a href="#正确同时更新" class="headerlink" title="正确同时更新"></a>正确同时更新</h3><p>$$<br>tmp_w=w-\alpha\frac{\partial}{\partial w}J(w,b)\<br>tmp_b=b-\alpha\frac{\partial}{\partial b}J(w,b)\<br>w=tmp_w<br>b=tmp_b<br>$$</p><h3 id="学习率的选择"><a href="#学习率的选择" class="headerlink" title="学习率的选择"></a>学习率的选择</h3><blockquote><p>影响效率</p></blockquote><p>学习率太小，每次迈出的步子，收敛的速度会很慢，需要很多步骤</p><p>学习率太大，每次迈出的步子太大，有可能会错i过适合收敛的位置，最后无法收敛甚至发散，离最小值越来远<br>$$<br>w=w-\alpha\frac{1}{m}\sum_{i = 1}^m(f_{w,b}x^{(i)}-y^{(i)})x^{(i)}\<br>b=b-\alpha\frac{1}{m}\sum_{i = 1}^m(f_{w,b}x^{(i)}-y^{(i)})<br>$$<br>线性回归只有一个最小值，因为他是一个凸函数</p><p>这种梯度下降叫做批量梯度下降(bashed grading descent)，在梯度下降的每一步中我们都在查看所有的训练示例，而不仅仅是训练数据的一个子集，每次计算的时候都看了整个训练集</p><p>也有使用子集进行计算，我们选择批量梯度下降算法进行线性回归</p><h2 id="多元线性回归-multiple-linear-regression"><a href="#多元线性回归-multiple-linear-regression" class="headerlink" title="多元线性回归(multiple linear regression)"></a>多元线性回归(multiple linear regression)</h2><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/image-20241018085410084.png"></p><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/Snipaste_2024-10-18_08-58-43.png"></p><h2 id="矢量化"><a href="#矢量化" class="headerlink" title="矢量化"></a>矢量化</h2><p>使用numpy，数值线性代数库</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">w = np.array([<span class="number">1.0</span>, <span class="number">2.5</span>, -<span class="number">3.4</span>])</span><br><span class="line">b = <span class="number">4</span></span><br><span class="line">x = np.array([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>])</span><br><span class="line"><span class="comment"># 提高效率，代码更短，更快，在计算机硬件中通过矢量化实现并行</span></span><br><span class="line">f = np.dot(w, x) + b</span><br><span class="line">w = w - <span class="number">0.1</span> * d</span><br><span class="line"><span class="comment"># 相较于</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">16</span>):</span><br><span class="line">    w[j] = w[j] - <span class="number">0.1</span> * d[j]</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>使用下标访问不同的特征值</p><h2 id="多元线性回归的梯度下降法"><a href="#多元线性回归的梯度下降法" class="headerlink" title="多元线性回归的梯度下降法"></a>多元线性回归的梯度下降法</h2><p><img src="https://raw.githubusercontent.com/Dra-Tammer/blog_pic/main/post_img/Snipaste_2024-10-18_09-34-55.png"></p><h2 id="正规方程法-normal-equation"><a href="#正规方程法-normal-equation" class="headerlink" title="正规方程法(normal equation)"></a>正规方程法(normal equation)</h2><p>只适用于线性回归方程</p><p>不需要迭代就能算出w, b，无法泛化，速度慢</p><p>梯度下降算法更好</p><h2 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>特征的可能值很大时，权重应该更小</p><p>有不同的特征，他们的取值范围非常不同时，可能会导致梯度下降运行缓慢，应该重新缩放不同的特征，使它们都具有可比较的取值范围。</p><p>相当于特征值的归一化</p><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>z-score </p><h3 id="and"><a href="#and" class="headerlink" title="and"></a>and</h3><p>根据经验，在执行特征缩放时，希望使特征的范围从负一左右到每个特征x正一左右</p><h2 id="判断梯度下降是否生效"><a href="#判断梯度下降是否生效" class="headerlink" title="判断梯度下降是否生效"></a>判断梯度下降是否生效</h2><p>代价函数-迭代次数图像，正常情况下的图像应该是随着迭代次数的增多，代价函数逐渐下降</p><p>如何J在一次迭代后增加，这意味着学习率选择不当，通常意味着学习率太大或者代码中存在错误</p><p>正确实施梯度下降的一个调试技巧是，如果学习率足够小，成本函数应该在每次迭代中减少</p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>通过转换或者组合问题的原始特征来是学习算法更容易做出准确的预测</p><h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2>]]></content>
    
    
    <summary type="html">学习machine-learning</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="机器学习" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="lea" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/lea/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="人工智能" scheme="https://dra-tammer.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="机器学习" scheme="https://dra-tammer.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="lea" scheme="https://dra-tammer.github.io/tags/lea/"/>
    
  </entry>
  
  <entry>
    <title>云边有个小卖部</title>
    <link href="https://dra-tammer.github.io/posts/4c32c6bc.html"/>
    <id>https://dra-tammer.github.io/posts/4c32c6bc.html</id>
    <published>2024-10-10T12:40:16.000Z</published>
    <updated>2024-10-10T12:40:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>start from 2024-09-30</code></p><p><code>end on 2024-10-06</code></p><p>先是看的电影，之后去找的原著。就不该先看电影，搞得我看书的时候觉得程霜就该长周也那样，周也真的是标准的初恋脸，外婆也就该长电影里的外婆那样，男主倒是无所谓哈哈哈哈。</p><p>我觉得这个小说看起来像一个童话，催泪结尾的童话，整个过程就是刘十三的成长过程。从一个我们传统意义上的没本事的人一步一步成熟，一步一步失去最爱的人，最后成长。</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><blockquote><p>抄自百度</p></blockquote><p>该小说主要写了云边镇少年刘十三的成长故事，前半部分写了刘十三从云边镇走向城市，在校园爱情、职场中受挫且伤痕累累，后半部分写刘十三被外婆王莺莺用拖拉机拉回了云边镇，在云边镇感受到的世情冷暖。该小说表达了对故乡、对亲情的衷心倾诉。外婆王莺莺的乐观坚韧和无限包容，程霜像一道光一样短暂又永恒，刘十三的奋斗与卑微，云边镇迷人的自然风景、悠然的生活节奏，共同构成了云边故乡的美好意境。</p><h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><p>我有很重要的事，输了的话，我就真的一无所有了。</p><p>幻觉很好，做梦也很好，一切远离现实的都很好。</p><p>有些人刻苦铭心，没几年会遗忘；有些人不论生死，都陪在身边。</p><p>月亮挂在半空，小镇背倚着起起伏伏的峰峦，山形边缘浮动银白色。</p><p>明明一块儿踏青野炊点篝火，大自然如此美好哭什么，难道触景生情，哭的是一岁一枯荣？</p><p>它们夹在笔记本最后的空白页，像夹在时光的间隙，人们随口说的一些话，跌落墙角，风吹不走，阳关烧不掉，独自沉眠。</p><p>为别人活着，也要为自己活着；希望和悲伤，都是一缕光；总有一天，我们会再相遇。</p><p>山风微微，像月光下晃动的海浪；温和而柔软，停留在时光的背后；变成小时候听过的故事；在遥远的城市，陌生的地方，有他未曾见过的山和海。</p><p>生命是有光的，在我熄灭以前，能够照亮你一点，就是我所有能做的了，我爱你，你要记得我。</p><p>跌倒一次，好不容易刚爬起来！没想到没走几步又狠狠地摔倒！想放弃这辈子就是个废物！但是为了亲情和责任又爬起来！装作没事的人，又接着上路。</p><p>原来世界上很多事情，不是你有计划，有毅力就能做到的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优点就是生活化做的很好，有时候叙事的同时会冷不丁地冒出来很有生活气息的一句话，让人感觉这是作者亲身经历过的事情，也容易引起共鸣，看书的时候会心一笑，开心一下。</p><p>看的时候感觉槽点很多，有些东西不能细想，有些东西太理想化。有人说作者是用了虚实结合的手法，情节是虚构的，但是人物测情感内核是真的。（十三的谐音是失散，程霜可能是成双成对，但终究是一场梦）。</p><p>耐心读完，一边吐槽一边大受感动，感受到了平时身边的人的对自己的爱是陪伴。</p><p>当不开心的时候或者想要消磨时间的时候，这本书是一个不错的选择，故事也很容易理解，十分具有生活气息。人和人之间舒服的关系，是可以一直不说话，也可以随时说话。</p>]]></content>
    
    
    <summary type="html">作者：张嘉佳</summary>
    
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>NexT配置utterances</title>
    <link href="https://dra-tammer.github.io/posts/14f6913e.html"/>
    <id>https://dra-tammer.github.io/posts/14f6913e.html</id>
    <published>2024-09-03T07:09:31.000Z</published>
    <updated>2024-09-03T07:09:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NexT配置utterances"><a href="#NexT配置utterances" class="headerlink" title="NexT配置utterances"></a>NexT配置utterances</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>utterances通过Github App实现，可以只对issues授权，因此没有安全性风险，不需要初始化。</p><blockquote><p><a href="https://utteranc.es/">https://utteranc.es/</a></p></blockquote><h2 id="创建存储评论的仓库"><a href="#创建存储评论的仓库" class="headerlink" title="创建存储评论的仓库"></a>创建存储评论的仓库</h2><p>新建一个仓库<code>blog_comments_db</code>用来存储评论</p><ul><li>保证仓库是公开仓库，否则读者没有办法看到这些评论</li><li>保证utterances app已经被安装</li></ul><h2 id="安装Github-Apps"><a href="#安装Github-Apps" class="headerlink" title="安装Github Apps"></a>安装Github Apps</h2><p><code>https://github.com/apps/utterances</code></p><p><code>install</code>-&gt;<code>Only select repositories</code>-&gt;<code>blog_comment_db</code></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="创建utterances-swig"><a href="#创建utterances-swig" class="headerlink" title="创建utterances.swig"></a>创建<code>utterances.swig</code></h3><p>在<code>layout/_third-party/comments</code>里创建<code>utterances.swig</code>，内容如下</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">{<span class="string">%-</span> <span class="string">if</span> <span class="string">page.comments</span> <span class="string">%</span>}</span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">NexT.utils.loadComments(document.querySelector('#utterances-container'),</span> <span class="string">()</span> <span class="string">=&gt;</span> {</span><br><span class="line">    <span class="string">//</span> <span class="string">if</span> <span class="string">(typeof</span> <span class="string">parcelRequire</span> <span class="string">===</span> <span class="string">'function'</span><span class="string">)</span> { <span class="string">return;</span> }</span><br><span class="line">    <span class="string">var</span> <span class="string">js</span> <span class="string">=</span> <span class="string">document.createElement('script');</span></span><br><span class="line">    <span class="string">js.type</span> <span class="string">=</span> <span class="string">'text/javascript'</span><span class="string">;</span></span><br><span class="line">    <span class="string">js.src</span> <span class="string">=</span> <span class="string">'https://utteranc.es/client.js'</span><span class="string">;</span></span><br><span class="line">    <span class="string">js.async</span> <span class="string">=</span> <span class="literal">true</span><span class="string">;</span></span><br><span class="line">    <span class="string">js.crossorigin</span> <span class="string">=</span> <span class="string">'anonymous'</span><span class="string">;</span></span><br><span class="line">    <span class="string">js.setAttribute('repo'</span>, <span class="string">'<span class="template-variable">{{ theme.utterances.repo }}</span>'</span><span class="string">);</span></span><br><span class="line">    <span class="string">js.setAttribute('issue-term'</span>, <span class="string">'<span class="template-variable">{{ theme.utterances.issue_term }}</span>'</span><span class="string">);</span></span><br><span class="line">    <span class="string">js.setAttribute('theme'</span>, <span class="string">'<span class="template-variable">{{ theme.utterances.theme }}</span>'</span><span class="string">);</span></span><br><span class="line">    <span class="string">document.getElementById('utterances-container').appendChild(js);</span></span><br><span class="line">}<span class="string">);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line">{<span class="string">%-</span> <span class="string">endif</span> <span class="string">%</span>}</span><br></pre></td></tr></tbody></table></figure><h3 id="创建utterances-js"><a href="#创建utterances-js" class="headerlink" title="创建utterances.js"></a>创建<code>utterances.js</code></h3><p>在<code>scripts/filters/comment</code>下创建<code>utterances.js</code>，内容如下</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/*</span> <span class="string">global</span> <span class="string">hexo</span> <span class="string">*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">'use strict'</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="string">const</span> <span class="string">path</span> <span class="string">=</span> <span class="string">require('path');</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">Add</span> <span class="string">comment</span></span><br><span class="line"><span class="string">hexo.extend.filter.register('theme_inject',</span> <span class="string">injects</span> <span class="string">=&gt;</span> {</span><br><span class="line">  <span class="string">let</span> <span class="string">theme</span> <span class="string">=</span> <span class="string">hexo.theme.config;</span></span><br><span class="line">  <span class="string">if</span> <span class="string">(!theme.utterances.enable)</span> <span class="string">return;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">injects.comment.raw('utterances'</span>, <span class="string">'&lt;div class="comments" id="utterances-container"&gt;&lt;/div&gt;'</span>, {}, {<span class="attr">cache:</span> <span class="literal">true</span>}<span class="string">);</span></span><br><span class="line"></span><br><span class="line">  <span class="string">injects.bodyEnd.file('utterances'</span>, <span class="string">path.join(hexo.theme_dir</span>, <span class="string">'layout/_third-party/comments/utterances.swig'</span><span class="string">));</span></span><br><span class="line"></span><br><span class="line">}<span class="string">);</span></span><br></pre></td></tr></tbody></table></figure><h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><p><code>NexT主题文件夹</code>-&gt;<code>_config.yml</code></p><p>在主题配置文件中添加</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">utterances:</span> </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">"你的repo地址"</span></span><br><span class="line">  <span class="attr">issue_term:</span> <span class="string">"pathname"</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">"github-light"</span></span><br></pre></td></tr></tbody></table></figure><p>关于配置选项的更多信息可参考<a href="https://utteranc.es/">官方网站</a>.</p><blockquote><p>现在我的hexo版本和next版本都是最新的，发现next已经内置了utterances</p></blockquote><p>所以只需要完成最后一步：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">utterances:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">Dra-Tammer/blog_comments_db</span> <span class="comment"># Github repository owner and name</span></span><br><span class="line">  <span class="comment"># Available values: pathname | url | title | og:title</span></span><br><span class="line">  <span class="attr">issue_term:</span> <span class="string">pathname</span></span><br><span class="line">  <span class="comment"># Available values: github-light | github-dark | preferred-color-scheme | github-dark-orange | icy-dark | dark-blue | photon-dark | boxy-light</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">github-dark</span></span><br></pre></td></tr></tbody></table></figure><h2 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h2><p>hexo三连</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></tbody></table></figure><h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><h3 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h3><p>本地部署，查看评论功能的时候登录会显示404，不知道如何解决，但是将代码push上去之后，访问github page就没有问题，确实加载的时候有点慢。</p><p>之后sign with github又能正常使用了</p><h3 id="设置部分页面不能评论"><a href="#设置部分页面不能评论" class="headerlink" title="设置部分页面不能评论"></a>设置部分页面不能评论</h3><p>配置之后发现tags, categories, about页面都有评论，想要不能评论，可以在对应的md页面的头部添加<code>comments: false</code>配置项</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2023-08-06 18:10:02</span><br><span class="line">type: categories</span><br><span class="line">comments: false</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">NexT主题配置utterances评论系统</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="博客" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="Hexo" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2/Hexo/"/>
    
    <category term="NexT" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2/Hexo/NexT/"/>
    
    <category term="配置" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2/Hexo/NexT/%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="博客" scheme="https://dra-tammer.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>2024年九月推免面试汇总</title>
    <link href="https://dra-tammer.github.io/posts/1d5f4f02.html"/>
    <id>https://dra-tammer.github.io/posts/1d5f4f02.html</id>
    <published>2024-08-27T03:21:20.000Z</published>
    <updated>2024-08-27T03:21:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本地知识库问答应用"><a href="#本地知识库问答应用" class="headerlink" title="本地知识库问答应用"></a>本地知识库问答应用</h2><h3 id="核心功能介绍"><a href="#核心功能介绍" class="headerlink" title="核心功能介绍"></a>核心功能介绍</h3><h4 id="个人AI助手"><a href="#个人AI助手" class="headerlink" title="个人AI助手"></a>个人AI助手</h4><p>将智能对话系统和传统知识库相耦合，使用户不仅可以询问知识库内相关内容，还可以询问知识库以外的内容。</p><h4 id="智能问答模块"><a href="#智能问答模块" class="headerlink" title="智能问答模块"></a>智能问答模块</h4><p>基于LLM大语言模型，在海量的知识库文件中挖掘信息，实现知识理解，推理与分析，根据挖掘的有效知识信息，智能回答用户提出的问题，并给出参考文件。</p><h4 id="对象存储模块"><a href="#对象存储模块" class="headerlink" title="对象存储模块"></a>对象存储模块</h4><p>利用对象存储技术的可扩展性强，可靠性高，采用全局唯一标识符访问数据，包含基本的文件管理，文件上传，文件删除功能。</p><h4 id="知识库管理模块"><a href="#知识库管理模块" class="headerlink" title="知识库管理模块"></a>知识库管理模块</h4><p>单独设立个人空间，包含新增知识库，删除知识库，修改知识库，知识库成员新增和踢出等知识库管理功能，同时还可以变更知识库访问权限。</p><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><blockquote><p>一套互联网应用程序的API设计理论</p></blockquote><p><strong>API</strong>是应用程序编程接口，使得一个软件程序能够向另一个软件程序传输数据，API调用就是触发使用API。</p><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>通信协议总是使用HTTPS</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>应该尽量将API部署在专用域名之下，如果确定API很简单，不会有进一步扩展，可以考虑放在主域名之下</p><h4 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h4><p>GET, POST, PUT, PATCH, DELETE等</p><h4 id="状态码等"><a href="#状态码等" class="headerlink" title="状态码等"></a>状态码等</h4><ol><li>200，成功返回数据</li><li>400，用户发出的请求有误</li><li>500，服务器发生错误，用户无法判断发出的请求是否成功</li></ol><h3 id="FastAPI"><a href="#FastAPI" class="headerlink" title="FastAPI"></a>FastAPI</h3><p>FasAPI是一个现代，快速，高性能的Web框架，用户构建基于Python的API</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>快速高效</li><li>自动文档生成</li><li>数据验证和转换</li><li>类型提示</li><li>安全认证</li><li>强大的生态系统</li></ul><h3 id="LangChain"><a href="#LangChain" class="headerlink" title="LangChain"></a>LangChain</h3><p>开源编排框架，用于使用大语言模型开发应用程序，可以简化LLM驱动型应用程序的开发过程。</p><p>核心是一个开发环境，通过使用抽象方法简化LLM应用程序的编程，模块化将充当AI程序的构建块，将它们连接在一起来创建应用程序。</p><h4 id="Langchain-组件"><a href="#Langchain-组件" class="headerlink" title="Langchain 组件"></a><strong>Langchain 组件</strong></h4><p>基于以下几个核心的 langchain 组件构建本地知识库</p><ul><li><p>Embedding（嵌入模型）</p><p>为了捕捉文本的语义和语法信息，以便在后续的任务中能够更好地使用</p></li><li><p>Vector Store（向量数据库）</p></li><li><p>Document Splitter（文档切割）</p></li><li><p>LLM （大模型）</p></li></ul><h3 id="LLM"><a href="#LLM" class="headerlink" title="LLM"></a>LLM</h3><p>大语言模型是针对语言的大模型，大模型是一种深度学习模型，包含了“预训练”和“大模型”两层含义，模型在大规模数据集上完成了预训练后无需微调或者仅需少量的微调，就能直接支持各类应用。</p><p>通过学习大量的文本数据，<strong>来预测下一个词或者下一段话的可能性</strong>，从而使计算机能够更好地理解和生成人类语言。生成式预训练Transformer（GPT），可以自动生成具有语言上下文和逻辑关系的连贯文本，这些文本在预训练时并没有直接指定，而是通过模型自身的学习和推理得到的。</p><p>LLM能够理解上下文信息，处理多种自然语言处理的任务，比如：文本生成，翻译，摘要，情感分析，无需给每个任务单独训练一个模型。</p><h4 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h4><p>一个预先设定的条件，可以限制模型的自由发散，而是围绕提示内容进行展开。</p><h3 id="如何进行知识挖掘"><a href="#如何进行知识挖掘" class="headerlink" title="如何进行知识挖掘"></a>如何进行知识挖掘</h3><ol><li>加载用户上传到知识库中的文件</li><li>预处理与文本切分</li></ol><p>将一个文档转成向量数据库中的数据往往可以分成两个大的步骤，<strong>tokenizer****和</strong>embedding**</p><ul><li>tokenizer负责将文本拆分成次元</li><li>embedding将词元转换成词向量的表示</li></ul><ol><li>向量化与向量存储</li><li>用户提问，将用户的提问向量化，在数据库中检索相似的几条向量，即匹配文本相似性和语义检索，将检索出来的结果用于NLP问答。将用户的提问向量和检索出的向量数据发送给大语言模型处理，生成用户能够理解的语言。</li></ol><h3 id="向量数据库"><a href="#向量数据库" class="headerlink" title="向量数据库"></a>向量数据库</h3><blockquote><p>向量数据存储在专门设计的向量数据库中，可以通过最近邻搜索算法找到与查询向量相似的向量。</p></blockquote><p>如果要表达一个具体事物的特征，所用的向量维度还是非常大的，在检索的时候非常消耗性能，使用一些算法进行优化， 比如K-means聚类算法，用分类的质心向量来代替每一个向量，以减少存储的空间。</p><p>每一个事物可以是具象的，也可以是抽象的，最终都会在一个高维的特征空间中对应着一个坐标点。</p><h4 id="向量数据库对LLM处理的作用"><a href="#向量数据库对LLM处理的作用" class="headerlink" title="向量数据库对LLM处理的作用"></a>向量数据库对LLM处理的作用</h4><p>如果拿着当前文本的向量数据去寻找之前问答过程中最相似的问答文本，将他们作为上下文输送给大模型，能够极大提高大模型的输出准确性和输出效率。能够生成具有上下文意识和更加满足用户需求，更加专业的回答。</p><ol><li>提高LLM的性能：通过使用向量数据库，LLM可以实现对文本数据的快速检索和分析，从而提高其处理速度和准确性。这对于需要处理大规模数据的LLM来说尤为重要。</li><li>降低存储成本：向量数据库采用高效的存储结构，能够实现对向量数据的压缩和去重，从而降低存储成本。这对于需要长期保存大量数据的LLM来说非常有利。</li><li>支持多模态数据处理：除了文本数据外，向量数据库还可以处理图像、音频等多模态数据。这使得LLM能够实现对多种类型数据的综合处理，进一步拓展其应用场景。</li></ol><p>同时解决LLM的上下文限制问题（token），如果你的知识库内容长度超出了限制，我们就不能直接让 ChatGPT 对其进行总结并回答问题。通过 Embedding 技术，我们可以使用语义搜索来快速找到相关的文档，然后只将相关的文档内容注入到大模型的上下文窗口中，让模型来生成特定问题的答案，从而解决大模型的限制问题。这种做法比 Fine tuning 速度更快，而且不需要训练，使用上也更灵活。</p><h4 id="最近邻问题"><a href="#最近邻问题" class="headerlink" title="最近邻问题"></a>最近邻问题</h4><blockquote><p>向量数据的一个主要的应用场景就是给定一个查询向量，然后从众多向量中找到最为相似的一些。</p></blockquote><h4 id="最近邻搜索算法"><a href="#最近邻搜索算法" class="headerlink" title="最近邻搜索算法"></a>最近邻搜索算法</h4><h5 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h5><p>两个向量的夹角，或者计算两个向量之间的欧氏距离。</p><h5 id="K-means聚类算法（近似最近邻）"><a href="#K-means聚类算法（近似最近邻）" class="headerlink" title="K-means聚类算法（近似最近邻）"></a>K-means聚类算法（近似最近邻）</h5><ol><li>先选定一个想要分类的数量，随机生成四个点，称为聚类中心点，这些向量与哪个中心点最近就被分为哪一类</li><li>用当前被分为一类的向量计算出一个平均向量点，把对应的中心点的位置更新为这个平均向量点</li><li>重新判断每一个向量与哪个中心最近，重新分类</li><li>重复步骤二，三</li></ol><p>如此反复，这个不断迭代的过程就被称为训练，最后这些中心点会趋于稳定或者说收敛，搜索的时候，先看查询向量属于哪个聚类，再在聚类中所搜最相似的向量。</p><h4 id="向量数据库和传统数据库有什么区别"><a href="#向量数据库和传统数据库有什么区别" class="headerlink" title="向量数据库和传统数据库有什么区别"></a>向量数据库和传统数据库有什么区别</h4><p>传统数据库主要是针对结构化数据的存储和查询，而向量数据库则是针对非结构化数据（例如图像、文本等）的存储和查询。 向量数据库的优势在于它可以通过向量相似度快速和高效地查询相似的数据，适用于图像搜索、语音识别、推荐系统等场景。</p><h4 id="什么是结构化的数据"><a href="#什么是结构化的数据" class="headerlink" title="什么是结构化的数据"></a>什么是结构化的数据</h4><p>结构化数据就是具有预定义的结构或者预定义的格式的数据，例如存储的日期是有格式的，性别是有格式的</p><p>非结构化数据缺乏定义，各种各样的格式，比如图像，文本等</p><h4 id="向量数据库给LLM传输的是什么类型的数据"><a href="#向量数据库给LLM传输的是什么类型的数据" class="headerlink" title="向量数据库给LLM传输的是什么类型的数据"></a>向量数据库给LLM传输的是什么类型的数据</h4><p>在构建知识库应用时，向量数据库向LLM（大型语言模型）传输的数据通常是高维数值向量。这些向量是通过将原始数据（如文本、图像、音频等）经过特定的算法（如词嵌入Word Embeddings、BERT或其他深度学习模型）转换得到的，它们能够捕捉数据的关键特征和语义信息。</p><h3 id="AIGC"><a href="#AIGC" class="headerlink" title="AIGC"></a>AIGC</h3><blockquote><p>人工智能生成内容</p></blockquote><p>ChatGPT是AIGC在聊天对话场景的一个具体应用。</p><h3 id="自然语言处理（NLP）"><a href="#自然语言处理（NLP）" class="headerlink" title="自然语言处理（NLP）"></a>自然语言处理（NLP）</h3><p>理解用户的自然语言</p><h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><p>一种深度学习模型，在自然语言处理领域特别流行，能够更加高效和有效地处理序列数据。transformer完全基于注意力机制，没有使用循环神经网络（RNN）或者卷积神经网络（CNN）。核心是：</p><ul><li>自注意力机制：并行处理所有位置的数据，提高计算效率</li><li>多头注意力：捕获序列中多种不同级别的依赖关系</li><li>位置编码：提供单词在序列中位置的信息</li></ul><h3 id="RNN模型"><a href="#RNN模型" class="headerlink" title="RNN模型"></a>RNN模型</h3><p>循环神经网络（recurrent neural network，RNN）是一种具有反馈结构的神经网络，其输出不但与当前输入和网络的权值有关，而且也与之前网络的输入有关；RNN通过添加跨越时间点的自连接隐藏层，对时间进行建模；换句话说，隐藏层的反馈，不仅仅进入输出端，而且还进入了下一时间的隐藏层。 一般的RNNs有多个FNN横向连接而成，其中中间有个rnn-cell, 存储的是前面序列的隐含状态s。 分解开来的话， 就相当于三层，第一层是输入x到rnn-cell的连接，第二层是rnn-cell,得到的是隐藏状态s，第三层是rnn-cell到输出o的连接层。</p><ul><li>输入层</li><li>隐藏层</li><li>输出层</li></ul><h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>基于对象的存储，与其他计算机数据存储架构不同的是，它管理的是对象，而不是文件系统和数据块，一个“对象”包括数据本身，一些元数据和一个唯一标识符。这些数据可以通过API或者http/https进行即刻访问。通过这种方式，对象存储保障了数据的安全。如果需要这些数据还可以复制到多个数据中心。</p><p>与文件类型和块类型存储不同，对象存储支持有助于描述文件的全面元数据。元数据可帮助您理解和分析大型文件，而无需直接处理文件中包含的内容。</p><h4 id="对象存储的好处"><a href="#对象存储的好处" class="headerlink" title="对象存储的好处"></a>对象存储的好处</h4><ul><li><strong>更易于访问</strong>：对象存储由元数据驱动，通过对每个数据的这种分类级别，您可以轻松地对文件进行排序和搜索。</li><li><strong>无限存储</strong>：对象存储不依赖于硬件（不限于单个服务器或NAS）</li><li><strong>降低成本</strong>：由于对象存储的横向扩展性质，存储所有数据的成本更低。</li><li><strong>资源优化</strong>：由于对象存储没有归档层次结构，并且元数据完全可自定义，因此与文件或块存储相比，硬件限制要少得多。</li></ul><h4 id="对象存储的元数据"><a href="#对象存储的元数据" class="headerlink" title="对象存储的元数据"></a>对象存储的元数据</h4><p>对于元数据为何产生影响的实际例子，我们可以看看医院如何存储和处理患者的X射线图像。 X射线文件将具有与其关联的有限元数据，例如创建日期，所有者，位置和大小。另一方面，X射线对象可以具有丰富的元数据信息。</p><p>元数据可以包括患者姓名，出生日期，受伤细节，身体的哪个区域进行X光检查 - 以及文件所具有的相同标签。这使得医生提取相关信息以供参考非常有用。</p><h4 id="对象存储的局限性"><a href="#对象存储的局限性" class="headerlink" title="对象存储的局限性"></a>对象存储的局限性</h4><ul><li>与Block Storage相比，访问速度更慢</li><li>文件无法编辑，需要重写/重新上传整个内容</li><li>难以限制/定义存储位置</li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="燃烧若干根不均匀的绳，每条绳子燃尽是1小时，如何计时1小时15分？"><a href="#燃烧若干根不均匀的绳，每条绳子燃尽是1小时，如何计时1小时15分？" class="headerlink" title="燃烧若干根不均匀的绳，每条绳子燃尽是1小时，如何计时1小时15分？"></a>燃烧若干根不均匀的绳，每条绳子燃尽是1小时，如何计时1小时15分？</h3><p>把第一根绳子两头同时点燃,同时把第二根绳子点燃一头,当第一根绳子烧完时,时间为半个小时,这时把第二根绳子的另一头也点燃,开始计时,当第二根绳子烧完时,停止计时,那么这段时间就是15分钟。也就是说，只需要3根绳子就可以计时一个小时15分钟。</p><h3 id="给你一个6L和5L的杯子和一个无限容量的容器，如何量出4L的水？"><a href="#给你一个6L和5L的杯子和一个无限容量的容器，如何量出4L的水？" class="headerlink" title="给你一个6L和5L的杯子和一个无限容量的容器，如何量出4L的水？"></a>给你一个6L和5L的杯子和一个无限容量的容器，如何量出4L的水？</h3><p>先把6L桶装满，再向5L桶里倒水。5L桶满，则把它的水倒掉，6L桶没水，则装满水，不断循环这个过程，直到找到满足要求的水。</p><h3 id="exe文件在Linux系统下为什么不能运行"><a href="#exe文件在Linux系统下为什么不能运行" class="headerlink" title=".exe文件在Linux系统下为什么不能运行"></a>.exe文件在Linux系统下为什么不能运行</h3><p>编译链接的时候用到的库不一样</p><h3 id="编译型语言和解释型语言的区别"><a href="#编译型语言和解释型语言的区别" class="headerlink" title="编译型语言和解释型语言的区别"></a>编译型语言和解释型语言的区别</h3><p>源代码一次性转换成二进制指令，生成一个可执行程序，即编译型语言</p><p>一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序</p><h3 id="深度学习和机器学习"><a href="#深度学习和机器学习" class="headerlink" title="深度学习和机器学习"></a>深度学习和机器学习</h3><p>深度学习（也称为深度神经学习或深度神经网络）会让计算机通过观察，学习、模仿人类获取知识的方式。 </p><p>人脑中有很多相互连接的神经元，当大脑处理信息（或数据）时，这些神经元就负责传递信息。神经元之间通过电信号和化学物质相互作用，并在大脑的不同区域之间传递信息。 </p><p>人工神经网络（ANN）是模仿这种生物学现象而构成的，是深度学习所依托的底层架构，然而，ANN 使用的是人工神经元而不是生物神经元，这些人工神经元是由称为节点的软件模块构成的。这些节点使用数值计算（而不是大脑中的化学信号）来进行通信和传递信息。模拟神经网络（SNN）通过聚类数据点进行预测的方式来处理数据。</p><p>为了便于理解，我们可以将深度学习想象为某种流程图，它从输入层开始，到输出层结束。夹在这两层之间的是“隐藏层”，负责加工处理不同级别的信息，并随着不断接收新数据而调整和适应它们的行为。深层学习模型可以拥有数百个隐藏层，每个隐藏层都在数据集中发现关系和模式方面发挥作用。 </p><p>深度学习是机器学习的一种特殊形式，两者的区别在于其所处理的数据类型和学习方法。</p><p>经典的机器学习算法需要人工干预，先对数据集进行预处理，然后再将其导入模型。这意味着人要在模型的输入数据中定义和标记特定特征，并组织到表格中，然后再将其导入机器学习模型。相反，深度学习算法不需要这种级别的预处理，并且能够理解非结构化数据，例如文本文档、像素数据图像或音频数据文件。 </p><p>在有大量数据，却缺乏相关主题的背景知识或手头有复杂耗时的任务的情况下，深度学习可能优于经典机器学习。</p><ol><li>机器学习只关注解决现实问题。它还需要人工智能的一些想法。机器学习通过旨在模仿人类决策能力的神经网络。ML工具和技术是两个主要的仅关注深度学习的窄子集。我们需要应用它来解决任何需要思考的问题 —— 人类的或人为的。任何深度神经网络都将包含以下三层：输入层、隐藏层、输出层</li><li>我们用机器算法来解析数据，学习数据，并从中做出理智的判定。根本上讲，深度学习用于创建可自我学习和可理智判定的人工“神经网络”。我们可以说深度学习是机器学习的子领域。</li></ol><h3 id="介绍一下go语言的特征"><a href="#介绍一下go语言的特征" class="headerlink" title="介绍一下go语言的特征"></a>介绍一下go语言的特征</h3><h4 id="go语言出现的背景"><a href="#go语言出现的背景" class="headerlink" title="go语言出现的背景"></a>go语言出现的背景</h4><ul><li>Go希望成为互联网时代的C语言。多数系统级语言（包括Java和C#）的根本编程哲学来源于C++，将C++的面向对象进一步发扬光大。但是Go语言的设计者却有不同的看法，他们认为值得学习的是C语言。C语言经久不衰的根源是它足够简单。因此，Go语言也是足够简单。</li><li>所以，他们当时设计Go的目标是为了消除各种缓慢和笨重、改进各种低效和扩展性。Go是由那些开发大型系统的人设计的，同时也是为了这些人服务的；它是为了解决工程上的问题，不是为了研究语言设计；它还是为了让我们的编程变得更舒适和方便。</li><li>但是结合Google当时内部的一些现实情况，如很多工程师都是C系的，所以新设计的语言一定要易学习，最好是类似C的语言；20年没有出新的语言了，所以新设计的语言必须是现代化的（例如内置GC）等情况。最后根据实战经验，他们向着目标设计了Go这个语言。</li></ul><h4 id="go语言的特色"><a href="#go语言的特色" class="headerlink" title="go语言的特色"></a>go语言的特色</h4><ul><li>没有继承多态的面向对象</li><li>强一致类型</li><li>interface不需要显式声明(Duck Typing)</li><li>没有异常处理(Error is value)</li><li>基于首字母的可访问特性</li><li>不用的import或者变量引起编译错误</li><li>完整而卓越的标准库包</li><li>Go内置runtime（作用是性能监控、垃圾回收等）</li></ul><h4 id="go语言的优势"><a href="#go语言的优势" class="headerlink" title="go语言的优势"></a>go语言的优势</h4><p>1、学习曲线容易</p><p> Go语言语法简单，包含了类C语法。因为Go语言容易学习，所以一个普通的大学生花几个星期就能写出来可以上手的、高性能的应用。在国内大家都追求快，这也是为什么国内Go流行的原因之一。</p><p>2、效率：快速的编译时间，开发效率和运行效率高</p><p> 开发过程中相较于 Java 和 C++呆滞的编译速度，Go 的快速编译时间是一个主要的效率优势。Go拥有接近C的运行效率和接近PHP的开发效率。</p><p>C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。</p><p>3、出身名门、血统纯正</p><p> 之所以说Go出身名门，从Go语言的创造者就可见端倪，Go语言绝对血统纯正。其次Go语言出自Google公司，Google在业界的知名度和实力自然不用多说。Google公司聚集了一批牛人，在各种编程语言称雄争霸的局面下推出新的编程语言，自然有它的战略考虑。而且从Go语言的发展态势来看，Google对它这个新的宠儿还是很看重的，Go自然有一个良好的发展前途。</p><p>4、自由高效：组合的思想、无侵入式的接口</p><p> Go语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go语言支持当前所有的编程范式，包括过程式编程、面向对象编程、面向接口编程、函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。</p><p>5、强大的标准库</p><p> 这包括互联网应用、系统编程和网络编程。Go里面的标准库基本上已经是非常稳定了，特别是我这里提到的三个，网络层、系统层的库非常实用。<strong>Go 语言的 lib 库麻雀虽小五脏俱全。</strong>Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。</p><p>6、部署方便：二进制文件，Copy部署</p><p> 这一点是很多人选择Go的最大理由，因为部署太方便了，所以现在也有很多人用Go开发运维程序。</p><p>7、简单的并发</p><p><strong>并行和异步编程几乎无痛点。</strong>Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的编程者来说，完全就是让人眼前一亮的感觉。Go 是一种非常高效的语言，高度支持并发性。Go是为大数据、微服务、并发而生的一种编程语言。</p><ul><li>Go 作为一门语言致力于使事情简单化。它并未引入很多新概念，而是聚焦于打造一门简单的语言，它使用起来异常快速并且简单。其唯一的创新之处是 goroutines 和通道。Goroutines 是 Go 面向线程的轻量级方法，而通道是 goroutines 之间通信的优先方式。</li><li>创建 Goroutines 的成本很低，只需几千个字节的额外内存，正由于此，才使得同时运行数百个甚至数千个 goroutines 成为可能。可以借助通道实现 goroutines 之间的通信。Goroutines 以及基于通道的并发性方法使其非常容易使用所有可用的 CPU 内核，并处理并发的 IO。相较于 Python/Java，在一个 goroutine 上运行一个函数需要最小的代码。</li></ul><p>8、稳定性</p><p> Go拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么Go相比于其他程序会更稳定呢？这是因为Go提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如go tool、gofmt、go test。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="计算机之间的通信"><a href="#计算机之间的通信" class="headerlink" title="计算机之间的通信"></a>计算机之间的通信</h3><p>计算机之间的通信是两个主机进程之间的通信</p><h3 id="计算机网络分层"><a href="#计算机网络分层" class="headerlink" title="计算机网络分层"></a>计算机网络分层</h3><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><ul><li>应用层：为计算机用户提供服务</li><li>表示层：数据处理</li><li>会话层：管理应用程序之间的会话</li><li>传输层：端到端的进程通信</li><li>网络层：路由和寻址</li><li>数据链路层：帧编码喝误差纠正控制</li><li>物理层：透明地传送比特流</li></ul><h4 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h4><ul><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ul><h4 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h4><table><thead><tr><th>层次</th><th>功能</th><th>协议</th><th>交互的数据单元</th><th>中间设备</th></tr></thead><tbody><tr><td>应用层</td><td>为最终用户提供特定的网络应用</td><td>DNS,HTTP,HTTPS,SMTP</td><td>报文</td><td>网关</td></tr><tr><td>运输层</td><td>提供端到端的进程通信</td><td>TCP,UDP</td><td>报文段（TCP），用户数据报（UDP）</td><td>网关</td></tr><tr><td>网络层</td><td>在任意主机之间进行通信，任意节点之间尽力而为地传输分组</td><td>IP</td><td>IP数据报（数据报）</td><td>路由器</td></tr><tr><td>数据链路层</td><td>相邻节点之间无差错地传输数据帧</td><td>PPP,以太网</td><td>数据帧</td><td>网桥，交换机</td></tr><tr><td>物理层</td><td>传播比特流</td><td></td><td>比特</td><td>转发器，集线器，中继器，放大器</td></tr></tbody></table><h3 id="为什么网络要分层"><a href="#为什么网络要分层" class="headerlink" title="为什么网络要分层"></a>为什么网络要分层</h3><ol><li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li><li><strong>提高了灵活性和可替换性</strong>：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。并且，每一层都可以根据需要进行修改或替换，而不会影响到整个网络的结构。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li><li><strong>大问题化小</strong>：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 **这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</li></ol><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p></blockquote><h3 id="常见的网络协议"><a href="#常见的网络协议" class="headerlink" title="常见的网络协议"></a>常见的网络协议</h3><ul><li><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）</strong>：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li><li><strong>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）</strong>：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li><li><strong>POP3/IMAP（邮件接收协议）</strong>：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li><li><strong>FTP（File Transfer Protocol，文件传输协议）</strong> : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。</li><li><strong>Telnet（远程登陆协议）</strong>：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li><li><strong>SSH（Secure Shell Protocol，安全的网络传输协议）</strong>：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务</li><li><strong>RTP（Real-time Transport Protocol，实时传输协议）</strong>：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</li><li><strong>DNS（Domain Name System，域名管理系统）</strong>: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。</li></ul><h3 id="信息交互的方式"><a href="#信息交互的方式" class="headerlink" title="信息交互的方式"></a>信息交互的方式</h3><ol><li><p>单工通信</p><p>只有一个方向的通信没有反方向的交互</p></li><li><p>半双工通信</p><p>通信的双方都能发送信息，但是不能同时发送信息</p></li><li><p>全双工通信</p><p>通信的双方可以同时发送和接收信息</p></li></ol><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><blockquote><p>隐藏局域网之间的差异，逻辑上编一个地址，给连接到互联网上的每一台主机（或者路由器）的每一个接口，分配一个在全世界范围内唯一的32位的标识符）</p><p>格式：网络号+主机号</p><p>IPv4的地址空间2^32</p><p>点分十进制</p><p>IPv6的地址空间2^128</p><p>点分十六进制</p></blockquote><h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><p>TCP是面向连接的，可靠的，基于字节流的传输层通信协议</p><ol><li>面向连接：一定是一对一建立连接才能通信，不像UDP可以一对多</li><li>可靠的：保证报文一定能够到达接收端</li><li>字节流</li></ol><h3 id="TCP建立的三次握手"><a href="#TCP建立的三次握手" class="headerlink" title="TCP建立的三次握手"></a>TCP建立的三次握手</h3><ol><li>请求方向接收方发送一个建立连接的请求报文。（SYN = 1）</li><li>接收方向发送方发送一个对建立连接报文的确认报文。（SYN = 1, ACK = 1）</li><li>请求方向接收方发送一个对确认报文的确认报文，建立连接。（SYN = 1）</li></ol><h3 id="TCP断开连接的四次挥手"><a href="#TCP断开连接的四次挥手" class="headerlink" title="TCP断开连接的四次挥手"></a>TCP断开连接的四次挥手</h3><ol><li>主动关闭方告诉对方自己没有数据发送，请求关闭连接。</li><li>被动关闭方向主动关闭方发送一个对关闭连接请求的确认报文。</li><li>被动关闭方发送一个准备关闭连接的报文。</li><li>主动关闭方发送一个对被动关闭方发送的关闭连接的请求的确认报文，之后双方都进入CLOSED状态。</li></ol><h3 id="UDP和TCP"><a href="#UDP和TCP" class="headerlink" title="UDP和TCP"></a>UDP和TCP</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>都是传输层的协议</p><ul><li>传输控制协议(TCP)：面向连接，可靠</li><li>用户数据报协议(UDP)：无连接，尽力而为，不保证可靠</li></ul><h4 id="面向"><a href="#面向" class="headerlink" title="面向"></a>面向</h4><ul><li>UDP是面向报文的，对于应用层传输下来的报文，加上一个首部就交付给网络层。对报文既不拆分也不合并，保留这些报文的边界。一次发送一个报文。UDP向应用层交付的时候也是去掉一个首部，将一个完整的报文交给应用层。</li><li>TCP是面向字节流的，无论是发送还是接收，都是把数据块视为一个无边界的字节流，按顺序一个字节一个字节地发送或者接收。</li></ul><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>UDP是无连接的，TCP是面向连接的</p><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>UDP是不可靠的传输协议，他只是尽力而为地传输。没有内置的重传机制，流量控制和拥塞控制。TCP是可靠的传输协议，停等协议，回退n帧，选择重发，有流量控制和拥塞控制。</p><h4 id="上层协议"><a href="#上层协议" class="headerlink" title="上层协议"></a>上层协议</h4><p>DNS的下层协议是UDP，HTTP，HTTPS，FTP的下层协议是TCP</p><h3 id="网络层有哪些协议"><a href="#网络层有哪些协议" class="headerlink" title="网络层有哪些协议"></a>网络层有哪些协议</h3><ul><li><strong>IP（Internet Protocol，网际协议）</strong>：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li><li><strong>ARP（Address Resolution Protocol，地址解析协议）</strong>：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li><li><strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。</li><li><strong>NAT（Network Address Translation，网络地址转换协议）</strong>：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</li><li><strong>OSPF（Open Shortest Path First，开放式最短路径优先）</strong>：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</li><li><strong>RIP(Routing Information Protocol，路由信息协议）</strong>：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li><li><strong>BGP（Border Gateway Protocol，边界网关协议）</strong>：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。</li></ul><h3 id="从输入URL到页面展示发生了什么"><a href="#从输入URL到页面展示发生了什么" class="headerlink" title="从输入URL到页面展示发生了什么"></a>从输入URL到页面展示发生了什么</h3><ol><li>在浏览器中输入指定网页的 URL。</li><li>浏览器通过 DNS 协议，获取域名对应的 IP 地址。</li><li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li><li>浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li><li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li><li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li><li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li></ol><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>互联网上唯一的进程编号</p><h3 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h3><p>互联网使用的命名系统，便于人们容易理解的机器名字转换为IP地址，解决域名和IP地址的映射问题</p><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><p>HTTP最初的目的是为了提供一种发布和接收HTML页面的方法</p><p>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。</p><ol><li><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</li><li><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li><li><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li><li><strong>SEO（搜索引擎优化）</strong>：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</li></ol><h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><p>GET 和 POST 是 HTTP 协议中两种常用的请求方法，它们在不同的场景和目的下有不同的特点和用法。一般来说，可以从以下几个方面来区分二者（重点搞清两者在语义上的区别即可）：</p><ul><li>语义（主要区别）：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。</li><li>幂等：GET 请求是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。</li><li>格式：GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中，可以有多种编码格式，如 application/x-www-form-urlencoded、multipart/form-data、application/json 等。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。不过，实际上 GET 请求也可以用 body 传输数据，只是并不推荐这样做，因为这样可能会导致一些兼容性或者语义上的问题。</li><li>缓存：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。</li><li>安全性：GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 HTTP 协议本身是明文传输的，必须使用 HTTPS 协议来加密传输数据。另外，GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中。</li></ul><h3 id="WebSocket和HTTP有什么区别"><a href="#WebSocket和HTTP有什么区别" class="headerlink" title="WebSocket和HTTP有什么区别"></a>WebSocket和HTTP有什么区别</h3><p>WebSocket 和 HTTP 两者都是基于 TCP 的应用层协议，都可以在网络中传输数据。</p><p>下面是二者的主要区别：</p><ul><li>WebSocket 是一种双向实时通信协议，而 HTTP 是一种单向通信协议。并且，HTTP 协议下的通信只能由客户端发起，服务器无法主动通知客户端。</li><li>WebSocket 使用 ws:// 或 wss://（使用 SSL/TLS 加密后的协议，类似于 HTTP 和 HTTPS 的关系） 作为协议前缀，HTTP 使用 http:// 或 https:// 作为协议前缀。</li><li>WebSocket 可以支持扩展，用户可以扩展协议，实现部分自定义的子协议，如支持压缩、加密等。</li><li>WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小，而 HTTP 通信每次都要携带完整的头部，网络开销较大（HTTP/2.0 使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）。</li></ul><h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><h3 id="B，KB，MB，GB，TB"><a href="#B，KB，MB，GB，TB" class="headerlink" title="B，KB，MB，GB，TB"></a>B，KB，MB，GB，TB</h3><ul><li><strong>B</strong> 代表字节（Byte），是最小的数据单位，1个字节等于8位（bit）。</li><li><strong>KB</strong> 代表千字节（Kilobyte），1KB 等于 1024 字节（2^10 字节）。</li><li><strong>MB</strong> 代表兆字节（Megabyte），1MB 等于 1024KB，也就是 1024 * 1024 字节，即 2^20 字节。</li><li><strong>GB</strong> 代表吉字节（Gigabyte），1GB 等于 1024MB，也就是 1024 * 1024KB，即 1024210242 字节，等于 230230 字节。</li><li><strong>TB</strong> 代表太字节（Terabyte），1TB 等于 1024GB，也就是 1024 * 1024MB，即 1024310243 字节，等于 240240 字节。</li></ul><h3 id="冯诺依曼体系结构和机器的特点"><a href="#冯诺依曼体系结构和机器的特点" class="headerlink" title="冯诺依曼体系结构和机器的特点"></a>冯诺依曼体系结构和机器的特点</h3><p>五大组成，输入设备，运算器，输出设备，存储器和控制器</p><p>特点：</p><ul><li>指令和数据以二进制码表示</li><li>同等地位</li><li>指令由操作码和地址码组成</li><li>指令在存储器中顺序存放</li><li>运算器为中心</li></ul><h3 id="比特，字，字节"><a href="#比特，字，字节" class="headerlink" title="比特，字，字节"></a>比特，字，字节</h3><p><strong>比特</strong>，表示二进制位</p><p><strong>字节</strong>，byte，一个字节等于8个比特</p><p><strong>字</strong>，word，计算机进行数据处理时，一次存取，加工和传送的数据长度称为字，一个字通常是由一个或者多个字节构成。计算机的字长决定了其CPU一次操作处理实际位数的多少，由此可见计算机的字长越大，其性能越优越。</p><h3 id="RAM-和-ROM和FM"><a href="#RAM-和-ROM和FM" class="headerlink" title="RAM 和 ROM和FM"></a>RAM 和 ROM和FM</h3><p>随机存取存储器RAM，访问某个单元时间和它的物理位置没有关系</p><p>RAM包括SRAM用触发器实现，稳定，但元件多，常用cache，DRAM用电容实现，元件少，常用主存</p><p>RAM断电后数据丢失</p><p>只读存储器ROM，负责把辅存里面的OS调到RAM中，负责存储开机的详细信息</p><h3 id="计算机系统由哪两部分组成？性能取决于什么？"><a href="#计算机系统由哪两部分组成？性能取决于什么？" class="headerlink" title="计算机系统由哪两部分组成？性能取决于什么？"></a>计算机系统由哪两部分组成？性能取决于什么？</h3><p>软件和硬件，CPU（运算器，控制器）和内存（存储器），外存（硬盘）</p><h3 id="解释下什么是DMA"><a href="#解释下什么是DMA" class="headerlink" title="解释下什么是DMA"></a>解释下什么是DMA</h3><p>以主存为中心，采用硬件手段在主存与I/O设备之间建立直接的数据传送通路，由DMA控制器（DMAC）取得总线控制权，控制主存与I/O设备之间的数据传送，在传送过程中不需要CPU的程序干预的数据传送控制方式。</p><h3 id="说下五级流水CPU的各阶段"><a href="#说下五级流水CPU的各阶段" class="headerlink" title="说下五级流水CPU的各阶段"></a>说下五级流水CPU的各阶段</h3><p>取指、译码、执行、访存、写回</p><h3 id="执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？"><a href="#执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？" class="headerlink" title="执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？"></a>执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？</h3><p>单周期更快，减少段与段之间的交互开销。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="如何判断一个单链表是否是循环链表（要给出一个比遍历更快的方法）"><a href="#如何判断一个单链表是否是循环链表（要给出一个比遍历更快的方法）" class="headerlink" title="如何判断一个单链表是否是循环链表（要给出一个比遍历更快的方法）"></a>如何判断一个单链表是否是循环链表（要给出一个比遍历更快的方法）</h3><p>快慢指针法：两个指针一个每次前进1步、一个每次前进2步，相遇则循环</p><h3 id="介绍下平衡二叉树"><a href="#介绍下平衡二叉树" class="headerlink" title="介绍下平衡二叉树"></a>介绍下平衡二叉树</h3><p>一般是二叉搜索树，任意节点的子树的高度差都小于等于 1</p><h3 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h3><ul><li>时间复杂度是用于评估执行程序所消耗的时间</li><li>空间复杂度是用于评估执行程序所占用的内存空间</li></ul><h3 id="数据结构、逻辑结构、存储结构"><a href="#数据结构、逻辑结构、存储结构" class="headerlink" title="数据结构、逻辑结构、存储结构"></a>数据结构、逻辑结构、存储结构</h3><ul><li>数据结构是计算机存储和组织数据的方式</li><li>逻辑结构是指元素之间的逻辑关系，与数据的存储结构无关</li><li>存储结构是指元素在计算机中的物理存储方式</li></ul><h3 id="数据结构的4种逻辑结构"><a href="#数据结构的4种逻辑结构" class="headerlink" title="数据结构的4种逻辑结构"></a>数据结构的4种逻辑结构</h3><ul><li>集合结构:数据元素之间同属于一种类型</li><li>线性结构:数据元素之间存在一对一的关系</li><li>树形结构:数据元素之间存在一对多的关系</li><li>图状结构:数据元素之间存在多对多的关系</li></ul><h3 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h3><ul><li><p>数组需要预先从栈中分配固定的长度，不能动态增添数据项，适用于快速查找和修改，较少使用插入和删除</p></li><li><p>链表可以从堆中动态地分配空间，可以适应动态增添数据项，适用于经常插入和删除</p></li><li><p>数组支持随机访问，而链表不支持。</p></li><li><p>数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</p></li><li><p>数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！</p></li></ul><h3 id="树的存储方式"><a href="#树的存储方式" class="headerlink" title="树的存储方式"></a>树的存储方式</h3><p>双亲表示法:每个节点都有一个指向其父节点的指针<br>孩子表示法:每个节点都有一个指向其第一个孩子节点的指针，如果一个节点有多个孩子，可以使用链表将它们链接起来<br>孩子兄弟表示法:每个节点都有一个指向其第一个孩子节点和其右兄弟节点的指针<br>二叉树线性存储：用一组连续的存储单元来存放二叉树的数据元素</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>完全二叉树<br>除最后一层外，每一层的结点数都达到最大值，最后一层的结点，连续集中在最左边</p><p>堆是一颗完全二叉树，任何一个分支节点都不大于（或不小于）其左右结点的值，可以分为大顶堆、小顶堆</p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>给定n个权值作为n个叶子节点，构造一棵带权路径长度最小的二叉树叫做最优二叉树，即哈夫曼树</p><p>结点的带权路径长度:树的根结点到该结点的路径长度和该结点权重的乘积</p><p>树的带权路径长度WPL:哈夫曼树中，所有叶子结点的带权路径长度之和</p><p>构造方法:每次从森林中取出两个根节点权值最小的子树合并，分别作为新树的左右子树，新树的根节点的权值为左右子树根节点权值之和。重复n-1次这个操作，最后森林中仅剩的一棵树即是哈夫曼树。</p><p>应用:哈夫曼编码，减少编码长度</p><h3 id="最小生成树两种算法优缺点比较"><a href="#最小生成树两种算法优缺点比较" class="headerlink" title="最小生成树两种算法优缺点比较"></a>最小生成树两种算法优缺点比较</h3><p>最小生成树:寻找原图中包含n个结点边权值和最小的极小联通子图</p><p>prim:基于贪心策略，先选择一个初始点加入点集S，然后从点集S中选出弧尾未被标记且边权最小的点继续加入点集S，重复上述操作，直至图中所有的点都被收录到S中，只跟结点数有关，适用于稠密图<br>kruskal:基于贪心策略，贪心地从边集中选出一条最短的边，并使用并查集判断加入边是否会使生成树形成环，如果会，就跳过这条边，直至最后选出n-1条边，只跟边数有关，适用于稀疏图</p><h3 id="图的遍历方式"><a href="#图的遍历方式" class="headerlink" title="图的遍历方式"></a>图的遍历方式</h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>首先访问出发点V，然后访问与V邻接的未被访问的点W，直至访问完与V连通的所有结点，若还有结点未被访问，就继续重复上述操作，直至将所有图中所有的点都访问过</p><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>首先访问出发点V，并将V加入到队列中，然后弹出队列中的结点，依次访问与其邻接的且未被访问的点，并加入队列中，重复上述操作，直至将所顶点都访问过</p><h3 id="图的存储方式"><a href="#图的存储方式" class="headerlink" title="图的存储方式:"></a>图的存储方式:</h3><p>邻接矩阵 适合表示稠密图，需要较大的存储空间<br>邻接表 适合表示稀疏图，能节省存储空间，能够快速找到它的邻边<br>十字链表 针对有向图<br>邻接多重表 针对无向图</p><h3 id="快速排序的流程"><a href="#快速排序的流程" class="headerlink" title="快速排序的流程"></a>快速排序的流程</h3><p>从区间中选定一个主元，将区间划分为左、右两个子区间<br>接着可以使用插空法将大于等于主元的放到右区间，小于等于主元的放到左区间<br>同理，对主元左右两个子区间进行上述操作，直至整体有序</p><h3 id="简述背包问题"><a href="#简述背包问题" class="headerlink" title="简述背包问题"></a>简述背包问题</h3><p>背包是一个动态规划问题，问题的描述是给定一组具有重量和价值的物品，在限定重量的背包内如何放下总价值最大的物品。</p><p>可以用dp[i][j]代表前i件物品放入j容量的背包中的最大容量，对于这种情况，总共可以有两种选择，一、不放第i件物品，问题就转化为i-1件物品放入j容量的背包的情况即dp[i-1][j]，二、放第i件物品，问题就转化为i-1件物品放入j-第i件物品重量的问题，所以第i层的状态可以由i-1层状态转移过来，所以可以从初试层一直递推下去得到背包问题的最优结果</p><h3 id="KMP的主要思想"><a href="#KMP的主要思想" class="headerlink" title="KMP的主要思想"></a>KMP的主要思想</h3><p>建立一个next数组用于存储失配结点的跳转位置，实际上是<strong>存储了模式串的最大相同前后缀长度</strong>，当在某一个位置失配时，可以将模式串的前缀滑动到后缀相同的位置，从而主串匹配的位置i无需回溯，并继续从该位置继续比较</p><h3 id="二叉搜索树的优缺点"><a href="#二叉搜索树的优缺点" class="headerlink" title="二叉搜索树的优缺点"></a><strong>二叉搜索树的优缺点</strong></h3><p>二叉搜索树查找速度快、查找方便（logn时间）。但是其维护困难，且数据的插入和删除十分的复杂。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><p>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。操作系统本质上是一个运行在计算机上的软件程序 ，主要用于管理计算机硬件和软件资源。 </p><h3 id="操作系统实现的功能"><a href="#操作系统实现的功能" class="headerlink" title="操作系统实现的功能"></a>操作系统实现的功能</h3><ul><li><strong>进程和线程的管理</strong>：进程的创建、撤销、阻塞、唤醒，进程间的通信等。</li><li><strong>存储管理</strong>：内存的分配和管理、外存（磁盘等）的分配和管理等。</li><li><strong>文件管理</strong>：文件的读、写、创建及删除等。</li><li><strong>设备管理</strong>：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。</li><li><strong>网络管理</strong>：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。</li><li><strong>安全管理</strong>：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。</li></ul><h3 id="什么是用户态和内核态"><a href="#什么是用户态和内核态" class="headerlink" title="什么是用户态和内核态"></a>什么是用户态和内核态</h3><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ul><li><strong>用户态(User Mode)</strong> : 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当应用程序需要执行某些需要特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起系统调用请求，进入内核态。</li><li>**内核态(Kernel Mode)**：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。</li></ul><p>内核态相比用户态拥有更高的特权级别，因此能够执行更底层、更敏感的操作。不过，由于进入内核态需要付出较高的开销（需要进行一系列的上下文切换和权限检查），应该尽量减少进入内核态的次数，以提高系统的性能和稳定性。</p><h3 id="只有一个内核态不行吗"><a href="#只有一个内核态不行吗" class="headerlink" title="只有一个内核态不行吗"></a>只有一个内核态不行吗</h3><ul><li>在 CPU 的所有指令中，有一些指令是比较危险的比如内存分配、设置时钟、IO 处理等，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成灾难性地影响。因此，我们需要限制这些危险指令只能内核态运行。这些只能由操作系统内核态执行的指令也被叫做 <strong>特权指令</strong> 。</li><li>如果计算机系统中只有一个内核态，那么所有程序或进程都必须共享系统资源，例如内存、CPU、硬盘等，这将导致系统资源的竞争和冲突，从而影响系统性能和效率。并且，这样也会让系统的安全性降低，毕竟所有程序或进程都具有相同的特权级别和访问权限。</li></ul><h3 id="用户态和内核态是如何切换的"><a href="#用户态和内核态是如何切换的" class="headerlink" title="用户态和内核态是如何切换的"></a>用户态和内核态是如何切换的</h3><ol><li>系统调用</li><li>中断</li><li>异常</li></ol><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间</p></li><li><p>线程是比进程更小的执行单位，它是在一个进程中独立的控制流，一个进程可以启动多个线程，每条线程并行执行不同的任务。</p></li></ul><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul><li>线程是进程划分成更小的运行单位，一个进程在其执行的过程中可以产生多个线程。</li><li>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li><li>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</li></ul><h3 id="有了进程为什么还要有线程"><a href="#有了进程为什么还要有线程" class="headerlink" title="有了进程为什么还要有线程"></a>有了进程为什么还要有线程</h3><ul><li>进程切换是一个开销很大的操作，线程切换的成本较低。</li><li>线程更轻量，一个进程可以创建多个线程。</li><li>多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。</li><li>同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。</li></ul><h3 id="线程间的同步方式"><a href="#线程间的同步方式" class="headerlink" title="线程间的同步方式"></a>线程间的同步方式</h3><ul><li>互斥锁</li><li>读写锁</li><li>信号量</li><li>屏障</li><li>事件</li></ul><h3 id="进程的几种状态"><a href="#进程的几种状态" class="headerlink" title="进程的几种状态"></a>进程的几种状态</h3><blockquote><p>PCB，进程控制块</p></blockquote><ul><li>创建</li><li>就绪</li><li>运行</li><li>阻塞</li><li>结束</li></ul><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>进程间通信方式有以下几种：</p><p>1、<strong>管道通信</strong></p><p>匿名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 有名管道是半双工的通信方式，数据只能单向流动。</p><p>2、<strong>消息队列</strong></p><p>3、<strong>共享内存</strong>。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p><p>4、<strong>信号量</strong>。信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>5、套接字</p><h3 id="进程调度的衡量标准是什么？"><a href="#进程调度的衡量标准是什么？" class="headerlink" title="进程调度的衡量标准是什么？"></a>进程调度的衡量标准是什么？</h3><ul><li>CPU利用率</li><li>系统吞吐量</li><li>周转时间</li><li>等待时间</li><li>响应时间</li></ul><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ul><li>先来先服务</li><li>短作业优先</li><li>高相应比优先</li><li>时间片轮转</li><li>优先级调度</li></ul><h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h3><ul><li>阻塞</li><li>挂起</li><li>执行</li></ul><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器可以做到并发。比如有两个进程<code>A</code>和<code>B</code>，<code>A</code>运行一个时间片之后，切换到<code>B</code>，<code>B</code>运行一个时间片之后又切换到<code>A</code>。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。</p><p>并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。</p><h3 id="多线程相较单线程的好处"><a href="#多线程相较单线程的好处" class="headerlink" title="多线程相较单线程的好处"></a>多线程相较单线程的好处</h3><p>1、并发提升程序执行效率</p><p>2、提升CPU利用率，访存的时候可以切换线程来执行</p><p>3、更快的响应速度，可以有专门的线程来监听用户请求和专门的线程来处理请求。比如监听线程和工作线程是两个线程，这样监听就负责监听，工作的就负责工作，监听到用户请求马上把请求转到工作线程去处理，监听线程继续监听</p><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，它们都将无法推进下去。</p><h3 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h3><ol><li>互斥</li><li>占有并等待</li><li>非抢占</li><li>循环等待</li></ol><h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><ul><li>预防</li><li>避免</li><li>检测</li><li>解除</li></ul><h3 id="内存管理主要做了什么"><a href="#内存管理主要做了什么" class="headerlink" title="内存管理主要做了什么"></a>内存管理主要做了什么</h3><ol><li>内存的分配与回收</li><li>地址转换</li><li>内存扩充</li><li>内存映射</li><li>内存优化</li><li>内存安全</li></ol><h3 id="什么是物理地址和虚拟地址"><a href="#什么是物理地址和虚拟地址" class="headerlink" title="什么是物理地址和虚拟地址"></a>什么是物理地址和虚拟地址</h3><p><strong>物理地址（Physical Address）</strong> 是真正的物理内存中地址，更具体点来说是内存地址寄存器中的地址。程序中访问的内存地址不是物理地址，而是 <strong>虚拟地址（Virtual Address）</strong> 。</p><p>也就是说，我们编程开发的时候实际就是在和虚拟地址打交道。比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的虚拟地址。</p><h3 id="什么是分页？"><a href="#什么是分页？" class="headerlink" title="什么是分页？"></a>什么是分页？</h3><blockquote><p>把主存（物理内存）分为连续等长的物理页，应用程序的虚拟地址空间划也被分为连续等长的虚拟页。现代操作系统广泛采用分页机制。</p></blockquote><p>把内存空间划分为<strong>大小相等且固定的块</strong>，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，<strong>因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。</strong></p><p>访问分页系统中内存数据需要<strong>两次的内存访问</strong> (一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。</p><h3 id="什么是分段？"><a href="#什么是分段？" class="headerlink" title="什么是分段？"></a>什么是分段？</h3><blockquote><p>不同于分段机制下不同长度的段。</p></blockquote><p><strong>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</strong></p><p>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。</p><h3 id="分页和分段有什么区别？"><a href="#分页和分段有什么区别？" class="headerlink" title="分页和分段有什么区别？"></a>分页和分段有什么区别？</h3><ul><li>分页对程序员是透明的，但是分段需要程序员显式划分每个段。</li><li>分页的地址空间是一维地址空间，分段是二维的。</li><li>页的大小不可变，段的大小可以动态改变。</li><li>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><ul><li>都是非连续内存管理的方式。</li><li>都采用了地址映射的方法，将虚拟地址映射到物理地址，以实现对内存的管理和保护。</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li><p>分页机制以页面为单位进行内存管理，而分段机制以段为单位进行内存管理。页的大小是固定的，由操作系统决定，通常为 2 的幂次方。而段的大小不固定，取决于我们当前运行的程序。</p></li><li><p>页是物理单位，即操作系统将物理内存划分成固定大小的页面，每个页面的大小通常是 2 的幂次方，例如 4KB、8KB 等等。而段则是逻辑单位，是为了满足程序对内存空间的逻辑需求而设计的，通常根据程序中数据和代码的逻辑结构来划分。</p></li><li><p>分段机制容易出现外部内存碎片，即在段与段之间留下碎片空间(不足以映射给虚拟地址空间中的段)。分页机制解决了外部内存碎片的问题，但仍然可能会出现内部内存碎片。</p></li><li><p>分页机制采用了页表来完成虚拟地址到物理地址的映射，页表通过一级页表和二级页表来实现多级映射；而分段机制则采用了段表来完成虚拟地址到物理地址的映射，每个段表项中记录了该段的起始地址和长度信息。</p></li><li><p>分页机制对程序没有任何要求，程序只需要按照虚拟地址进行访问即可；而分段机制需要程序员将程序分为多个段，并且显式地使用段寄存器来访问不同的段。</p></li></ul><h3 id="常见的磁盘调度算法"><a href="#常见的磁盘调度算法" class="headerlink" title="常见的磁盘调度算法"></a>常见的磁盘调度算法</h3><ol><li>先来先服务</li><li>最短寻道时间</li><li>扫描</li><li>循环扫描</li><li>边扫描边观察</li><li>均衡循环扫描</li></ol><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>启动mysql服务：<code>mysql [-h 127.0.0.1] [-P 3306] -u root -p</code></p><blockquote><p>-h 指定的是连接的是哪个ip，-p指定的是连接的是哪个端口</p><p>查看当前的mysql服务开在哪个端口上，<code>show global variables like 'port'</code></p></blockquote><p>ddl，数据定义语言，定义数据库对象</p><p>dml，数据操作语言，用来对数据库表中的数据进行增删改</p><p>dql，数据查询语言，查询库中表的记录</p><p>dcl，数据控制语言，用来创建数据库用户，控制数据库的访问权限</p><p>char   性能好，定长，多余的空间用空格占位</p><p>varchar  性能稍差，变长，用多少占用多少，自动计算</p><h3 id="什么是关系型数据库"><a href="#什么是关系型数据库" class="headerlink" title="什么是关系型数据库"></a>什么是关系型数据库</h3><p>顾名思义，关系型数据库（RDB，Relational Database）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p><p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p><h3 id="MySQL的字段类型"><a href="#MySQL的字段类型" class="headerlink" title="MySQL的字段类型"></a>MySQL的字段类型</h3><ul><li><strong>数值类型</strong>：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）</li><li><strong>字符串类型</strong>：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。</li><li><strong>日期时间类型</strong>：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。</li></ul><h3 id="什么是ER图"><a href="#什么是ER图" class="headerlink" title="什么是ER图"></a>什么是ER图</h3><blockquote><p>实体联系图，提供了表示实体类型，属性和联系的方法</p></blockquote><h3 id="主键和外键有什么区别"><a href="#主键和外键有什么区别" class="headerlink" title="主键和外键有什么区别"></a>主键和外键有什么区别</h3><p>**主键(主码)**：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</p><p>**外键(外码)**：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</p><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tb_user(</span><br><span class="line">  id INT COMMENT '编号',</span><br><span class="line">name VARCHAR(50) COMMENT '姓名',</span><br><span class="line">age INT COMMENT '年龄',</span><br><span class="line">gender VARCHAR(1) COMMENT '性别'</span><br><span class="line">) COMMENT '用户表';</span><br><span class="line"></span><br><span class="line">DESC tb_user;</span><br><span class="line">show CREATE TABLE tb_user;</span><br><span class="line"></span><br><span class="line">ALTER TABLE tb_user ADD teacher VARCHAR(10); -- 添加字段</span><br><span class="line">ALTER TABLE tb_user CHANGE teacher newteacher VARCHAR(20); -- 修改字段名</span><br><span class="line">ALTER TABLE tb_user DROP newteacher; -- 删除字段</span><br><span class="line">ALTER TABLE tb_user RENAME TO user; -- 修改表名</span><br><span class="line"></span><br><span class="line">CREATE TABLE demo(</span><br><span class="line">  id INT</span><br><span class="line">);</span><br><span class="line">DROP TABLE demo; -- 删除表</span><br><span class="line">TRUNCATE TABLE demo; -- 删除表，重新创建一个名字相同的新表</span><br></pre></td></tr></tbody></table></figure><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO user (id,name,age) VALUES(12,'zhangsan',88); -- 给指定的字段添加数据</span><br><span class="line">INSERT INTO user VALUES(12,'lisi',22,'男'); -- 给整张表添加数据</span><br><span class="line">INSERT INTO user (id,name,age) VALUES(12,'zhadngsan',88),(1,'zhangsdsan',88),(2,'zhangsan',88); -- 批量添加数据</span><br><span class="line"></span><br><span class="line">UPDATE user SET id = 1,name = 2 WHERE id&gt;1; -- 如果没有条件，则会修改整张表的所有数据</span><br><span class="line"></span><br><span class="line">DELETE FROM user WHERE gender = '男'</span><br></pre></td></tr></tbody></table></figure><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><blockquote><p>基本查询，条件查询，聚合函数，分组查询，排序查询，分页查询</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">      字段列表</span><br><span class="line">FROM  </span><br><span class="line">      表名列表</span><br><span class="line">GROUP BY</span><br><span class="line">      分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">      分组后条件列表</span><br><span class="line">ORDER BY</span><br><span class="line">      排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">      分页参数</span><br></pre></td></tr></tbody></table></figure><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><blockquote><p>FROM</p><p>WHERE</p><p>GROUP BY</p><p>HAVING</p><p>SELECT</p><p>ORDER BY</p><p>LIMIT</p></blockquote><h4 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from user;</span><br><span class="line">select id from user;</span><br><span class="line">select id as '用户的id' from user;</span><br><span class="line">select distinct id from user;</span><br></pre></td></tr></tbody></table></figure><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from user</span><br><span class="line">where name is not null;</span><br></pre></td></tr></tbody></table></figure><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>执行顺序：where &gt; 聚合函数 &gt; having</p><p>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select dept_id, count(*)</span><br><span class="line">from emp</span><br><span class="line">where id &lt;= 5</span><br><span class="line">group by dept_id</span><br><span class="line">having count(*) &lt; 2;</span><br></pre></td></tr></tbody></table></figure><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><p>多字段排序，当第一个字段值相同的时候，根据第二个字段进行排序。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">order by dept_id desc, age;</span><br></pre></td></tr></tbody></table></figure><h4 id="排序查询-1"><a href="#排序查询-1" class="headerlink" title="排序查询"></a>排序查询</h4><p><code>select 字段列表 from 表名 limit 起始索引，查询记录数</code></p><ul><li>起始索引从0开始，起始索引 = （查询页码 - 1）*每页显示记录数</li><li>分页查询是数据库的方言，不同的数据库有不同的表现，MySQL中是limit</li><li>如果查询的是第一页的数据，起始索引可以省略，直接简写为limit 10</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">limit 0,2;</span><br><span class="line"></span><br><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">limit 1,3;</span><br></pre></td></tr></tbody></table></figure><h3 id="sql的几种子句是什么？顺序是什么？"><a href="#sql的几种子句是什么？顺序是什么？" class="headerlink" title="sql的几种子句是什么？顺序是什么？"></a>sql的几种子句是什么？顺序是什么？</h3><p>五个子句：</p><ul><li>from：组装来自不同数据源的数据</li><li>where：基于指定的条件对记录进行筛选</li><li>group by：将数据划分为多个分组</li><li>having：聚集函数进行计算</li><li>order by：对结果进行排序</li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><p>封装是对象功能内聚的表现形式，在抽象基础上决定信息是否公开及公开等级，核心问题是以什么方式暴漏哪些信息。主要任务是对属性、数据、敏感行为实现隐藏，对属性的访问和修改必须通过公共接口实现。封装使对象关系变得简单，降低了代码耦合度，方便维护。</p><p>迪米特原则就是对封装的要求，即 A 模块使用 B 模块的某接口行为，对 B 模块中除此行为外的其他信息知道得应尽可能少。不直接对 public 属性进行读取和修改而使用 getter/setter 方法是因为假设想在修改属性时进行权限控制、日志记录等操作，在直接访问属性的情况下无法实现。如果将 public 的属性和行为修改为 private 一般依赖模块都会报错，因此不知道使用哪种权限时应优先使用 private。</p><p>继承用来扩展一个类，子类可继承父类的部分属性和行为使模块具有复用性。继承是”is-a”关系，可使用里氏替换原则判断是否满足”is-a”关系，即任何父类出现的地方子类都可以出现。如果父类引用直接使用子类引用来代替且可以正确编译并执行，输出结果符合子类场景预期，那么说明两个类符合里氏替换原则。</p><p>多态以封装和继承为基础，根据运行时对象实际类型使同一行为具有不同表现形式。降低代码的耦合性。多态指在编译层面无法确定最终调用的方法体，在运行期由 JVM 动态绑定，调用合适的重写方法。由于重载属于静态绑定，本质上重载结果是完全不同的方法，因此多态一般专指重写。</p><h3 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h3><p>重载指方法名称相同，但参数类型个数不同，是行为水平方向不同实现。</p><p>重写指子类实现接口或继承父类时，保持方法签名完全相同，实现不同方法体，是行为垂直方向不同实现。</p><hr><h2 id="2024-8-28-17-30-线上"><a href="#2024-8-28-17-30-线上" class="headerlink" title="2024.8.28 17:30 线上"></a>2024.8.28 17:30 <code>线上</code></h2><h3 id="准备PPT了吗"><a href="#准备PPT了吗" class="headerlink" title="准备PPT了吗"></a>准备PPT了吗</h3><p>对不起，没有，我不知道需要做</p><blockquote><p>算是一次正式的面试，所以需要制作ppt</p></blockquote><h3 id="你使用go语言开发什么应用"><a href="#你使用go语言开发什么应用" class="headerlink" title="你使用go语言开发什么应用"></a>你使用go语言开发什么应用</h3><p>我一般使用gin框架开发web应用服务端</p><h3 id="你有C-的开发经验吗"><a href="#你有C-的开发经验吗" class="headerlink" title="你有C++的开发经验吗"></a>你有C++的开发经验吗</h3><p>没有，cpp只是打算法竞赛的时候作为解题的语言使用</p><h3 id="介绍一下你的大创项目"><a href="#介绍一下你的大创项目" class="headerlink" title="介绍一下你的大创项目"></a>介绍一下你的大创项目</h3><p>我突然紧张了一下，脑子空了一下，直接回答的本质上就是一个对象存储和大语言模型结合的本地知识库智能问询，知识挖掘的部分使用向量数据库的相似性检索。</p><p>&lt;项目以人工智能赋能数据存储为出发点，通过将大语言模型和对象存储功能有机结合，创建了一套兼具数据安全、资料存储、知识挖掘与智能问答的平台。深入挖掘文件知识，提供精准的智能咨询。结合对象存储，打造个性化文件管家，提升文件存取效率和协作能力。私有化部署保障数据安全，简化硬件需求，优化用户体验。&gt;</p><h3 id="知识库进行知识挖掘的过程是什么样的"><a href="#知识库进行知识挖掘的过程是什么样的" class="headerlink" title="知识库进行知识挖掘的过程是什么样的"></a>知识库进行知识挖掘的过程是什么样的</h3><blockquote><p>就是用户提问，然后到你们的题库中去匹配吗，我这样理解对吗</p></blockquote><p>不对，读取用户上传的文件，对特定格式的文件进行预处理，分词，embedding向量化，将得到的向量数据存储到向量数据库中，用户提问，对用户做出的提问进行向量化，在向量数据库中进行搜索，找出自相似的几条向量数据，将向量数据库的输出内容输出给大语言模型进行处理，生成用户能够理解的具有一定逻辑性的回答。</p><ol><li><strong>向量化处理</strong>：首先，原始数据（如文本、图像等）需要通过嵌入模型转换成向量形式。这些向量能够捕捉数据的关键特征，并以数值形式表示，便于机器处理和比较 。</li><li><strong>存储与索引</strong>：生成的向量数据随后被存储在向量数据库中，并建立相应的索引，以优化搜索效率。不同的向量数据库如Chroma、Milvus、Faiss、Weaviate等，提供了不同的索引结构和算法来加速向量搜索过程 。</li><li><strong>相似性搜索</strong>：当用户提出查询时，查询同样被转换成向量形式，并在向量数据库中执行相似性搜索，找到与查询向量最相似的向量。这个过程通常利用余弦相似度、欧氏距离等度量标准来评估向量之间的相似度 。</li><li><strong>信息检索</strong>：搜索结果通常是一组与查询向量最相似的数据向量。这些向量可以代表相关的文档、图像或其他类型的数据。</li><li><strong>LLM处理</strong>：检索到的向量或相关数据随后被用作上下文信息，输入到大型语言模型中。LLM利用这些信息生成自然语言响应，以回答用户的查询。在这个过程中，LLM可以结合检索到的知识与用户的具体需求，生成更加准确和有帮助的回答 。</li><li><strong>结果优化</strong>：为了提高生成内容的质量和相关性，可以对LLM进行微调，使其更好地适应特定的业务场景或领域知识 。</li><li><strong>用户反馈</strong>：最后，生成的内容可以展示给用户，并根据用户的反馈进行迭代优化，以不断提升系统的性能和用户体验。</li></ol><h3 id="大语言模型在项目中起到了什么样的作用"><a href="#大语言模型在项目中起到了什么样的作用" class="headerlink" title="大语言模型在项目中起到了什么样的作用"></a>大语言模型在项目中起到了什么样的作用</h3><p>大模型输入输出都是文字文本，但是模型实际接触和学习数据是向量化文本</p><p>LLM处理：检索到的向量或相关数据随后被用作上下文信息，输入到大型语言模型中。LLM利用这些信息生成自然语言响应，以回答用户的查询。在这个过程中，LLM可以结合检索到的知识与用户的具体需求，生成更加准确和有帮助的回答 。</p><h3 id="用到是哪个公司的大预言模型"><a href="#用到是哪个公司的大预言模型" class="headerlink" title="用到是哪个公司的大预言模型"></a>用到是哪个公司的大预言模型</h3><ul><li>百度：文心一言</li><li>阿里：通义千问</li><li>OpenAI：Chat-GPT</li></ul><p>else</p><ul><li>腾讯：混元助手</li><li>华为：盘古</li><li>科大讯飞：讯飞星火</li><li>清华智谱：“ChatGLM”大模型</li></ul><h3 id="你有什么特别感兴趣的算法吗"><a href="#你有什么特别感兴趣的算法吗" class="headerlink" title="你有什么特别感兴趣的算法吗"></a>你有什么特别感兴趣的算法吗</h3><p>这个被问懵了，本来是想回答我感觉巧妙的算法，比如KMP</p><p>但是具体的解释遗忘了，就给模糊过去了</p><p>“之前学过的算法都是一些常用的，没有什么特别感兴趣的”</p><h3 id="我看你给了一个个人网站的链接，这你有什么用吗"><a href="#我看你给了一个个人网站的链接，这你有什么用吗" class="headerlink" title="我看你给了一个个人网站的链接，这你有什么用吗"></a>我看你给了一个个人网站的链接，这你有什么用吗</h3><p>平时学习的时候记一些个人博客</p><h3 id="你的研究生的计划是什么"><a href="#你的研究生的计划是什么" class="headerlink" title="你的研究生的计划是什么"></a>你的研究生的计划是什么</h3><p>继续在计算机领域深造，之前学习的东西太浅显，还希望继续学习</p><p><code>moreover</code></p><p>•本科期间学习的内容都比较浅显，希望能在读研期间更深入学习计算机领域的相关知识。</p><p>•提高抗压能力和保持积极乐观的心态。</p><p>•端正态度，积极阅读专业相关论著，勤于思考。</p><p>•与导师和组内的其他同学积极交流，开拓科研视野。扎实完成科研和其他课题任务，提高自主创新能力。</p><p>•毕业找一份心仪工作。</p><h3 id="研究生的压力能够承受了吗"><a href="#研究生的压力能够承受了吗" class="headerlink" title="研究生的压力能够承受了吗"></a>研究生的压力能够承受了吗</h3><blockquote><p>强调了毕业的条件要做出一定的成果，询问一天能够在学习的时间，一周中能够工作的时间，之前有高强度地进行开发的经历吗</p></blockquote><h3 id="你有没有需要询问的问题"><a href="#你有没有需要询问的问题" class="headerlink" title="你有没有需要询问的问题"></a>你有没有需要询问的问题</h3><p>去广州会提供宿舍吗</p><blockquote><p>先在西安上学，之后到广研院，都提供宿舍</p></blockquote><p>面试的结果什么时候会出</p><blockquote><p>一两天，邮件通知，这两天我都在面试学生</p></blockquote><hr><h2 id="2024-9-23-西电广研院"><a href="#2024-9-23-西电广研院" class="headerlink" title="2024.9.23 西电广研院"></a>2024.9.23 <code>西电广研院</code></h2><blockquote><p>面试的顺序是按姓名拼音排序的，我排在了本场的倒数第三名去面试。</p><p>西电广研院今年的面试没有问及专业课的问题，考察英语能力也仅是英文的自我介绍，会问一道考察思想政治素质的题目，主要是围绕你所写的项目去展开。</p></blockquote><h3 id="英文自我介绍，一分钟"><a href="#英文自我介绍，一分钟" class="headerlink" title="英文自我介绍，一分钟"></a>英文自我介绍，一分钟</h3><h3 id="谈谈你对文化自信的理解"><a href="#谈谈你对文化自信的理解" class="headerlink" title="谈谈你对文化自信的理解"></a>谈谈你对文化自信的理解</h3><h3 id="介绍一下你的项目"><a href="#介绍一下你的项目" class="headerlink" title="介绍一下你的项目"></a>介绍一下你的项目</h3><h3 id="项目中的大模型发挥了什么作用"><a href="#项目中的大模型发挥了什么作用" class="headerlink" title="项目中的大模型发挥了什么作用"></a>项目中的大模型发挥了什么作用</h3><h3 id="平时学过或者自己复现过一些深度学习算法之类的吗"><a href="#平时学过或者自己复现过一些深度学习算法之类的吗" class="headerlink" title="平时学过或者自己复现过一些深度学习算法之类的吗"></a>平时学过或者自己复现过一些深度学习算法之类的吗</h3><h3 id="项目使用开源的东西进行开发的吗"><a href="#项目使用开源的东西进行开发的吗" class="headerlink" title="项目使用开源的东西进行开发的吗"></a>项目使用开源的东西进行开发的吗</h3><h3 id="我看你打过一些反映编程能力的比赛，你平时都学过哪些算法"><a href="#我看你打过一些反映编程能力的比赛，你平时都学过哪些算法" class="headerlink" title="我看你打过一些反映编程能力的比赛，你平时都学过哪些算法"></a>我看你打过一些反映编程能力的比赛，你平时都学过哪些算法</h3><h3 id="我看你是客户端开发，所以跟大模型对接的那些东西都是另一个同学开发的对吗"><a href="#我看你是客户端开发，所以跟大模型对接的那些东西都是另一个同学开发的对吗" class="headerlink" title="我看你是客户端开发，所以跟大模型对接的那些东西都是另一个同学开发的对吗"></a>我看你是客户端开发，所以跟大模型对接的那些东西都是另一个同学开发的对吗</h3><h3 id="学过或者说看过一些关于深度学习的课程吗"><a href="#学过或者说看过一些关于深度学习的课程吗" class="headerlink" title="学过或者说看过一些关于深度学习的课程吗"></a>学过或者说看过一些关于深度学习的课程吗</h3><h3 id="你们的项目大多数都是调用接口的吗"><a href="#你们的项目大多数都是调用接口的吗" class="headerlink" title="你们的项目大多数都是调用接口的吗"></a>你们的项目大多数都是调用接口的吗</h3><h2 id="邮件文书"><a href="#邮件文书" class="headerlink" title="邮件文书"></a>邮件文书</h2><p>尊敬的xxxx老师：</p><p>您好！</p><p>我叫xxxx，是xxxx大学xxxxx专业的大四在读学生。我今年拿到了本校推免的名额，渴望能够有机会推免攻读您的硕士，想冒昧问您一下，您今年是否还有招生名额，我能否有机会得到您的指导。</p><p>在过去三年的学习生活中，我刻苦努力，力争上游，专业排名为xx/xx。我编程基础扎实，能够独立完成简单信息管理系统从需求分析到系统设计到代码实现等的工作。我曾在xxx和xxx年连续两年获xxxxx大赛xxxxx等奖，曾获xxxxx大赛全国总决赛xxxxx奖等奖项。我于今年作为负责人参加了大学生创新创业训练计划，项目获得国家级拟立项资格。</p><p>我拥有良好的英语水平，英语四级xxx分，英语六级xxx分。我为人热情大方，活泼开朗，乐观积极向上，敢于面对并解决工作学习过程中遇到的挑战。</p><p>附件为我的简历，供您参考。</p><p>冒昧致信，恳请您海涵！非常感谢您能够在百忙之中抽出时间阅信。</p><p>祝您身体健康，工作愉快！</p><p>xxxx</p><p>xxxxxx</p><p>xxxx年x月xx日</p><h2 id="EnglishProficiency"><a href="#EnglishProficiency" class="headerlink" title="EnglishProficiency"></a>EnglishProficiency</h2><h3 id="SelfIntroduction"><a href="#SelfIntroduction" class="headerlink" title="SelfIntroduction"></a>SelfIntroduction</h3><blockquote><p>Please start your introduction</p><p>Please tell me about yourself / introduce yourself</p><p>What would you like us to know about you ?</p></blockquote><blockquote><p>本身没有什么特别的长处，感觉这样也好表达，同时我想让他人了解的东西都有所提及，算是简单介绍了一下，关键要看流利度和停顿我赶脚。</p></blockquote><p>Good morning / afternoon, It’s very nice to meet you professors. It’s an honor to be here today.</p><p>My name is tammer. I’m a senior student majoring in Computer Science and Technology at …… University. I’m currently excelling in my courses, and I’m ranked second in my major. I’ve also received provincial first price award for my performance in Lanqiao Cup Competition. And our team won the provincial second prise in the Chinese Collegiate Computing Competition for two consecutive years. </p><p>In my study, I’m especially interested in Artificial Intellegence, so I formed a team to research developing applications powered by large language models. After several months of coding, we finally developed a local knowledge base question-answering system. Within my team, I was chosen to complete the concept design and client code implementation because I‘m good at front-end development.</p><p>Besides, I’m very observant, adaptable, flexible with people and situations and always ready to learn new things. I firmly believe physical fitness should be an essential part of life like eating and sleeping. So during my spare time I would go to the gym and exercise for an hour, and after that the fatigue of the day would disappear.</p><p>I believe these qualities will make me better fulfill my role as a graduate student in the future.</p><p>That’s all, thank you! </p><p><code>2 to 3 minutes</code></p><p>Good morning / afternoon, It’s very nice to meet<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>you professors. It’s an <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>honor to be here today.</p><p>My name<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> is tammer. I’m <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>a senior student majoring in Computer Science <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>and Technology at …… University. I’m currently excelling<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> in my courses, and <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>I’m ranked second in my major. Additionally, I’ve also received provincial first price <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>award for my performance in Lanqiao Cup Competition. And <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>our team won the provincial second prise in the Chinese Collegiate Computing Competition for two consecutive years. </p><p>In my study, I’m interested<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> in Artificial Intellegence, so I formed <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>a team to research developing applications powered by large language models. After several months <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>of coding, we finally developed<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> a local knowledge base question-answering system. Within my team, I was chosen to complete the concept design and client code implementation because I‘m good <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>at front-end development.</p><p>Besides, I’m very observant, adaptable, flexible with people <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>and situations and <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>always ready to learn new things. I firmly believe physical fitness should be an essential part<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> of life like eating and sleeping. So during my spare time I would go to the gym and exercise for <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>an <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>hour, and <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>after that the fatigue of the day would disappear.</p><p>I believe these qualities will make me better fulfill my role<span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> as <span class="github-emoji"><span>🔦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f526.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>a graduate student in the future.</p><p>That’s all, thank you! </p><h3 id="OtherQuestion"><a href="#OtherQuestion" class="headerlink" title="OtherQuestion"></a>OtherQuestion</h3><blockquote><p>why do you choose our school ?</p></blockquote><p>because xi’dian is famous in computer, and i want to study further in computer science and technology, so choose it, and i would be glad to enter it.</p><h2 id="行远自迩，登高自卑"><a href="#行远自迩，登高自卑" class="headerlink" title="行远自迩，登高自卑"></a>行远自迩，登高自卑</h2><blockquote><p>行远自迩，登高自卑，行走远路要从近处开始，登高山要从低处开始，比喻做事要脚踏实地，循序渐进。</p></blockquote><h2 id="思想政治素质"><a href="#思想政治素质" class="headerlink" title="思想政治素质"></a>思想政治素质</h2><h3 id="根本政治制度"><a href="#根本政治制度" class="headerlink" title="根本政治制度"></a>根本政治制度</h3><p>人民代表大会制度</p><h3 id="指导思想"><a href="#指导思想" class="headerlink" title="指导思想"></a>指导思想</h3><ul><li>马克思列宁主义</li><li>毛泽东思想</li><li>邓小平理论</li><li>“三个代表”重要思想<ol><li>代表中国先进生产力的发展要求</li><li>代表中国先进文化的前进方向</li><li>代表中国最广大人民的根本利益</li></ol></li><li>科学发展观</li><li>习近平新时代中国特色社会主义思想</li></ul><h3 id="四个自信"><a href="#四个自信" class="headerlink" title="四个自信"></a>四个自信</h3><ul><li>道路自信</li><li>理论自信</li><li>制度自信</li><li>文化自信</li></ul><h3 id="初心使命"><a href="#初心使命" class="headerlink" title="初心使命"></a>初心使命</h3><p>为中国人民谋幸福，为中华民族谋复兴</p><h3 id="新时代"><a href="#新时代" class="headerlink" title="新时代"></a>新时代</h3><p>如今实现了第一个百年奋斗目标（全面建成小康社会），开启了第二个百年奋斗目标新征程（建成富强民主文明和谐美丽的社会主义现代化强国。</p><p>我国正处于并将长期处于社会主义初级阶段</p><h3 id="执政兴国的第一要务"><a href="#执政兴国的第一要务" class="headerlink" title="执政兴国的第一要务"></a>执政兴国的第一要务</h3><p>发展，坚持以人民为中心的发展思想</p><h3 id="基本路线"><a href="#基本路线" class="headerlink" title="基本路线"></a>基本路线</h3><p>领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为一个富强民主文明和谐美丽的社会主义现代化强国而奋斗。</p><h3 id="四项基本原则"><a href="#四项基本原则" class="headerlink" title="四项基本原则"></a>四项基本原则</h3><ul><li>坚持社会主义道路</li><li>坚持人民民主专政</li><li>坚持中国共产党的领导</li><li>坚持马克思列宁主义毛泽东思想</li></ul><h3 id="入党誓词"><a href="#入党誓词" class="headerlink" title="入党誓词"></a>入党誓词</h3><p>我志愿加入中国共产党，拥护党的纲领，遵守党的章程，履行党员义务，执行党的决定，严守党的纪律，保守党的秘密，对党忠诚，积极工作，为共产主义奋斗终身，随时准备为党和人民牺牲一切，永不叛党。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>面试题部分：JavaGuide</li><li>思想政治素质部分：党章</li></ul>]]></content>
    
    
    <summary type="html">2024年9月面试的准备</summary>
    
    
    
    <category term="面试" scheme="https://dra-tammer.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="经验" scheme="https://dra-tammer.github.io/categories/%E9%9D%A2%E8%AF%95/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="推免" scheme="https://dra-tammer.github.io/categories/%E9%9D%A2%E8%AF%95/%E7%BB%8F%E9%AA%8C/%E6%8E%A8%E5%85%8D/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="面试" scheme="https://dra-tammer.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="经验" scheme="https://dra-tammer.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="推免" scheme="https://dra-tammer.github.io/tags/%E6%8E%A8%E5%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>zinx-go</title>
    <link href="https://dra-tammer.github.io/posts/b5221bcc.html"/>
    <id>https://dra-tammer.github.io/posts/b5221bcc.html</id>
    <published>2024-05-07T13:24:04.000Z</published>
    <updated>2024-05-07T13:24:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zinx-go"><a href="#zinx-go" class="headerlink" title="zinx-go"></a>zinx-go</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h3><blockquote><p>套接字是网络编程中的一种通信机制，是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p></blockquote><h4 id="为什么使用套接字"><a href="#为什么使用套接字" class="headerlink" title="为什么使用套接字"></a>为什么使用套接字</h4><blockquote><p>接打电话需要什么？</p><p>电话机</p></blockquote><p>那么套接字就相当于一个电话机，为两边建立TCP提供载体。</p><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><blockquote><p>电话号码是多少</p><p>电话号码是 ***</p></blockquote><p>调用bind函数给套接字分配地址之后，完成准备工作。</p><h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><blockquote><p>架起电话线，使得电话能够打进来</p></blockquote><p>把套接字的状态转换为可连接的状态</p><h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><blockquote><p>电话铃响</p><p>接听</p></blockquote><p>受理套接字请求</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>创建套接字</li><li>分配IP地址和端口号</li><li>状态转换为可接收请求的状态</li><li>受理套接字请求</li></ol><p>TCP客户—服务器程序的执行流程图</p><h3 id="字节和比特"><a href="#字节和比特" class="headerlink" title="字节和比特"></a>字节和比特</h3><blockquote><p>byte 是字节，一个字节8个比特位</p><p>bit 是比特</p></blockquote><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>就是假如有一个都要调用的函数<code>func_pro</code>，很多人都要用，每个人在一个固定的点上加上自己的业务，当然不能用<code>if else</code>，这时候使用者在调用这个函数的时候传入一个封装有自己业务逻辑的函数变量。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func_pro</span><span class="params">(<span class="keyword">func</span> f)</span></span> {</span><br><span class="line">    ...</span><br><span class="line">    f()</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这个函数变量就是回调函数</p></blockquote><h3 id="实例方法与静态方法"><a href="#实例方法与静态方法" class="headerlink" title="实例方法与静态方法"></a>实例方法与静态方法</h3><blockquote><p> 实例方法是实例化之后才能使用</p></blockquote><h3 id="路由是干什么的"><a href="#路由是干什么的" class="headerlink" title="路由是干什么的"></a>路由是干什么的</h3><blockquote><p>提供一个指令，指令对应的一个处理方式，指令和处理方式放在一起叫路由，不同消息不同路由</p></blockquote><h3 id="为什么在Connection中实现接口"><a href="#为什么在Connection中实现接口" class="headerlink" title="为什么在Connection中实现接口"></a>为什么在Connection中实现接口</h3><p>在Go语言中，接口（interface）是一种抽象类型，它定义了一组方法的集合，但并不实现这些方法的具体行为。接口的实现是通过类型为该接口的值来完成的，这些值可以是任何具有相应方法集的具体类型（通常是结构体）。这种设计允许多种不同的类型实现同一个接口，从而提供了一种灵活的方式来实现多态性。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IRouter <span class="keyword">interface</span> {</span><br><span class="line">    PreHandle(request IRequest)</span><br><span class="line">    Handle(request IRequest)</span><br><span class="line">    PostHandle(request IRequest)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Connection <span class="keyword">struct</span> {</span><br><span class="line">    Router ziface.IRouter</span><br><span class="line">    <span class="comment">// ... 其他字段 ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>Router</code> 字段的类型是 <code>ziface.IRouter</code> 接口。这里有几个关键点：</p><ol><li><p><strong>多态性</strong>：通过在 <code>Connection</code> 结构体中使用 <code>IRouter</code> 接口类型，您可以将任何实现了 <code>IRouter</code> 接口的具体类型赋值给 <code>Router</code> 字段。这意味着 <code>Connection</code> 可以与多种不同的路由处理逻辑一起工作，只要这些逻辑实现了 <code>IRouter</code> 接口。</p></li><li><p><strong>解耦</strong>：接口允许 <code>Connection</code> 结构体与具体的路由实现解耦。<code>Connection</code> 不需要知道 <code>Router</code> 字段的具体类型，只需要知道它实现了 <code>IRouter</code> 接口。</p></li><li><p><strong>扩展性</strong>：如果您需要添加新的路由处理逻辑，您只需创建一个新的类型并实现 <code>IRouter</code> 接口中的方法，而无需修改 <code>Connection</code> 结构体或其它使用 <code>IRouter</code> 的代码。</p></li><li><p><strong>实现接口而不是对象</strong>：在Go中，通常推荐实现接口而不是直接实现具体的对象。这是因为接口提供了一种定义契约的方式，任何类型都可以实现这个契约，从而使得代码更加灵活和可扩展。</p></li><li><p><strong>依赖注入</strong>：通过接口，可以实现依赖注入的设计模式，这是软件设计中常用的一种提高代码可测试性和可维护性的方法。</p></li></ol><p>因此，<code>Router</code> 字段被声明为接口类型，而不是一个具体的对象，是为了提供灵活性和可扩展性，同时允许 <code>Connection</code> 结构体与具体的路由实现保持解耦。</p><h2 id="基础的server"><a href="#基础的server" class="headerlink" title="基础的server"></a>基础的server</h2><ul><li><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>启动服务器</p><p>基本的服务器开发：</p><ol><li><p>创建addr </p></li><li><p>创建listenner </p></li><li><p>处理客户端的基本的业务，回显功能</p></li></ol></li><li><p>停止服务器</p></li><li><p>运行服务器</p><p>调用Start()方法，调用之后做阻塞处理，在之间可以做一个今后的一个扩展功能</p></li><li><p>初始化服务器</p></li></ul></li><li><p>属性</p><ul><li>name名称</li><li>监听的IP</li><li>监听的端口</li></ul></li></ul><p>先创建两个模块，一个是抽象层接口，一个是实现层</p><h2 id="简单的链接封装和业务绑定"><a href="#简单的链接封装和业务绑定" class="headerlink" title="简单的链接封装和业务绑定"></a>简单的链接封装和业务绑定</h2><ul><li><p>链接的模块</p><ul><li><p>方法</p><ul><li><p>启动链接start</p></li><li><p>停止链接stop</p></li><li><p>获取当前链接的conn对象（套接字）</p></li><li><p>绑定一个链接ID</p></li><li><p>得到客户端链接的地址和端口</p></li><li><p>发送数据的方法send</p><p>发送数据到客户端</p></li></ul></li><li><p>属性</p><ul><li><p>socket TCP套接字</p></li><li><p>链接的ID</p></li><li><p>当前链接的状态</p><p>是否已经关闭，关闭应该把链接给干掉或者回收掉</p></li><li><p>与当前链接所绑定的处理业务方法</p></li><li><p>等待被告知的channel告知当前链接是退出，这是一个异步过程，channel去捕获这个状态，等待链接被动退出的channel</p></li></ul></li></ul></li></ul><h2 id="基础路由模块"><a href="#基础路由模块" class="headerlink" title="基础路由模块"></a>基础路由模块</h2><p>现在我们就给用户提供一个自定义的conn处理业务的接口吧，很显然，我们不能把业务处理的方法绑死在<code>type HandFunc func(*net.TCPConn, []byte, int) error</code>这种格式中，我们需要定一些<code>interface{}</code>来让用户填写任意格式的连接处理业务方法。</p><p>那么，很显然func是满足不了我们需求的，我们需要再做几个抽象的接口类。</p><h3 id="request请求封装"><a href="#request请求封装" class="headerlink" title="request请求封装"></a>request请求封装</h3><blockquote><p>将连接和数据绑定在一起，看成一个元子的请求包</p><p>router应该是基于这个request包进行处理</p></blockquote><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li>链接IConnection</li><li>请求数据</li></ul><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul><li>得到当前连接</li><li>得到当前数据</li></ul><h3 id="Router模块"><a href="#Router模块" class="headerlink" title="Router模块"></a>Router模块</h3><h4 id="抽象的router"><a href="#抽象的router" class="headerlink" title="抽象的router"></a>抽象的router</h4><h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><ul><li><p>处理业务之前的方法（钩子）</p></li><li><p>处理业务的主方法</p></li><li><p>处理业务之后的方法（钩子）</p></li></ul><h4 id="具体的BaseRouter"><a href="#具体的BaseRouter" class="headerlink" title="具体的BaseRouter"></a>具体的BaseRouter</h4><h5 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h5><ul><li><p>处理业务之前的方法（钩子）</p></li><li><p>处理业务的主方法</p></li><li><p>处理业务之后的方法（钩子）</p></li></ul><h4 id="自定义的router"><a href="#自定义的router" class="headerlink" title="自定义的router"></a>自定义的router</h4><p>继承BaseRouter去重写方法</p><h4 id="为什么还要搞一个BaseRouter"><a href="#为什么还要搞一个BaseRouter" class="headerlink" title="为什么还要搞一个BaseRouter"></a>为什么还要搞一个BaseRouter</h4><p>因为如果每一个自定义的router都继承接口，就要实现接口中的所有方法，但是我们不一定需要hook函数。所以baserouter先空实现接口的方法，然后再让自定义的router去继承baserouter，实现自己想要的函数</p><h3 id="zinx集成router模块"><a href="#zinx集成router模块" class="headerlink" title="zinx集成router模块"></a>zinx集成router模块</h3><ul><li>IServer增添路由添加功能</li><li>Server类增添Router成员</li><li>Connection类绑定一个Router成员</li><li>在Connection调用已经注册的Router处理业务</li></ul><h2 id="Q-S"><a href="#Q-S" class="headerlink" title="Q&amp;S"></a>Q&amp;S</h2><blockquote><p>在这个包去import其他包的东西的时候会爆红，取消勾选</p></blockquote><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable <span class="keyword">go</span> modules integration</span><br></pre></td></tr></tbody></table></figure><hr><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server.<span class="keyword">go</span>:<span class="number">3</span>:<span class="number">8</span>: <span class="keyword">package</span> zinx-<span class="keyword">go</span>/znet is not in GOROOT (D:\Environment\Go\src\zinx-<span class="keyword">go</span>\znet)</span><br></pre></td></tr></tbody></table></figure><p>需要引入本地包的话，需要在go.mod中进行修改，两个项目都在src目录下，如下即可解决问题。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require <span class="string">"zinx-go"</span> v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">replace <span class="string">"zinx-go"</span> =&gt; <span class="string">"../zinx-go"</span></span><br></pre></td></tr></tbody></table></figure><hr>]]></content>
    
    
    <summary type="html">学习zinx的工程中的笔记</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="go" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/go/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="go" scheme="https://dra-tammer.github.io/tags/go/"/>
    
    <category term="项目" scheme="https://dra-tammer.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>追风筝的人</title>
    <link href="https://dra-tammer.github.io/posts/ab39eefc.html"/>
    <id>https://dra-tammer.github.io/posts/ab39eefc.html</id>
    <published>2024-04-24T03:02:39.000Z</published>
    <updated>2024-04-24T03:02:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>start from 2024-04-12</code></p><p><code>end on 2024-04-24</code></p><p><code>卡勒德·胡塞尼</code></p>]]></content>
    
    
    <summary type="html">作者：卡勒德·胡塞尼</summary>
    
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>杀死一只知更鸟</title>
    <link href="https://dra-tammer.github.io/posts/842c0a9a.html"/>
    <id>https://dra-tammer.github.io/posts/842c0a9a.html</id>
    <published>2024-04-10T02:27:04.000Z</published>
    <updated>2024-04-10T02:27:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>start from 2024-04-03</code></p><p><code>end on 2024-04-10</code></p><p><code>哈珀·李</code></p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>我是通过微信读书的榜单知道这本书的，刚开始阅读的时候并没有这么上瘾，在交代斯库特，杰姆，迪尔他们的童年生活，一开始很疑惑这个阿迪克斯是什么人，随着阅读的深入，发现是他们的爸爸。他允许自己的孩子呼喊自己的名字，这点很特殊。幼年的孩子们天真烂漫，富有好奇心，他们想瞥见怪人拉德利的生活，并无恶意地去“打扰”怪人的生活，最后也获得了回应，树洞里的礼物证明了这一点，但是最后树洞被水泥封上了。之后故事围绕汤姆的强奸案展开，从这开始，我逐渐开始上瘾。黑人被最底层的白人造谣强奸，在当时的社会这是要判处死刑，但是阿迪克斯根据证据发现他是清白的。他一直努力在帮助黑人脱罪，但是最后还是杀不死人们一贯的偏见。汤姆也摆脱不了固有的天性，反抗被枪杀。在这个过程上，我和周围人都在不停地成长，周围人的形象也在一步一步地立体了起来。本书以尤厄尔的死亡告终，赫克和阿迪克斯都在用自己的方式去帮助那个怪人，去守护那一片纯真的心灵。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><blockquote><p>阿迪克斯是一位伟大的父亲，也是普通人的榜样</p></blockquote><p>阿迪克斯是一名律师，为他人声张正义，他一直为自己内心的正义工作，即便受到死亡威胁，他也不害怕。能够克服当时固有的种族歧视去帮助一个黑人脱罪。虽然最后没有成功，但是大家都知道他是能够无偏见地去帮助每一个人去声张正义。正义之士的形象跃然纸上。</p><p>同时他也是一名父亲，对孩子们管教有加，在怪人拉德利的事情上，阿迪克斯给与了孩子们最大的探索空间，告诉孩子们危险之处在哪，但是没有过多的阻拦，只做了最基础的警告。能够陪孩子们一起看报，将自己的思想传播给孩子们，给予孩子们平等的说话权。在孩子们犯错的时候给孩子们时间去解释整个事情的流程，而不是妄加指责。他是孩子们的父亲，良师和益友。他教会孩子们为人处世的道理，耐心纠正孩子们的错误，同时又给孩子们最大的个人思考的空间。这种教育的方式值得借鉴，同时也是理想的教育方式。</p><blockquote><p>不要用自己的标准去衡量和要求别人</p></blockquote><p>小说的最后杰姆看不懂看不惯人们的做法，为什么他们明知道事实的真相，但是却选择了撒谎。他认为其他人的做法都是错的。这个对我的思考很大，最近在组队搞比赛。组内的大佬一股子恃才放旷味道，也是火上眉头，差点冲突。但是看完这本书之后一想，每个人有每个人待人处事的方式，这或许就是他这个人的特点，我们不能拿我们认为对的东西去严加要求别人应该怎么干，怎么做事。自己做事问心无愧即可。</p><blockquote><p>优秀的人懂得尊重别人</p></blockquote><p>鲁迅先生曾经说过(应该是)，我原先以为别人尊重我是因为我优秀，后来发现，别人尊重我是因为别人优秀。无论面对的是谁，都要把对方当作人去看待。</p><blockquote><p>有些道理是成长之后才会知道的</p></blockquote><p>有时候不了解父母的某些做法，是不是因为阅历不够，经验不足呢。</p><blockquote><p>低调做人，高调做事</p></blockquote><p>阿迪克斯就是这一类人，自己本身其实非常优秀，但是他并没在孩子们面前鼓吹自己有多么多么牛掰，自己跟其他的父母相比有多么多么地好，而是将自己的价值观一点一点在平时的生活中传递给孩子们。在与孩子们生活的过程中让孩子们觉得自己父亲的本事是理所应当的，是能够深刻体会到的，而不是靠嘴吹牛逼出来的。</p><p>这是大三下学期看的第一本书，清明之后集中给他看完了，看后心中平静了不少，清明左右拔了两颗牙，又碰上计设ddl，难免火气大，感谢自己撑住了三天，感谢文字，无论是课程老师传授还是文字表达，都能让我犯错或者迷茫之时找到方向，有所启发，瞥见他人思想，他人经验总结出来的精华。同时老去的心又年轻了一回hh，但是可惜。</p><p>好，再会！</p>]]></content>
    
    
    <summary type="html">作者：哈珀·李</summary>
    
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
    <category term="读书" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="读后感" scheme="https://dra-tammer.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://dra-tammer.github.io/posts/f5f9fa9b.html"/>
    <id>https://dra-tammer.github.io/posts/f5f9fa9b.html</id>
    <published>2024-02-15T06:22:52.000Z</published>
    <updated>2024-02-15T06:22:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="Windows配置Docker环境"><a href="#Windows配置Docker环境" class="headerlink" title="Windows配置Docker环境"></a>Windows配置Docker环境</h2><h3 id="启用Hyper-v"><a href="#启用Hyper-v" class="headerlink" title="启用Hyper-v"></a>启用Hyper-v</h3><ul><li>控制面板</li><li>程序</li><li>启动或关闭windows功能</li><li>Hyper-v</li></ul><h3 id="WSL及Linux分发版安装"><a href="#WSL及Linux分发版安装" class="headerlink" title="WSL及Linux分发版安装"></a>WSL及Linux分发版安装</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wsl --install </span><br><span class="line">wsl --list --online <span class="comment">// 查看可用的Linux发行版列表</span></span><br><span class="line">wsl --install -d <span class="title class_">Ubuntu</span>-<span class="number">22.04</span></span><br></pre></td></tr></tbody></table></figure><h3 id="修改WSL中系统的安装位置"><a href="#修改WSL中系统的安装位置" class="headerlink" title="修改WSL中系统的安装位置"></a>修改WSL中系统的安装位置</h3><ul><li><p>查看所有分发版本<code>wsl -l --all -v</code></p></li><li><p>导出分发版为tar文件到D盘<code>wsl --export Ubuntu-22.04 D:\Environment\ubuntu22.04.tar</code></p></li><li><p>注销当前分发版<code>wsl --unregister Ubuntu-22.04</code></p></li><li><p>重新导入并安装分发版在D盘</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --<span class="keyword">import</span> <span class="title class_">Ubuntu</span>-<span class="number">22.04</span> <span class="attr">D</span>:\<span class="title class_">Environment</span>\<span class="title class_">Ubuntu22</span><span class="number">.04</span> <span class="attr">D</span>:\<span class="title class_">Environment</span>\ubuntu22<span class="number">.04</span>.<span class="property">tar</span> --version <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>设置默认登录用户<code>ubuntu2204 config --default-user root</code></p></li><li><p>删除tar文件<code>del D:\ubuntu22.04.tar</code></p></li></ul><h3 id="DockerDesktop"><a href="#DockerDesktop" class="headerlink" title="DockerDesktop"></a>DockerDesktop</h3><p>官网下载安装<code>DockerDesktop</code>，最大的问题就是默认安装在c盘，十分占用c盘的空间</p><h4 id="更改DockerDesktop的安装目录"><a href="#更改DockerDesktop的安装目录" class="headerlink" title="更改DockerDesktop的安装目录"></a>更改DockerDesktop的安装目录</h4><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd /c mklink /j <span class="string">"C:\Program Files\Docker"</span> <span class="string">"D:\SoftWare\DockerDesktop"</span></span><br></pre></td></tr></tbody></table></figure><p>实测创建连接的方法不可行，能安装上但是<code>Docker Engine</code>无法启动，会报错<code>Docker Desktop - WSL distro terminated abruptly</code>，看来只能装到C盘，先卸载，再删除链接目录<code>rmdir D:\Software\DockerDesktop</code></p><blockquote><p>todo: 镜像安装的文件夹，没法修改，导致下载会都下载到C盘很难受</p></blockquote><p><a href="https://docker.easydoc.net/doc/81170005/cCewZWoN/lTKfePfP">🎉 Docker 简介和安装 - Docker 快速入门 - 易文档 (easydoc.net)</a></p><h2 id="为什么使用docker"><a href="#为什么使用docker" class="headerlink" title="为什么使用docker"></a>为什么使用docker</h2><p>方便测试和生产环境部署，省去很多环境配置的时间</p><h2 id="和虚拟机的区别"><a href="#和虚拟机的区别" class="headerlink" title="和虚拟机的区别"></a>和虚拟机的区别</h2><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>每台虚拟机需要占用大量的资源，启动时间长。因为需要完整的操作系统，cpu占用等。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>docker只是container的一种的实现，是一种容器化的解决方案和平台。</p><p>容器不需要在虚拟化的环境中运行一个操作系统，而是使用宿主机的操作系统，启动速度非常快。需要的资源更少，充分利用物理服务器的资源。</p><h2 id="基本原理和概念"><a href="#基本原理和概念" class="headerlink" title="基本原理和概念"></a>基本原理和概念</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>镜像是一个只读的模板，它可以用来创建容器。</p><h3 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h3><p>容器是docker的运行实例，他提供了一个独立的可移植的环境。可以在这个环境中运行应用程序。镜像和容器的关系就像java中类和实例的关系一样。</p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>存储docker镜像的地方，最流行也是常用的仓库就是dockerhub，公共的docker仓库。</p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>Client-Server架构模式，</p><h2 id="容器化和Dockerfile"><a href="#容器化和Dockerfile" class="headerlink" title="容器化和Dockerfile"></a>容器化和Dockerfile</h2><ol><li>创建一个Dockerfile</li><li>使用Dockerfile构建镜像</li><li>使用镜像创建和运行容器</li></ol><blockquote><p>如果想要在浏览器之外的环境运行javascipt的代码，就要安装node.js，通过<code>node index.js</code>运行index文件的代码</p></blockquote><h2 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h2><h3 id="镜像的构建"><a href="#镜像的构建" class="headerlink" title="镜像的构建"></a>镜像的构建</h3><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build <span class="literal">-t</span> hello<span class="literal">-docker</span> .</span><br></pre></td></tr></tbody></table></figure><h3 id="镜像的运行"><a href="#镜像的运行" class="headerlink" title="镜像的运行"></a>镜像的运行</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-docker</span><br></pre></td></tr></tbody></table></figure><h3 id="查看镜像库"><a href="#查看镜像库" class="headerlink" title="查看镜像库"></a>查看镜像库</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></tbody></table></figure><h2 id="推荐网站"><a href="#推荐网站" class="headerlink" title="推荐网站"></a>推荐网站</h2><p>play-with-docker 尝试docker的各种功能</p><h2 id="docker-desktop"><a href="#docker-desktop" class="headerlink" title="docker-desktop"></a>docker-desktop</h2><p>docker数据是非持久化的，需要持久化就使用Volumes功能。</p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><ul><li>用于定义和运行多容器Docker应用程序的工具</li><li>使用YAML文件来配置应用程序的服务</li><li>一条命令就可以创建并启动所有服务</li></ul>]]></content>
    
    
    <summary type="html">The notes on how to use Docker</summary>
    
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/docker/"/>
    
    <category term="部署" scheme="https://dra-tammer.github.io/categories/%E6%8A%80%E6%9C%AF/docker/%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="技术" scheme="https://dra-tammer.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="docker" scheme="https://dra-tammer.github.io/tags/docker/"/>
    
  </entry>
  
</feed>
